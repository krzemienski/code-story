---
phase: 01-foundation
type: execute
domain: python-agent-sdk
---

<objective>
Create the tools library using Claude Agent SDK's @tool decorator pattern (NOT class-based skills).

Purpose: Establish the tool infrastructure with @tool decorated async functions that Claude agents will use.
Output: Tool modules with placeholder implementations using proper @tool decorator pattern, ready for domain-specific implementation in later phases.
</objective>


<context>
@BRIEF.md
@ROADMAP.md
@plans/01-foundation/01-01-SUMMARY.md
@plans/01-foundation/01-02-SUMMARY.md
@plans/01-foundation/01-03-SUMMARY.md
@plans/01-foundation/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create shared utility module for tools</n>
  <files>src/codestory/tools/utils.py</files>
  <action>
    Implement shared utilities used across all tool modules:

    ```python
    # src/codestory/tools/utils.py
    """Shared utilities for Code Story tools."""

    import asyncio
    import json
    import re
    from typing import Any, TypeVar
    import httpx
    from datetime import datetime


    T = TypeVar("T")


    class ToolError(Exception):
        """Base exception for tool errors."""

        def __init__(self, message: str, code: str | None = None, details: dict | None = None):
            super().__init__(message)
            self.code = code
            self.details = details or {}


    class RateLimitError(ToolError):
        """Raised when an API rate limit is hit."""
        pass


    class APIError(ToolError):
        """Raised when an external API returns an error."""
        pass


    class ValidationError(ToolError):
        """Raised when input validation fails."""
        pass


    def format_tool_response(data: Any) -> dict:
        """Format data as a proper tool response.

        All @tool decorated functions should return this format:
        {"content": [{"type": "text", "text": "..."}]}

        Args:
            data: Data to return (will be JSON encoded if not string)

        Returns:
            Properly formatted tool response dict
        """
        if isinstance(data, str):
            text = data
        else:
            text = json.dumps(data, indent=2, default=str)

        return {
            "content": [
                {"type": "text", "text": text}
            ]
        }


    def format_error_response(error: str | Exception) -> dict:
        """Format an error as a tool response.

        Args:
            error: Error message or exception

        Returns:
            Properly formatted error response dict
        """
        message = str(error) if isinstance(error, Exception) else error
        return {
            "content": [
                {"type": "text", "text": f"Error: {message}"}
            ],
            "isError": True,
        }


    # HTTP Client with retry logic
    class HTTPClient:
        """Async HTTP client with retry and rate limiting support."""

        def __init__(
            self,
            base_url: str = "",
            headers: dict[str, str] | None = None,
            timeout: float = 30.0,
            max_retries: int = 3,
            retry_delay: float = 1.0,
        ):
            self.base_url = base_url.rstrip("/")
            self.default_headers = headers or {}
            self.timeout = timeout
            self.max_retries = max_retries
            self.retry_delay = retry_delay
            self._client: httpx.AsyncClient | None = None

        async def _get_client(self) -> httpx.AsyncClient:
            """Get or create the HTTP client."""
            if self._client is None:
                self._client = httpx.AsyncClient(
                    base_url=self.base_url,
                    headers=self.default_headers,
                    timeout=self.timeout,
                )
            return self._client

        async def close(self) -> None:
            """Close the HTTP client."""
            if self._client:
                await self._client.aclose()
                self._client = None

        async def request(
            self,
            method: str,
            path: str,
            **kwargs,
        ) -> dict[str, Any]:
            """Make an HTTP request with retry logic.

            Args:
                method: HTTP method (GET, POST, etc.)
                path: URL path (will be joined with base_url)
                **kwargs: Additional arguments passed to httpx

            Returns:
                Parsed JSON response

            Raises:
                APIError: If the request fails after retries
                RateLimitError: If rate limited
            """
            client = await self._get_client()
            last_error: Exception | None = None

            for attempt in range(self.max_retries):
                try:
                    response = await client.request(method, path, **kwargs)

                    # Handle rate limiting
                    if response.status_code == 429:
                        retry_after = int(response.headers.get("Retry-After", self.retry_delay * 2))
                        if attempt < self.max_retries - 1:
                            await asyncio.sleep(retry_after)
                            continue
                        raise RateLimitError(
                            f"Rate limited on {path}",
                            code="RATE_LIMITED",
                            details={"retry_after": retry_after},
                        )

                    # Handle errors
                    if response.status_code >= 400:
                        error_body = response.text
                        try:
                            error_body = response.json()
                        except json.JSONDecodeError:
                            pass

                        raise APIError(
                            f"API error {response.status_code} on {path}",
                            code=f"HTTP_{response.status_code}",
                            details={"response": error_body},
                        )

                    # Parse response
                    if response.headers.get("content-type", "").startswith("application/json"):
                        return response.json()
                    return {"content": response.text}

                except (httpx.ConnectError, httpx.TimeoutException) as e:
                    last_error = e
                    if attempt < self.max_retries - 1:
                        await asyncio.sleep(self.retry_delay * (attempt + 1))
                        continue

            raise APIError(
                f"Request failed after {self.max_retries} retries: {last_error}",
                code="CONNECTION_FAILED",
            )

        async def get(self, path: str, **kwargs) -> dict[str, Any]:
            """Make a GET request."""
            return await self.request("GET", path, **kwargs)

        async def post(self, path: str, **kwargs) -> dict[str, Any]:
            """Make a POST request."""
            return await self.request("POST", path, **kwargs)


    # Data parsing utilities
    def parse_github_url(url: str) -> tuple[str, str]:
        """Parse a GitHub URL to extract owner and repo.

        Args:
            url: GitHub repository URL

        Returns:
            Tuple of (owner, repo_name)

        Raises:
            ValidationError: If URL is not a valid GitHub URL
        """
        patterns = [
            r"github\.com[:/]([^/]+)/([^/\.]+)",  # HTTPS or SSH
            r"^([^/]+)/([^/]+)$",  # owner/repo format
        ]

        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                owner, repo = match.groups()
                repo = repo.rstrip(".git")
                return owner, repo

        raise ValidationError(
            f"Invalid GitHub URL: {url}",
            code="INVALID_GITHUB_URL",
        )


    def truncate_text(text: str, max_length: int, suffix: str = "...") -> str:
        """Truncate text to a maximum length."""
        if len(text) <= max_length:
            return text
        return text[: max_length - len(suffix)] + suffix


    def safe_json_parse(text: str, default: T = None) -> dict | list | T:
        """Safely parse JSON text."""
        try:
            return json.loads(text)
        except json.JSONDecodeError:
            return default


    def format_timestamp(dt: datetime | None = None) -> str:
        """Format a datetime as ISO 8601 string."""
        if dt is None:
            dt = datetime.utcnow()
        return dt.strftime("%Y-%m-%dT%H:%M:%SZ")


    def estimate_tokens(text: str) -> int:
        """Estimate the number of tokens in text (~4 chars per token)."""
        return len(text) // 4


    def chunk_text(text: str, max_tokens: int = 4000) -> list[str]:
        """Split text into chunks that fit within token limits."""
        max_chars = max_tokens * 4
        chunks = []

        paragraphs = text.split("\n\n")
        current_chunk = ""

        for para in paragraphs:
            if len(current_chunk) + len(para) + 2 <= max_chars:
                if current_chunk:
                    current_chunk += "\n\n"
                current_chunk += para
            else:
                if current_chunk:
                    chunks.append(current_chunk)
                if len(para) > max_chars:
                    for i in range(0, len(para), max_chars):
                        chunks.append(para[i : i + max_chars])
                    current_chunk = ""
                else:
                    current_chunk = para

        if current_chunk:
            chunks.append(current_chunk)

        return chunks
    ```

    Avoid: Do NOT skip error handling, do NOT hardcode timeouts without configuration.
  </action>
  <verify>Utils module imports correctly, HTTP client works, parsing functions tested</verify>
  <done>Shared utility module with HTTP client, error handling, and response formatting</done>
</task>

<task type="auto">
  <n>Task 2: Create @tool decorated GitHub tools</n>
  <files>src/codestory/tools/github.py</files>
  <action>
    Create GitHub tools using @tool decorator:

    ```python
    # src/codestory/tools/github.py
    """GitHub API tools for repository analysis.

    These tools are decorated with @tool from claude_agent_sdk and will be
    accessible as mcp__codestory__<tool_name> when registered in the server.
    """

    from claude_agent_sdk import tool

    from .utils import (
        HTTPClient,
        parse_github_url,
        format_tool_response,
        format_error_response,
    )
    from ..core.config import get_settings


    # HTTP client for GitHub API (lazy initialized)
    _github_client: HTTPClient | None = None


    def _get_github_client() -> HTTPClient:
        """Get or create GitHub HTTP client."""
        global _github_client
        if _github_client is None:
            settings = get_settings()
            headers = {"Accept": "application/vnd.github.v3+json"}
            if settings.has_github_token():
                headers["Authorization"] = f"Bearer {settings.github_token}"
            _github_client = HTTPClient(
                base_url=settings.github_api_base,
                headers=headers,
            )
        return _github_client


    @tool(
        name="fetch_repo_tree",
        description="Fetch the directory tree structure of a GitHub repository",
        input_schema={
            "repo_url": "GitHub repository URL (e.g., https://github.com/owner/repo)",
            "branch": "Branch name to fetch (default: main)",
        }
    )
    async def fetch_repo_tree(args: dict) -> dict:
        """Fetch repository file tree.

        Returns the full directory structure of a repository.
        Called as: mcp__codestory__fetch_repo_tree
        """
        try:
            repo_url = args.get("repo_url", "")
            branch = args.get("branch", "main")

            owner, repo = parse_github_url(repo_url)

            # Placeholder implementation - will be completed in Phase 3
            return format_tool_response({
                "owner": owner,
                "repo": repo,
                "branch": branch,
                "tree": [],
                "status": "placeholder",
            })
        except Exception as e:
            return format_error_response(e)


    @tool(
        name="fetch_file_content",
        description="Fetch the contents of a specific file from a GitHub repository",
        input_schema={
            "repo_url": "GitHub repository URL",
            "file_path": "Path to the file within the repository",
        }
    )
    async def fetch_file_content(args: dict) -> dict:
        """Fetch a file's contents from a repository.

        Returns the decoded content of a file.
        Called as: mcp__codestory__fetch_file_content
        """
        try:
            repo_url = args.get("repo_url", "")
            file_path = args.get("file_path", "")

            owner, repo = parse_github_url(repo_url)

            # Placeholder implementation - will be completed in Phase 3
            return format_tool_response({
                "owner": owner,
                "repo": repo,
                "path": file_path,
                "content": "",
                "status": "placeholder",
            })
        except Exception as e:
            return format_error_response(e)


    @tool(
        name="fetch_readme",
        description="Fetch the README file from a GitHub repository",
        input_schema={
            "repo_url": "GitHub repository URL",
        }
    )
    async def fetch_readme(args: dict) -> dict:
        """Fetch repository README.

        Returns the README content for quick project understanding.
        Called as: mcp__codestory__fetch_readme
        """
        try:
            repo_url = args.get("repo_url", "")
            owner, repo = parse_github_url(repo_url)

            # Placeholder implementation - will be completed in Phase 3
            return format_tool_response({
                "owner": owner,
                "repo": repo,
                "readme": "",
                "status": "placeholder",
            })
        except Exception as e:
            return format_error_response(e)


    @tool(
        name="list_branches",
        description="List all branches in a GitHub repository",
        input_schema={
            "repo_url": "GitHub repository URL",
        }
    )
    async def list_branches(args: dict) -> dict:
        """List repository branches.

        Returns list of branch names.
        Called as: mcp__codestory__list_branches
        """
        try:
            repo_url = args.get("repo_url", "")
            owner, repo = parse_github_url(repo_url)

            # Placeholder implementation - will be completed in Phase 3
            return format_tool_response({
                "owner": owner,
                "repo": repo,
                "branches": ["main"],
                "default_branch": "main",
                "status": "placeholder",
            })
        except Exception as e:
            return format_error_response(e)
    ```

    Avoid: Do NOT use class-based patterns, do NOT skip the @tool decorator.
  </action>
  <verify>All tools use @tool decorator, proper input_schema, return format_tool_response</verify>
  <done>GitHub tools with @tool decorator: fetch_repo_tree, fetch_file_content, fetch_readme, list_branches</done>
</task>

<task type="auto">
  <n>Task 3: Create @tool decorated analysis, narrative, and voice tools</n>
  <files>src/codestory/tools/analysis.py, src/codestory/tools/narrative.py, src/codestory/tools/voice.py</files>
  <action>
    Create remaining tool modules using @tool decorator:

    **analysis.py** - Code analysis tools:
    ```python
    # src/codestory/tools/analysis.py
    """Code analysis tools for understanding repository structure.

    These tools analyze code and return structured insights.
    Accessible as mcp__codestory__<tool_name> when registered.
    """

    from claude_agent_sdk import tool

    from .utils import format_tool_response, format_error_response


    @tool(
        name="analyze_python_structure",
        description="Analyze Python file structure including classes, functions, and imports",
        input_schema={
            "code": "Python source code to analyze",
            "filename": "Optional filename for context",
        }
    )
    async def analyze_python_structure(args: dict) -> dict:
        """Analyze Python code structure.

        Extracts classes, functions, imports from Python code.
        Called as: mcp__codestory__analyze_python_structure
        """
        try:
            code = args.get("code", "")
            filename = args.get("filename", "")

            # Placeholder implementation - will be completed in Phase 3
            return format_tool_response({
                "filename": filename,
                "classes": [],
                "functions": [],
                "imports": [],
                "status": "placeholder",
            })
        except Exception as e:
            return format_error_response(e)


    @tool(
        name="identify_patterns",
        description="Identify architectural patterns in the codebase",
        input_schema={
            "file_tree": "Repository file tree structure",
            "sample_files": "List of sample file contents for analysis",
        }
    )
    async def identify_patterns(args: dict) -> dict:
        """Identify architectural patterns.

        Analyzes code structure to identify design patterns.
        Called as: mcp__codestory__identify_patterns
        """
        try:
            file_tree = args.get("file_tree", {})
            sample_files = args.get("sample_files", [])

            # Placeholder implementation - will be completed in Phase 3
            return format_tool_response({
                "patterns": [],
                "architecture": "",
                "status": "placeholder",
            })
        except Exception as e:
            return format_error_response(e)


    @tool(
        name="extract_dependencies",
        description="Extract and analyze project dependencies",
        input_schema={
            "repo_url": "GitHub repository URL",
            "package_files": "Contents of package files (pyproject.toml, package.json, etc.)",
        }
    )
    async def extract_dependencies(args: dict) -> dict:
        """Extract project dependencies.

        Parses package files to list dependencies.
        Called as: mcp__codestory__extract_dependencies
        """
        try:
            repo_url = args.get("repo_url", "")
            package_files = args.get("package_files", {})

            # Placeholder implementation - will be completed in Phase 3
            return format_tool_response({
                "dependencies": [],
                "dev_dependencies": [],
                "status": "placeholder",
            })
        except Exception as e:
            return format_error_response(e)
    ```

    **narrative.py** - Narrative generation tools:
    ```python
    # src/codestory/tools/narrative.py
    """Narrative generation tools for creating story scripts.

    These tools transform code analysis into audio narratives.
    Accessible as mcp__codestory__<tool_name> when registered.
    """

    from claude_agent_sdk import tool

    from .utils import format_tool_response, format_error_response, estimate_tokens


    @tool(
        name="create_chapter_script",
        description="Generate a chapter script from code analysis",
        input_schema={
            "chapter_topic": "Topic or focus of the chapter",
            "analysis_data": "Code analysis data for the chapter",
            "style": "Narrative style (documentary, fiction, tutorial, podcast, technical)",
        }
    )
    async def create_chapter_script(args: dict) -> dict:
        """Create a chapter script.

        Generates narrative script for a chapter.
        Called as: mcp__codestory__create_chapter_script
        """
        try:
            chapter_topic = args.get("chapter_topic", "")
            analysis_data = args.get("analysis_data", {})
            style = args.get("style", "documentary")

            # Placeholder implementation - will be completed in Phase 4
            return format_tool_response({
                "topic": chapter_topic,
                "style": style,
                "script": "",
                "duration_estimate": 0,
                "status": "placeholder",
            })
        except Exception as e:
            return format_error_response(e)


    @tool(
        name="calculate_pacing",
        description="Calculate optimal pacing for the narrative",
        input_schema={
            "total_content": "Full narrative content",
            "target_duration_minutes": "Target duration in minutes",
        }
    )
    async def calculate_pacing(args: dict) -> dict:
        """Calculate narrative pacing.

        Determines optimal words-per-minute and section timing.
        Called as: mcp__codestory__calculate_pacing
        """
        try:
            total_content = args.get("total_content", "")
            target_duration = args.get("target_duration_minutes", 10)

            word_count = len(total_content.split())
            tokens = estimate_tokens(total_content)

            # Placeholder implementation - will be completed in Phase 4
            return format_tool_response({
                "word_count": word_count,
                "estimated_tokens": tokens,
                "target_duration": target_duration,
                "recommended_wpm": 150,
                "sections": [],
                "status": "placeholder",
            })
        except Exception as e:
            return format_error_response(e)


    @tool(
        name="apply_narrative_style",
        description="Apply a specific narrative style to content",
        input_schema={
            "content": "Raw narrative content",
            "style": "Style to apply (documentary, fiction, tutorial, podcast, technical)",
            "voice_personality": "Optional voice personality description",
        }
    )
    async def apply_narrative_style(args: dict) -> dict:
        """Apply narrative style to content.

        Transforms raw content with style-specific elements.
        Called as: mcp__codestory__apply_narrative_style
        """
        try:
            content = args.get("content", "")
            style = args.get("style", "documentary")
            voice_personality = args.get("voice_personality", "")

            # Placeholder implementation - will be completed in Phase 4
            return format_tool_response({
                "style": style,
                "styled_content": content,
                "voice_markers": [],
                "status": "placeholder",
            })
        except Exception as e:
            return format_error_response(e)
    ```

    **voice.py** - Voice synthesis tools:
    ```python
    # src/codestory/tools/voice.py
    """Voice synthesis tools for audio generation.

    These tools use ElevenLabs for text-to-speech synthesis.
    Accessible as mcp__codestory__<tool_name> when registered.
    """

    from claude_agent_sdk import tool

    from .utils import (
        format_tool_response,
        format_error_response,
        chunk_text,
        HTTPClient,
    )
    from ..core.config import get_settings


    # HTTP client for ElevenLabs API (lazy initialized)
    _elevenlabs_client: HTTPClient | None = None


    def _get_elevenlabs_client() -> HTTPClient:
        """Get or create ElevenLabs HTTP client."""
        global _elevenlabs_client
        if _elevenlabs_client is None:
            settings = get_settings()
            headers = {}
            if settings.has_elevenlabs_key():
                headers["xi-api-key"] = settings.elevenlabs_api_key
            _elevenlabs_client = HTTPClient(
                base_url="https://api.elevenlabs.io/v1",
                headers=headers,
            )
        return _elevenlabs_client


    @tool(
        name="synthesize_speech",
        description="Synthesize speech from text using ElevenLabs",
        input_schema={
            "text": "Text to synthesize",
            "voice_id": "ElevenLabs voice ID (optional, uses default if not specified)",
            "stability": "Voice stability (0-1, default 0.5)",
            "similarity_boost": "Similarity boost (0-1, default 0.75)",
        }
    )
    async def synthesize_speech(args: dict) -> dict:
        """Synthesize speech from text.

        Uses ElevenLabs API for high-quality TTS.
        Called as: mcp__codestory__synthesize_speech
        """
        try:
            settings = get_settings()
            text = args.get("text", "")
            voice_id = args.get("voice_id", settings.elevenlabs_default_voice)
            stability = args.get("stability", 0.5)
            similarity_boost = args.get("similarity_boost", 0.75)

            # Placeholder implementation - will be completed in Phase 5
            return format_tool_response({
                "voice_id": voice_id,
                "text_length": len(text),
                "audio_url": "",
                "status": "placeholder",
            })
        except Exception as e:
            return format_error_response(e)


    @tool(
        name="prepare_for_synthesis",
        description="Prepare long text for synthesis by chunking appropriately",
        input_schema={
            "script": "Full script text to prepare",
            "max_chunk_chars": "Maximum characters per chunk (default 5000)",
        }
    )
    async def prepare_for_synthesis(args: dict) -> dict:
        """Prepare script for synthesis.

        Chunks long text to fit API limits.
        Called as: mcp__codestory__prepare_for_synthesis
        """
        try:
            script = args.get("script", "")
            max_chunk_chars = args.get("max_chunk_chars", 5000)

            chunks = chunk_text(script, max_tokens=max_chunk_chars // 4)

            return format_tool_response({
                "total_length": len(script),
                "chunk_count": len(chunks),
                "chunks": chunks,
                "status": "ready",
            })
        except Exception as e:
            return format_error_response(e)


    @tool(
        name="upload_audio",
        description="Upload audio file to S3 storage",
        input_schema={
            "audio_data": "Base64 encoded audio data or local file path",
            "filename": "Destination filename",
            "content_type": "MIME type (default audio/mpeg)",
        }
    )
    async def upload_audio(args: dict) -> dict:
        """Upload audio to S3.

        Stores audio file and returns public URL.
        Called as: mcp__codestory__upload_audio
        """
        try:
            audio_data = args.get("audio_data", "")
            filename = args.get("filename", "")
            content_type = args.get("content_type", "audio/mpeg")

            settings = get_settings()

            # Placeholder implementation - will be completed in Phase 5
            return format_tool_response({
                "filename": filename,
                "bucket": settings.s3_bucket,
                "url": "",
                "status": "placeholder",
            })
        except Exception as e:
            return format_error_response(e)
    ```

    Avoid: Do NOT use class-based Skill patterns, do NOT use custom @skill decorator.
  </action>
  <verify>All tools use @tool decorator from claude_agent_sdk, proper schemas defined</verify>
  <done>Analysis, narrative, and voice tools with @tool decorator pattern</done>
</task>

<task type="auto">
  <n>Task 4: Update tools module exports</n>
  <files>src/codestory/tools/__init__.py</files>
  <action>
    Create comprehensive tools module exports:

    ```python
    # src/codestory/tools/__init__.py
    """Tool library for Code Story agents using Claude Agent SDK @tool decorator.

    Tools are functions decorated with @tool that agents can call.
    When registered with create_sdk_mcp_server(), they become accessible
    as mcp__codestory__<tool_name>.

    Tool categories:
    - github: GitHub API integration for repository access
    - analysis: Code structure analysis and pattern recognition
    - narrative: Story script generation and pacing
    - voice: ElevenLabs voice synthesis and audio storage
    """

    from .utils import (
        ToolError,
        RateLimitError,
        APIError,
        ValidationError,
        HTTPClient,
        format_tool_response,
        format_error_response,
        parse_github_url,
        truncate_text,
        safe_json_parse,
        format_timestamp,
        estimate_tokens,
        chunk_text,
    )

    # GitHub tools
    from .github import (
        fetch_repo_tree,
        fetch_file_content,
        fetch_readme,
        list_branches,
    )

    # Analysis tools
    from .analysis import (
        analyze_python_structure,
        identify_patterns,
        extract_dependencies,
    )

    # Narrative tools
    from .narrative import (
        create_chapter_script,
        calculate_pacing,
        apply_narrative_style,
    )

    # Voice tools
    from .voice import (
        synthesize_speech,
        prepare_for_synthesis,
        upload_audio,
    )


    # All tools for easy registration with create_sdk_mcp_server()
    ALL_TOOLS = [
        # GitHub
        fetch_repo_tree,
        fetch_file_content,
        fetch_readme,
        list_branches,
        # Analysis
        analyze_python_structure,
        identify_patterns,
        extract_dependencies,
        # Narrative
        create_chapter_script,
        calculate_pacing,
        apply_narrative_style,
        # Voice
        synthesize_speech,
        prepare_for_synthesis,
        upload_audio,
    ]


    __all__ = [
        # Utilities
        "ToolError",
        "RateLimitError",
        "APIError",
        "ValidationError",
        "HTTPClient",
        "format_tool_response",
        "format_error_response",
        "parse_github_url",
        "truncate_text",
        "safe_json_parse",
        "format_timestamp",
        "estimate_tokens",
        "chunk_text",
        # GitHub tools
        "fetch_repo_tree",
        "fetch_file_content",
        "fetch_readme",
        "list_branches",
        # Analysis tools
        "analyze_python_structure",
        "identify_patterns",
        "extract_dependencies",
        # Narrative tools
        "create_chapter_script",
        "calculate_pacing",
        "apply_narrative_style",
        # Voice tools
        "synthesize_speech",
        "prepare_for_synthesis",
        "upload_audio",
        # All tools list
        "ALL_TOOLS",
    ]
    ```

    Avoid: Do NOT skip utility exports, do NOT mix up tool function names.
  </action>
  <verify>All exports working, `from codestory.tools import ALL_TOOLS` succeeds</verify>
  <done>Complete tools module exports with ALL_TOOLS list for server registration</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `uv run python -c "from claude_agent_sdk import tool"` succeeds
- [ ] `uv run python -c "from codestory.tools import ALL_TOOLS"` succeeds
- [ ] All tools are decorated with @tool from claude_agent_sdk
- [ ] Each tool uses input_schema dict for parameter documentation
- [ ] All tools return format_tool_response() or format_error_response()
- [ ] HTTPClient with retry logic works correctly
</verification>

<success_criteria>
- All tools use @tool decorator (NOT class-based skills)
- Utility module with HTTP client and response helpers ready
- ALL_TOOLS list ready for create_sdk_mcp_server() registration
- Tools follow mcp__codestory__<tool_name> naming convention
- Foundation ready for domain-specific implementation in Phases 3-5
</success_criteria>

<o>
After completion, create `plans/01-foundation/01-05-SUMMARY.md`

This completes Phase 1: Foundation. The Validation Gate should verify:
- Project initializes with `uv sync`
- All imports work: codestory.agents, codestory.tools, codestory.core, codestory.models
- claude_agent_sdk imports: tool, create_sdk_mcp_server, ClaudeAgentOptions
- MCP server can be created with ALL_TOOLS
- Database models define correct schema
</o>
