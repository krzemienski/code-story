---
phase: 01-foundation
type: execute
domain: python-agent-sdk
---

<objective>
Implement the core agent framework using Claude Agent SDK's @tool decorator pattern and create_sdk_mcp_server().

Purpose: Create the MCP server infrastructure that exposes tools for all 4 agents (Intent, Analyzer, Architect, Voice) to use.
Output: Working MCP server with properly decorated @tool functions, ClaudeAgentOptions configuration, and tool registry.
</objective>


<context>
@BRIEF.md
@ROADMAP.md
@plans/01-foundation/01-01-SUMMARY.md
@plans/01-foundation/01-02-SUMMARY.md
</context>

<reasoning_guidance>
Thoroughly analyze the Claude Agent SDK architecture before implementing.
Key patterns to follow:
- @tool decorator for all tool functions (NOT class-based)
- create_sdk_mcp_server() to bundle tools into an MCP server
- ClaudeAgentOptions for agent configuration
- Tools are called via mcp__<server>__<tool> naming convention

The SDK pattern is function-based, not class-based. Each tool is an async function
decorated with @tool that returns a dict with {"content": [{"type": "text", "text": "..."}]}.
</reasoning_guidance>

<tasks>

<task type="auto">
  <n>Task 1: Create agent configuration with ClaudeAgentOptions</n>
  <files>src/codestory/agents/base.py</files>
  <action>
    Implement agent configuration using ClaudeAgentOptions:

    ```python
    # src/codestory/agents/base.py
    """Base configuration for Code Story agents using Claude Agent SDK."""

    from dataclasses import dataclass, field
    from typing import Literal
    from enum import Enum

    from claude_agent_sdk import ClaudeAgentOptions


    class PipelineStage(str, Enum):
        """Stages in the story generation pipeline."""
        INTENT = "intent"
        ANALYSIS = "analysis"
        NARRATIVE = "narrative"
        SYNTHESIS = "synthesis"
        COMPLETE = "complete"
        FAILED = "failed"


    @dataclass
    class PipelineState:
        """State of the story generation pipeline."""
        stage: PipelineStage
        intent_result: dict | None = None
        analysis_result: dict | None = None
        narrative_result: dict | None = None
        synthesis_result: dict | None = None
        error: str | None = None


    def create_agent_options(
        name: str,
        description: str,
        system_prompt: str,
        model: str = "claude-opus-4-5-20251101",
        max_tokens: int = 8192,
        temperature: float = 0.7,
        effort: Literal["low", "medium", "high"] = "high",
    ) -> ClaudeAgentOptions:
        """Create ClaudeAgentOptions for an agent.

        Args:
            name: Agent name for identification
            description: What this agent does
            system_prompt: System prompt for the agent
            model: Claude model to use
            max_tokens: Maximum tokens in response
            temperature: Sampling temperature
            effort: Opus 4.5 effort parameter

        Returns:
            ClaudeAgentOptions configured for the agent
        """
        return ClaudeAgentOptions(
            name=name,
            description=description,
            system_prompt=system_prompt,
            model=model,
            max_tokens=max_tokens,
            temperature=temperature,
            effort=effort,
        )


    # Pre-configured agent options for Code Story agents
    INTENT_AGENT_OPTIONS = create_agent_options(
        name="intent",
        description="Understands user learning goals and creates story plans",
        system_prompt="""You are the Intent Agent for Code Story.
Your role is to understand what the user wants to learn about a codebase
and create a structured plan for the story. You engage in conversation
to clarify goals, expertise level, and specific areas of interest.

You have access to repository analysis tools to help understand the codebase
and suggest relevant story topics.""",
    )

    ANALYZER_AGENT_OPTIONS = create_agent_options(
        name="analyzer",
        description="Analyzes repository structure and code patterns",
        system_prompt="""You are the Repo Analyzer Agent for Code Story.
Your role is to deeply analyze a codebase and extract meaningful insights
about its architecture, patterns, key components, and design decisions.

You use GitHub API tools to fetch repository contents and code analysis
tools to understand the structure.""",
    )

    ARCHITECT_AGENT_OPTIONS = create_agent_options(
        name="architect",
        description="Generates narrative scripts from code analysis",
        system_prompt="""You are the Story Architect Agent for Code Story.
Your role is to transform code analysis into engaging narrative scripts
suitable for audio storytelling. You create chapter structures, apply
narrative styles (documentary, fiction, tutorial, etc.), and ensure
proper pacing for audio consumption.

You craft stories that make complex code concepts accessible and interesting.""",
    )

    VOICE_AGENT_OPTIONS = create_agent_options(
        name="voice",
        description="Directs voice synthesis and audio production",
        system_prompt="""You are the Voice Director Agent for Code Story.
Your role is to direct the synthesis of narrative scripts into audio.
You handle text chunking for API limits, voice selection, pacing markers,
and audio assembly.

You use ElevenLabs tools to synthesize speech and S3 tools for storage.""",
    )
    ```

    Avoid: Do NOT use custom Agent classes with direct API calls. Use ClaudeAgentOptions.
  </action>
  <verify>Agent options create successfully, ClaudeAgentOptions imports from SDK</verify>
  <done>Agent configuration with ClaudeAgentOptions for all 4 agents</done>
</task>

<task type="auto">
  <n>Task 2: Create MCP server with create_sdk_mcp_server()</n>
  <files>src/codestory/server.py</files>
  <action>
    Implement the MCP server that bundles all tools:

    ```python
    # src/codestory/server.py
    """MCP server for Code Story using Claude Agent SDK."""

    from claude_agent_sdk import create_sdk_mcp_server

    # Import all tools from tool modules
    from .tools.github import (
        fetch_repo_tree,
        fetch_file_content,
        fetch_readme,
        list_branches,
    )
    from .tools.analysis import (
        analyze_python_structure,
        identify_patterns,
        extract_dependencies,
    )
    from .tools.narrative import (
        create_chapter_script,
        calculate_pacing,
        apply_narrative_style,
    )
    from .tools.voice import (
        synthesize_speech,
        prepare_for_synthesis,
        upload_audio,
    )


    def create_codestory_server():
        """Create the Code Story MCP server with all tools.

        Returns:
            MCP server instance with all registered tools.
            Tools are accessible via mcp__codestory__<tool_name> naming.
        """
        # Collect all tools
        all_tools = [
            # GitHub tools
            fetch_repo_tree,
            fetch_file_content,
            fetch_readme,
            list_branches,
            # Analysis tools
            analyze_python_structure,
            identify_patterns,
            extract_dependencies,
            # Narrative tools
            create_chapter_script,
            calculate_pacing,
            apply_narrative_style,
            # Voice tools
            synthesize_speech,
            prepare_for_synthesis,
            upload_audio,
        ]

        # Create MCP server
        server = create_sdk_mcp_server(
            name="codestory",
            version="1.0.0",
            tools=all_tools,
        )

        return server


    # Create the server instance
    server = create_codestory_server()


    def run_server():
        """Run the MCP server."""
        server.run()


    if __name__ == "__main__":
        run_server()
    ```

    Tool naming convention:
    - GitHub: mcp__codestory__fetch_repo_tree, mcp__codestory__fetch_file_content
    - Analysis: mcp__codestory__analyze_python_structure, mcp__codestory__identify_patterns
    - Narrative: mcp__codestory__create_chapter_script, mcp__codestory__calculate_pacing
    - Voice: mcp__codestory__synthesize_speech, mcp__codestory__prepare_for_synthesis

    Avoid: Do NOT use class-based tool registration, do NOT use custom Skill classes.
  </action>
  <verify>Server creates successfully, all tools registered with proper names</verify>
  <done>MCP server using create_sdk_mcp_server() with all tools bundled</done>
</task>

<task type="auto">
  <n>Task 3: Create Orchestrator for multi-agent coordination</n>
  <files>src/codestory/agents/orchestrator.py, src/codestory/agents/__init__.py</files>
  <action>
    Add Orchestrator for pipeline coordination:

    ```python
    # src/codestory/agents/orchestrator.py
    """Orchestrator for multi-agent story generation pipeline."""

    from typing import Callable, Any
    from dataclasses import dataclass

    from .base import (
        PipelineStage,
        PipelineState,
        INTENT_AGENT_OPTIONS,
        ANALYZER_AGENT_OPTIONS,
        ARCHITECT_AGENT_OPTIONS,
        VOICE_AGENT_OPTIONS,
    )


    @dataclass
    class StoryRequest:
        """Request to generate a story."""
        repo_url: str
        user_intent: str
        narrative_style: str = "documentary"
        voice_id: str | None = None
        expertise_level: str = "intermediate"


    @dataclass
    class StoryResult:
        """Result of story generation."""
        success: bool
        audio_url: str | None = None
        script_text: str | None = None
        chapters: list[dict] | None = None
        error: str | None = None
        pipeline_state: PipelineState | None = None


    class Orchestrator:
        """Orchestrates the 4-agent pipeline for story generation.

        Pipeline flow:
        1. Intent Agent - Understand user's learning goals
        2. Repo Analyzer - Analyze the codebase
        3. Story Architect - Generate narrative script
        4. Voice Director - Synthesize audio

        Each agent uses tools registered in the MCP server via mcp__codestory__* naming.
        """

        def __init__(self):
            self.state = PipelineState(stage=PipelineStage.INTENT)
            self._progress_callback: Callable[[PipelineStage, str], None] | None = None

        def set_progress_callback(
            self,
            callback: Callable[[PipelineStage, str], None]
        ) -> None:
            """Set callback for progress updates."""
            self._progress_callback = callback

        def _notify_progress(self, stage: PipelineStage, message: str) -> None:
            """Notify progress callback if set."""
            if self._progress_callback:
                self._progress_callback(stage, message)

        async def run_pipeline(self, request: StoryRequest) -> StoryResult:
            """Run the full story generation pipeline.

            Args:
                request: Story generation request

            Returns:
                StoryResult with generated audio or error
            """
            try:
                # Stage 1: Intent Analysis
                self.state.stage = PipelineStage.INTENT
                self._notify_progress(PipelineStage.INTENT, "Understanding your learning goals...")

                intent_result = await self._run_intent_stage(request)
                self.state.intent_result = intent_result

                # Stage 2: Repository Analysis
                self.state.stage = PipelineStage.ANALYSIS
                self._notify_progress(PipelineStage.ANALYSIS, "Analyzing the codebase...")

                analysis_result = await self._run_analysis_stage(request, intent_result)
                self.state.analysis_result = analysis_result

                # Stage 3: Narrative Generation
                self.state.stage = PipelineStage.NARRATIVE
                self._notify_progress(PipelineStage.NARRATIVE, "Crafting your story...")

                narrative_result = await self._run_narrative_stage(
                    request, intent_result, analysis_result
                )
                self.state.narrative_result = narrative_result

                # Stage 4: Voice Synthesis
                self.state.stage = PipelineStage.SYNTHESIS
                self._notify_progress(PipelineStage.SYNTHESIS, "Generating audio...")

                synthesis_result = await self._run_synthesis_stage(
                    request, narrative_result
                )
                self.state.synthesis_result = synthesis_result

                # Complete
                self.state.stage = PipelineStage.COMPLETE
                self._notify_progress(PipelineStage.COMPLETE, "Story complete!")

                return StoryResult(
                    success=True,
                    audio_url=synthesis_result.get("audio_url"),
                    script_text=narrative_result.get("script"),
                    chapters=narrative_result.get("chapters"),
                    pipeline_state=self.state,
                )

            except Exception as e:
                self.state.stage = PipelineStage.FAILED
                self.state.error = str(e)
                self._notify_progress(PipelineStage.FAILED, f"Error: {str(e)}")

                return StoryResult(
                    success=False,
                    error=str(e),
                    pipeline_state=self.state,
                )

        async def _run_intent_stage(self, request: StoryRequest) -> dict:
            """Run the intent analysis stage.

            The Intent Agent uses tools:
            - mcp__codestory__fetch_readme to understand the project
            - mcp__codestory__fetch_repo_tree to see structure

            Returns structured intent with learning goals and focus areas.
            """
            # Placeholder - actual implementation uses Claude with tools
            return {
                "repo_url": request.repo_url,
                "user_intent": request.user_intent,
                "expertise_level": request.expertise_level,
                "focus_areas": [],
                "learning_goals": request.user_intent,
            }

        async def _run_analysis_stage(
            self,
            request: StoryRequest,
            intent_result: dict
        ) -> dict:
            """Run the repository analysis stage.

            The Analyzer Agent uses tools:
            - mcp__codestory__fetch_repo_tree for structure
            - mcp__codestory__fetch_file_content for key files
            - mcp__codestory__analyze_python_structure for code analysis
            - mcp__codestory__identify_patterns for architecture

            Returns structured analysis with patterns and components.
            """
            # Placeholder - actual implementation uses Claude with tools
            return {
                "repo_url": request.repo_url,
                "architecture": "placeholder",
                "patterns": [],
                "key_components": [],
                "dependencies": [],
            }

        async def _run_narrative_stage(
            self,
            request: StoryRequest,
            intent_result: dict,
            analysis_result: dict
        ) -> dict:
            """Run the narrative generation stage.

            The Architect Agent uses tools:
            - mcp__codestory__create_chapter_script for each section
            - mcp__codestory__calculate_pacing for timing
            - mcp__codestory__apply_narrative_style for style

            Returns structured narrative with chapters and script.
            """
            # Placeholder - actual implementation uses Claude with tools
            return {
                "style": request.narrative_style,
                "script": "placeholder narrative script",
                "chapters": [],
                "total_duration_estimate": 0,
            }

        async def _run_synthesis_stage(
            self,
            request: StoryRequest,
            narrative_result: dict
        ) -> dict:
            """Run the voice synthesis stage.

            The Voice Agent uses tools:
            - mcp__codestory__prepare_for_synthesis to chunk text
            - mcp__codestory__synthesize_speech for each chunk
            - mcp__codestory__upload_audio to store result

            Returns audio URL and metadata.
            """
            # Placeholder - actual implementation uses Claude with tools
            return {
                "audio_url": "placeholder",
                "duration_seconds": 0,
                "voice_id": request.voice_id,
            }

        def get_state(self) -> PipelineState:
            """Get current pipeline state."""
            return self.state

        def reset(self) -> None:
            """Reset pipeline state for new request."""
            self.state = PipelineState(stage=PipelineStage.INTENT)
    ```

    Update `src/codestory/agents/__init__.py`:
    ```python
    """Agent framework for Code Story using Claude Agent SDK."""
    from .base import (
        PipelineStage,
        PipelineState,
        create_agent_options,
        INTENT_AGENT_OPTIONS,
        ANALYZER_AGENT_OPTIONS,
        ARCHITECT_AGENT_OPTIONS,
        VOICE_AGENT_OPTIONS,
    )
    from .orchestrator import (
        Orchestrator,
        StoryRequest,
        StoryResult,
    )

    __all__ = [
        "PipelineStage",
        "PipelineState",
        "create_agent_options",
        "INTENT_AGENT_OPTIONS",
        "ANALYZER_AGENT_OPTIONS",
        "ARCHITECT_AGENT_OPTIONS",
        "VOICE_AGENT_OPTIONS",
        "Orchestrator",
        "StoryRequest",
        "StoryResult",
    ]
    ```

    Avoid: Do NOT skip progress callbacks, do NOT ignore pipeline state transitions.
  </action>
  <verify>All classes import correctly, pipeline stages defined, orchestrator instantiates</verify>
  <done>Orchestrator class for 4-agent pipeline coordination with progress callbacks</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `uv run python -c "from claude_agent_sdk import tool, create_sdk_mcp_server, ClaudeAgentOptions"` succeeds
- [ ] `uv run python -c "from codestory.agents import Orchestrator, INTENT_AGENT_OPTIONS"` succeeds
- [ ] `uv run python -c "from codestory.server import server"` succeeds (placeholder tools)
- [ ] ClaudeAgentOptions properly configured for all 4 agents
- [ ] Orchestrator handles all 4 pipeline stages
</verification>

<success_criteria>
- ClaudeAgentOptions configured for all agents
- MCP server created with create_sdk_mcp_server()
- Orchestrator managing multi-agent pipeline
- Tool naming follows mcp__codestory__<tool> convention
</success_criteria>

<o>
After completion, create `plans/01-foundation/01-03-SUMMARY.md`
</o>
