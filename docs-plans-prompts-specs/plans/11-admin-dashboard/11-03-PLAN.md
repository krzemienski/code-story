# Plan 11-03: Usage Analytics and Cost Tracking

## Overview
Implement comprehensive analytics dashboard showing platform usage metrics, cost tracking for API calls (Anthropic, ElevenLabs, S3), user growth trends, and revenue insights using Claude Agent SDK patterns with audit logging hooks and secure data access.

## Dependencies
- Plan 11-01: Admin authentication with SDK patterns
- Phase 6: Database with usage data

## Claude Agent SDK Architecture

### 1. Analytics Tools with @tool Decorator

**src/codestory/tools/analytics.py:**
```python
"""Analytics tools using Claude Agent SDK @tool decorator."""
import uuid
from datetime import date, timedelta
from decimal import Decimal
from typing import Optional
import csv
import io

from claude_agent_sdk import tool, create_sdk_mcp_server
from sqlalchemy import func, and_
from sqlalchemy.orm import Session

from src.codestory.models.analytics import DailyMetrics, UserActivity, APICallLog
from src.codestory.models.user import User


@tool(
    "get_dashboard_metrics",
    "Get aggregated dashboard metrics for a date range including users, stories, costs, and revenue.",
    {
        "start_date": str,  # ISO format YYYY-MM-DD
        "end_date": str,    # ISO format YYYY-MM-DD
    }
)
async def get_dashboard_metrics(args: dict) -> dict:
    """Get aggregated metrics for analytics dashboard."""
    from src.codestory.core.database import get_db_session

    start = date.fromisoformat(args["start_date"])
    end = date.fromisoformat(args["end_date"])

    async with get_db_session() as db:
        metrics = db.query(DailyMetrics).filter(
            DailyMetrics.date >= start,
            DailyMetrics.date <= end
        ).all()

        totals = {
            "new_users": sum(m.new_users for m in metrics),
            "active_users": max((m.active_users for m in metrics), default=0),
            "stories_created": sum(m.stories_created for m in metrics),
            "stories_completed": sum(m.stories_completed for m in metrics),
            "total_audio_minutes": sum(float(m.total_audio_minutes) for m in metrics),
            "api_requests": sum(m.api_requests for m in metrics),
            "total_cost_cents": sum(m.total_cost for m in metrics),
            "revenue_cents": sum(m.revenue for m in metrics),
        }

        if totals["revenue_cents"] > 0:
            totals["profit_margin"] = (
                (totals["revenue_cents"] - totals["total_cost_cents"])
                / totals["revenue_cents"] * 100
            )
        else:
            totals["profit_margin"] = 0

        daily = [
            {
                "date": m.date.isoformat(),
                "new_users": m.new_users,
                "active_users": m.active_users,
                "stories": m.stories_created,
                "cost": m.total_cost / 100,
                "revenue": m.revenue / 100,
            }
            for m in sorted(metrics, key=lambda x: x.date)
        ]

        result = {
            "totals": totals,
            "daily": daily,
            "period": {
                "start": start.isoformat(),
                "end": end.isoformat(),
                "days": (end - start).days + 1,
            }
        }

    return {"content": [{"type": "text", "text": str(result)}]}


@tool(
    "get_cost_breakdown",
    "Get cost breakdown by service (Anthropic, ElevenLabs, S3) for a date range.",
    {
        "start_date": str,
        "end_date": str,
    }
)
async def get_cost_breakdown(args: dict) -> dict:
    """Get cost breakdown by API service."""
    from src.codestory.core.database import get_db_session

    start = date.fromisoformat(args["start_date"])
    end = date.fromisoformat(args["end_date"])

    async with get_db_session() as db:
        metrics = db.query(DailyMetrics).filter(
            DailyMetrics.date >= start,
            DailyMetrics.date <= end
        ).all()

        anthropic = sum(m.anthropic_cost for m in metrics)
        elevenlabs = sum(m.elevenlabs_cost for m in metrics)
        s3 = sum(m.s3_cost for m in metrics)
        total = anthropic + elevenlabs + s3

        breakdown = {
            "anthropic": {
                "cost_cents": anthropic,
                "cost_dollars": anthropic / 100,
                "percentage": (anthropic / total * 100) if total > 0 else 0,
            },
            "elevenlabs": {
                "cost_cents": elevenlabs,
                "cost_dollars": elevenlabs / 100,
                "percentage": (elevenlabs / total * 100) if total > 0 else 0,
            },
            "s3": {
                "cost_cents": s3,
                "cost_dollars": s3 / 100,
                "percentage": (s3 / total * 100) if total > 0 else 0,
            },
            "total": {
                "cost_cents": total,
                "cost_dollars": total / 100,
            }
        }

        daily = [
            {
                "date": m.date.isoformat(),
                "anthropic": m.anthropic_cost / 100,
                "elevenlabs": m.elevenlabs_cost / 100,
                "s3": m.s3_cost / 100,
            }
            for m in sorted(metrics, key=lambda x: x.date)
        ]

    return {"content": [{"type": "text", "text": str({"breakdown": breakdown, "daily": daily})}]}


@tool(
    "get_user_growth",
    "Get user growth metrics including new users, active users, and churn rates.",
    {
        "start_date": str,
        "end_date": str,
    }
)
async def get_user_growth(args: dict) -> dict:
    """Get user growth and retention metrics."""
    from src.codestory.core.database import get_db_session
    from datetime import datetime

    start = date.fromisoformat(args["start_date"])
    end = date.fromisoformat(args["end_date"])

    async with get_db_session() as db:
        metrics = db.query(DailyMetrics).filter(
            DailyMetrics.date >= start,
            DailyMetrics.date <= end
        ).order_by(DailyMetrics.date).all()

        total_users = db.query(func.count(User.id)).filter(
            User.created_at < datetime.combine(start, datetime.min.time())
        ).scalar() or 0

        cumulative = []
        for m in metrics:
            total_users += m.new_users
            cumulative.append({
                "date": m.date.isoformat(),
                "new_users": m.new_users,
                "total_users": total_users,
                "active_users": m.active_users,
                "churned": m.churned_users,
            })

        if len(cumulative) >= 2:
            first = cumulative[0]["total_users"]
            last = cumulative[-1]["total_users"]
            growth_rate = ((last - first) / first * 100) if first > 0 else 0
        else:
            growth_rate = 0

        result = {
            "daily": cumulative,
            "growth_rate": growth_rate,
            "total_new": sum(m.new_users for m in metrics),
            "total_churned": sum(m.churned_users for m in metrics),
        }

    return {"content": [{"type": "text", "text": str(result)}]}


@tool(
    "get_top_users",
    "Get top users by cost or usage metrics.",
    {
        "start_date": str,
        "end_date": str,
        "limit": int,
        "sort_by": str,  # "cost", "stories", "api_calls"
    }
)
async def get_top_users(args: dict) -> dict:
    """Get top users by specified metric."""
    from src.codestory.core.database import get_db_session

    start = date.fromisoformat(args["start_date"])
    end = date.fromisoformat(args["end_date"])
    limit = args.get("limit", 10)
    sort_by = args.get("sort_by", "cost")

    async with get_db_session() as db:
        query = db.query(
            UserActivity.user_id,
            func.sum(UserActivity.stories_created).label("stories"),
            func.sum(UserActivity.api_calls).label("api_calls"),
            func.sum(UserActivity.audio_minutes).label("audio_minutes"),
            func.sum(UserActivity.cost_cents).label("total_cost"),
        ).filter(
            UserActivity.date >= start,
            UserActivity.date <= end
        ).group_by(UserActivity.user_id)

        if sort_by == "cost":
            query = query.order_by(func.sum(UserActivity.cost_cents).desc())
        elif sort_by == "stories":
            query = query.order_by(func.sum(UserActivity.stories_created).desc())
        elif sort_by == "api_calls":
            query = query.order_by(func.sum(UserActivity.api_calls).desc())

        results = query.limit(limit).all()

        user_ids = [r.user_id for r in results]
        users = {u.id: u for u in db.query(User).filter(User.id.in_(user_ids)).all()}

        top_users = [
            {
                "user_id": r.user_id,
                "email": users.get(r.user_id).email if r.user_id in users else None,
                "stories": r.stories,
                "api_calls": r.api_calls,
                "audio_minutes": float(r.audio_minutes),
                "cost_dollars": r.total_cost / 100,
            }
            for r in results
        ]

    return {"content": [{"type": "text", "text": str(top_users)}]}


@tool(
    "export_analytics",
    "Export analytics data in CSV or JSON format.",
    {
        "start_date": str,
        "end_date": str,
        "format": str,  # "csv" or "json"
    }
)
async def export_analytics(args: dict) -> dict:
    """Export analytics data for download."""
    from src.codestory.core.database import get_db_session

    start = date.fromisoformat(args["start_date"])
    end = date.fromisoformat(args["end_date"])
    export_format = args.get("format", "csv")

    async with get_db_session() as db:
        metrics = db.query(DailyMetrics).filter(
            DailyMetrics.date >= start,
            DailyMetrics.date <= end
        ).order_by(DailyMetrics.date).all()

        if export_format == "csv":
            output = io.StringIO()
            writer = csv.writer(output)
            writer.writerow(["Date", "New Users", "Active Users", "Stories", "Cost", "Revenue"])

            for m in metrics:
                writer.writerow([
                    m.date.isoformat(),
                    m.new_users,
                    m.active_users,
                    m.stories_created,
                    m.total_cost / 100,
                    m.revenue / 100,
                ])

            result = {
                "format": "csv",
                "content": output.getvalue(),
                "filename": f"analytics_{start}_{end}.csv"
            }
        else:
            daily = [
                {
                    "date": m.date.isoformat(),
                    "new_users": m.new_users,
                    "active_users": m.active_users,
                    "stories": m.stories_created,
                    "cost": m.total_cost / 100,
                    "revenue": m.revenue / 100,
                }
                for m in metrics
            ]
            result = {"format": "json", "data": daily}

    return {"content": [{"type": "text", "text": str(result)}]}


@tool(
    "log_api_call",
    "Log an API call for cost tracking and analytics aggregation.",
    {
        "user_id": str,
        "service": str,  # "anthropic", "elevenlabs", "s3"
        "operation": str,
        "cost_cents": int,
        "story_id": str,  # optional
        "input_tokens": int,  # optional
        "output_tokens": int,  # optional
        "characters": int,  # optional (ElevenLabs)
        "bytes_transferred": int,  # optional (S3)
    }
)
async def log_api_call(args: dict) -> dict:
    """Log an API call for cost tracking."""
    from src.codestory.core.database import get_db_session

    async with get_db_session() as db:
        log = APICallLog(
            id=str(uuid.uuid4()),
            user_id=args["user_id"],
            story_id=args.get("story_id"),
            service=args["service"],
            operation=args["operation"],
            cost_cents=args["cost_cents"],
            input_tokens=args.get("input_tokens", 0),
            output_tokens=args.get("output_tokens", 0),
            characters=args.get("characters", 0),
            bytes_transferred=args.get("bytes_transferred", 0),
        )
        db.add(log)

        # Update daily metrics
        today = date.today()
        metrics = db.query(DailyMetrics).filter(
            DailyMetrics.date == today
        ).first()

        if not metrics:
            metrics = DailyMetrics(
                id=str(uuid.uuid4()),
                date=today
            )
            db.add(metrics)

        metrics.api_requests += 1
        metrics.total_cost += args["cost_cents"]

        if args["service"] == "anthropic":
            metrics.anthropic_cost += args["cost_cents"]
        elif args["service"] == "elevenlabs":
            metrics.elevenlabs_cost += args["cost_cents"]
        elif args["service"] == "s3":
            metrics.s3_cost += args["cost_cents"]

        # Update user activity
        activity = db.query(UserActivity).filter(
            UserActivity.user_id == args["user_id"],
            UserActivity.date == today
        ).first()

        if not activity:
            activity = UserActivity(
                id=str(uuid.uuid4()),
                user_id=args["user_id"],
                date=today
            )
            db.add(activity)

        activity.api_calls += 1
        activity.cost_cents += args["cost_cents"]

        db.commit()

    return {"content": [{"type": "text", "text": f"Logged API call: {args['service']}/{args['operation']}"}]}


def create_analytics_server():
    """Create MCP server for analytics tools."""
    return create_sdk_mcp_server(
        name="analytics",
        version="1.0.0",
        tools=[
            get_dashboard_metrics,
            get_cost_breakdown,
            get_user_growth,
            get_top_users,
            export_analytics,
            log_api_call,
        ]
    )
```

### 2. Security Hooks for Analytics Access

**src/codestory/hooks/analytics_hooks.py:**
```python
"""Security hooks for analytics access with audit logging."""
import json
from datetime import datetime
from typing import Any

import redis.asyncio as redis

from src.codestory.core.config import settings


async def validate_analytics_request(
    input_data: dict,
    tool_use_id: str,
    context: dict
) -> dict:
    """PreToolUse hook: Validate analytics access and rate limit."""
    tool_name = input_data.get("tool_name", "")

    if not tool_name.startswith("mcp__analytics__"):
        return {}

    admin_id = context.get("admin_id")
    if not admin_id:
        return {
            "hookSpecificOutput": {
                "hookEventName": "PreToolUse",
                "permissionDecision": "deny",
                "permissionDecisionReason": "Analytics access requires admin authentication"
            }
        }

    # Rate limiting: 30 requests per minute for analytics (higher than user mgmt)
    redis_client = redis.from_url(settings.redis_url)
    rate_key = f"analytics_rate:{admin_id}"

    try:
        current = await redis_client.incr(rate_key)
        if current == 1:
            await redis_client.expire(rate_key, 60)

        if current > 30:
            return {
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "permissionDecision": "deny",
                    "permissionDecisionReason": "Rate limit exceeded: 30 analytics requests per minute"
                }
            }
    finally:
        await redis_client.close()

    # Validate date range (max 365 days)
    tool_input = input_data.get("tool_input", {})
    if "start_date" in tool_input and "end_date" in tool_input:
        from datetime import date
        try:
            start = date.fromisoformat(tool_input["start_date"])
            end = date.fromisoformat(tool_input["end_date"])
            days = (end - start).days

            if days > 365:
                return {
                    "hookSpecificOutput": {
                        "hookEventName": "PreToolUse",
                        "permissionDecision": "deny",
                        "permissionDecisionReason": "Date range cannot exceed 365 days"
                    }
                }

            if days < 0:
                return {
                    "hookSpecificOutput": {
                        "hookEventName": "PreToolUse",
                        "permissionDecision": "deny",
                        "permissionDecisionReason": "End date must be after start date"
                    }
                }
        except ValueError:
            return {
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "permissionDecision": "deny",
                    "permissionDecisionReason": "Invalid date format (expected YYYY-MM-DD)"
                }
            }

    return {}


async def audit_analytics_access(
    input_data: dict,
    tool_use_id: str,
    context: dict
) -> dict:
    """PostToolUse hook: Log all analytics access for audit compliance."""
    tool_name = input_data.get("tool_name", "")

    if not tool_name.startswith("mcp__analytics__"):
        return {}

    from src.codestory.core.database import get_db_session
    from src.codestory.models.admin import AuditLog

    admin_id = context.get("admin_id")
    admin_email = context.get("admin_email")
    tool_input = input_data.get("tool_input", {})

    # Determine action type from tool name
    action_map = {
        "get_dashboard_metrics": "analytics_dashboard_viewed",
        "get_cost_breakdown": "analytics_costs_viewed",
        "get_user_growth": "analytics_growth_viewed",
        "get_top_users": "analytics_top_users_viewed",
        "export_analytics": "analytics_data_exported",
        "log_api_call": "api_call_logged",
    }

    tool_short_name = tool_name.replace("mcp__analytics__", "")
    action = action_map.get(tool_short_name, f"analytics_{tool_short_name}")

    # Log sensitive exports with extra detail
    details = {
        "tool": tool_short_name,
        "timestamp": datetime.utcnow().isoformat(),
        "ip_address": context.get("ip_address"),
    }

    if "start_date" in tool_input:
        details["date_range"] = {
            "start": tool_input.get("start_date"),
            "end": tool_input.get("end_date"),
        }

    if tool_short_name == "export_analytics":
        details["export_format"] = tool_input.get("format", "csv")
        details["alert"] = "DATA_EXPORT"

    if tool_short_name == "get_top_users":
        details["limit"] = tool_input.get("limit", 10)
        details["sort_by"] = tool_input.get("sort_by", "cost")

    async with get_db_session() as db:
        audit_entry = AuditLog(
            id=str(uuid.uuid4()),
            admin_id=admin_id,
            action=action,
            target_type="analytics",
            target_id=None,
            details=details,
            created_at=datetime.utcnow()
        )
        db.add(audit_entry)
        db.commit()

    return {}


async def cleanup_analytics_session(
    input_data: dict,
    tool_use_id: str,
    context: dict
) -> dict:
    """Stop hook: Clean up analytics session resources."""
    session_id = context.get("session_id")

    if session_id:
        redis_client = redis.from_url(settings.redis_url)
        try:
            # Clean up any cached analytics data
            await redis_client.delete(f"analytics_cache:{session_id}")
        finally:
            await redis_client.close()

    return {}
```

### 3. SDK Configuration for Analytics

**src/codestory/agents/analytics_config.py:**
```python
"""Claude Agent SDK configuration for analytics operations."""
import uuid
from fastapi import Request
from sqlalchemy.orm import Session

from claude_agent_sdk import ClaudeAgentOptions, HookMatcher, SandboxSettings

from src.codestory.tools.analytics import create_analytics_server
from src.codestory.hooks.analytics_hooks import (
    validate_analytics_request,
    audit_analytics_access,
    cleanup_analytics_session,
)
from src.codestory.models.admin import AdminUser


def get_analytics_sdk_options(
    request: Request,
    db: Session,
    admin: AdminUser
) -> ClaudeAgentOptions:
    """Get SDK options for analytics operations with security hooks."""

    analytics_server = create_analytics_server()
    session_id = str(uuid.uuid4())

    # Context for hooks
    hook_context = {
        "admin_id": admin.id,
        "admin_email": admin.email,
        "ip_address": request.client.host if request.client else None,
        "session_id": session_id,
        "db": db,
    }

    return ClaudeAgentOptions(
        mcp_servers={
            "analytics": analytics_server,
        },
        allowed_tools=[
            "mcp__analytics__get_dashboard_metrics",
            "mcp__analytics__get_cost_breakdown",
            "mcp__analytics__get_user_growth",
            "mcp__analytics__get_top_users",
            "mcp__analytics__export_analytics",
            # log_api_call is internal-only, not exposed to admin UI
        ],
        permission_mode="default",  # CRITICAL: Never bypassPermissions in production
        sandbox=SandboxSettings(
            enabled=True,
            network="host",  # Allow database access
        ),
        hooks={
            "PreToolUse": [
                HookMatcher(
                    matcher="mcp__analytics__*",
                    hooks=[validate_analytics_request],
                    context=hook_context
                )
            ],
            "PostToolUse": [
                HookMatcher(
                    matcher="*",
                    hooks=[audit_analytics_access],
                    context=hook_context
                )
            ],
            "Stop": [
                HookMatcher(
                    matcher="*",
                    hooks=[cleanup_analytics_session],
                    context=hook_context
                )
            ],
        },
        max_turns=10,
    )
```

### 4. Analytics Router with SDK Integration

**src/codestory/backend/api/routers/admin_analytics.py:**
```python
"""Admin analytics endpoints using Claude Agent SDK."""
from datetime import date, timedelta
from fastapi import APIRouter, Depends, Query, Request
from fastapi.responses import StreamingResponse
from sqlalchemy.orm import Session

from claude_agent_sdk import ClaudeSDKClient

from src.codestory.core.database import get_db
from src.codestory.models.admin import AdminUser, Permission
from src.codestory.backend.api.deps import require_permission
from src.codestory.agents.analytics_config import get_analytics_sdk_options

router = APIRouter(prefix="/admin/analytics", tags=["admin-analytics"])


@router.get("/dashboard")
async def get_dashboard(
    request: Request,
    start_date: date = Query(default_factory=lambda: date.today() - timedelta(days=30)),
    end_date: date = Query(default_factory=date.today),
    admin: AdminUser = Depends(require_permission(Permission.VIEW_ANALYTICS)),
    db: Session = Depends(get_db)
):
    """Get dashboard metrics via Claude Agent SDK."""
    options = get_analytics_sdk_options(request, db, admin)

    async with ClaudeSDKClient(options=options) as client:
        await client.query(
            f"Get dashboard metrics from {start_date.isoformat()} to {end_date.isoformat()}"
        )

        result = None
        async for message in client.receive_response():
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'text'):
                        result = eval(block.text)  # Parse dict from string

        return result


@router.get("/costs")
async def get_costs(
    request: Request,
    start_date: date = Query(default_factory=lambda: date.today() - timedelta(days=30)),
    end_date: date = Query(default_factory=date.today),
    admin: AdminUser = Depends(require_permission(Permission.VIEW_ANALYTICS)),
    db: Session = Depends(get_db)
):
    """Get cost breakdown by service via Claude Agent SDK."""
    options = get_analytics_sdk_options(request, db, admin)

    async with ClaudeSDKClient(options=options) as client:
        await client.query(
            f"Get cost breakdown from {start_date.isoformat()} to {end_date.isoformat()}"
        )

        result = None
        async for message in client.receive_response():
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'text'):
                        result = eval(block.text)

        return result


@router.get("/users/growth")
async def get_user_growth(
    request: Request,
    start_date: date = Query(default_factory=lambda: date.today() - timedelta(days=30)),
    end_date: date = Query(default_factory=date.today),
    admin: AdminUser = Depends(require_permission(Permission.VIEW_ANALYTICS)),
    db: Session = Depends(get_db)
):
    """Get user growth metrics via Claude Agent SDK."""
    options = get_analytics_sdk_options(request, db, admin)

    async with ClaudeSDKClient(options=options) as client:
        await client.query(
            f"Get user growth metrics from {start_date.isoformat()} to {end_date.isoformat()}"
        )

        result = None
        async for message in client.receive_response():
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'text'):
                        result = eval(block.text)

        return result


@router.get("/users/top")
async def get_top_users(
    request: Request,
    start_date: date = Query(default_factory=lambda: date.today() - timedelta(days=30)),
    end_date: date = Query(default_factory=date.today),
    limit: int = Query(10, ge=1, le=100),
    sort_by: str = Query("cost", regex="^(cost|stories|api_calls)$"),
    admin: AdminUser = Depends(require_permission(Permission.VIEW_ANALYTICS)),
    db: Session = Depends(get_db)
):
    """Get top users by usage or cost via Claude Agent SDK."""
    options = get_analytics_sdk_options(request, db, admin)

    async with ClaudeSDKClient(options=options) as client:
        await client.query(
            f"Get top {limit} users sorted by {sort_by} from {start_date.isoformat()} to {end_date.isoformat()}"
        )

        result = None
        async for message in client.receive_response():
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'text'):
                        result = eval(block.text)

        return result


@router.get("/export")
async def export_analytics(
    request: Request,
    start_date: date = Query(...),
    end_date: date = Query(...),
    format: str = Query("csv", regex="^(csv|json)$"),
    admin: AdminUser = Depends(require_permission(Permission.EXPORT_DATA)),
    db: Session = Depends(get_db)
):
    """Export analytics data via Claude Agent SDK."""
    options = get_analytics_sdk_options(request, db, admin)

    async with ClaudeSDKClient(options=options) as client:
        await client.query(
            f"Export analytics data in {format} format from {start_date.isoformat()} to {end_date.isoformat()}"
        )

        result = None
        async for message in client.receive_response():
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'text'):
                        result = eval(block.text)

        if result and format == "csv":
            return StreamingResponse(
                iter([result["content"]]),
                media_type="text/csv",
                headers={"Content-Disposition": f"attachment; filename={result['filename']}"}
            )

        return result
```

### 5. Analytics Models

**src/codestory/models/analytics.py:**
```python
"""Analytics and cost tracking models."""
from datetime import datetime, date
from decimal import Decimal
from sqlalchemy import Column, String, Integer, DateTime, Date, Numeric, JSON, UniqueConstraint
from src.codestory.core.database import Base


class DailyMetrics(Base):
    """Aggregated daily platform metrics."""
    __tablename__ = "daily_metrics"

    id = Column(String(36), primary_key=True)
    date = Column(Date, unique=True, nullable=False, index=True)

    # User metrics
    new_users = Column(Integer, default=0)
    active_users = Column(Integer, default=0)
    churned_users = Column(Integer, default=0)

    # Story metrics
    stories_created = Column(Integer, default=0)
    stories_completed = Column(Integer, default=0)
    stories_failed = Column(Integer, default=0)
    total_chapters = Column(Integer, default=0)
    total_audio_minutes = Column(Numeric(10, 2), default=0)

    # API metrics
    api_requests = Column(Integer, default=0)
    api_errors = Column(Integer, default=0)

    # Cost metrics (in cents)
    anthropic_cost = Column(Integer, default=0)
    elevenlabs_cost = Column(Integer, default=0)
    s3_cost = Column(Integer, default=0)
    total_cost = Column(Integer, default=0)

    # Revenue (in cents)
    revenue = Column(Integer, default=0)

    created_at = Column(DateTime, default=datetime.utcnow)


class UserActivity(Base):
    """Track individual user activity for analytics."""
    __tablename__ = "user_activity"

    id = Column(String(36), primary_key=True)
    user_id = Column(String(36), nullable=False, index=True)
    date = Column(Date, nullable=False, index=True)

    # Activity counts
    stories_created = Column(Integer, default=0)
    api_calls = Column(Integer, default=0)
    audio_minutes = Column(Numeric(10, 2), default=0)

    # Cost attribution
    cost_cents = Column(Integer, default=0)

    __table_args__ = (
        UniqueConstraint('user_id', 'date', name='uq_user_activity_user_date'),
    )


class APICallLog(Base):
    """Log individual API calls for cost tracking."""
    __tablename__ = "api_call_logs"

    id = Column(String(36), primary_key=True)
    user_id = Column(String(36), nullable=False, index=True)
    story_id = Column(String(36), nullable=True, index=True)

    # Call details
    service = Column(String(50), nullable=False)  # anthropic, elevenlabs, s3
    operation = Column(String(100), nullable=False)

    # Usage metrics
    input_tokens = Column(Integer, default=0)
    output_tokens = Column(Integer, default=0)
    characters = Column(Integer, default=0)  # For ElevenLabs
    bytes_transferred = Column(Integer, default=0)  # For S3

    # Cost (in cents)
    cost_cents = Column(Integer, default=0)

    created_at = Column(DateTime, default=datetime.utcnow, index=True)
```

### 6. Analytics Dashboard Component (React)

**apps/admin-dashboard/src/pages/AnalyticsPage.tsx:**
```typescript
import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  LineChart,
  Line,
  AreaChart,
  Area,
  BarChart,
  Bar,
  PieChart,
  Pie,
  Cell,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from "recharts";
import { format, subDays } from "date-fns";
import { Calendar as CalendarIcon, Download, Users, DollarSign, FileAudio, TrendingUp } from "lucide-react";
import { adminApi } from "@/lib/api";

const COLORS = ["#8884d8", "#82ca9d", "#ffc658"];

export default function AnalyticsPage() {
  const [dateRange, setDateRange] = useState({
    start: subDays(new Date(), 30),
    end: new Date(),
  });

  const { data: dashboard, isLoading } = useQuery({
    queryKey: ["analytics-dashboard", dateRange],
    queryFn: () =>
      adminApi.get("/admin/analytics/dashboard", {
        params: {
          start_date: format(dateRange.start, "yyyy-MM-dd"),
          end_date: format(dateRange.end, "yyyy-MM-dd"),
        },
      }),
  });

  const { data: costs } = useQuery({
    queryKey: ["analytics-costs", dateRange],
    queryFn: () =>
      adminApi.get("/admin/analytics/costs", {
        params: {
          start_date: format(dateRange.start, "yyyy-MM-dd"),
          end_date: format(dateRange.end, "yyyy-MM-dd"),
        },
      }),
  });

  const { data: growth } = useQuery({
    queryKey: ["analytics-growth", dateRange],
    queryFn: () =>
      adminApi.get("/admin/analytics/users/growth", {
        params: {
          start_date: format(dateRange.start, "yyyy-MM-dd"),
          end_date: format(dateRange.end, "yyyy-MM-dd"),
        },
      }),
  });

  const exportData = async () => {
    const response = await adminApi.get("/admin/analytics/export", {
      params: {
        start_date: format(dateRange.start, "yyyy-MM-dd"),
        end_date: format(dateRange.end, "yyyy-MM-dd"),
        format: "csv",
      },
      responseType: "blob",
    });

    const url = window.URL.createObjectURL(new Blob([response]));
    const link = document.createElement("a");
    link.href = url;
    link.setAttribute("download", `analytics_${format(dateRange.start, "yyyy-MM-dd")}.csv`);
    document.body.appendChild(link);
    link.click();
    link.remove();
  };

  const totals = dashboard?.totals || {};
  const costBreakdown = costs?.breakdown || {};

  return (
    <div className="p-6 space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">Analytics</h1>
        <div className="flex gap-2">
          <Popover>
            <PopoverTrigger asChild>
              <Button variant="outline">
                <CalendarIcon className="h-4 w-4 mr-2" />
                {format(dateRange.start, "MMM d")} - {format(dateRange.end, "MMM d, yyyy")}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0" align="end">
              <Calendar
                mode="range"
                selected={{ from: dateRange.start, to: dateRange.end }}
                onSelect={(range) => {
                  if (range?.from && range?.to) {
                    setDateRange({ start: range.from, end: range.to });
                  }
                }}
              />
            </PopoverContent>
          </Popover>
          <Button onClick={exportData}>
            <Download className="h-4 w-4 mr-2" />
            Export
          </Button>
        </div>
      </div>

      {/* KPI Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">New Users</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{totals.new_users?.toLocaleString()}</div>
            <p className="text-xs text-muted-foreground">
              {growth?.growth_rate?.toFixed(1)}% growth
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Stories Created</CardTitle>
            <FileAudio className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{totals.stories_created?.toLocaleString()}</div>
            <p className="text-xs text-muted-foreground">
              {totals.total_audio_minutes?.toFixed(0)} min audio
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Total Cost</CardTitle>
            <DollarSign className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${(totals.total_cost_cents / 100)?.toFixed(2)}
            </div>
            <p className="text-xs text-muted-foreground">
              ${(costBreakdown.anthropic?.cost_dollars || 0).toFixed(2)} Anthropic
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Revenue</CardTitle>
            <TrendingUp className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${(totals.revenue_cents / 100)?.toFixed(2)}
            </div>
            <p className="text-xs text-muted-foreground">
              {totals.profit_margin?.toFixed(1)}% margin
            </p>
          </CardContent>
        </Card>
      </div>

      <Tabs defaultValue="usage">
        <TabsList>
          <TabsTrigger value="usage">Usage</TabsTrigger>
          <TabsTrigger value="costs">Costs</TabsTrigger>
          <TabsTrigger value="users">Users</TabsTrigger>
        </TabsList>

        <TabsContent value="usage" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>Stories Over Time</CardTitle>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={300}>
                <AreaChart data={dashboard?.daily || []}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="date" tickFormatter={(v) => format(new Date(v), "MMM d")} />
                  <YAxis />
                  <Tooltip labelFormatter={(v) => format(new Date(v), "MMM d, yyyy")} />
                  <Area type="monotone" dataKey="stories" stroke="#8884d8" fill="#8884d8" fillOpacity={0.3} />
                </AreaChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="costs" className="space-y-4">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
            <Card>
              <CardHeader>
                <CardTitle>Cost Breakdown</CardTitle>
              </CardHeader>
              <CardContent>
                <ResponsiveContainer width="100%" height={300}>
                  <PieChart>
                    <Pie
                      data={[
                        { name: "Anthropic", value: costBreakdown.anthropic?.cost_dollars || 0 },
                        { name: "ElevenLabs", value: costBreakdown.elevenlabs?.cost_dollars || 0 },
                        { name: "S3", value: costBreakdown.s3?.cost_dollars || 0 },
                      ]}
                      cx="50%"
                      cy="50%"
                      outerRadius={100}
                      dataKey="value"
                      label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                    >
                      {COLORS.map((color, index) => (
                        <Cell key={`cell-${index}`} fill={color} />
                      ))}
                    </Pie>
                    <Tooltip formatter={(value: number) => `$${value.toFixed(2)}`} />
                  </PieChart>
                </ResponsiveContainer>
              </CardContent>
            </Card>

            <Card>
              <CardHeader>
                <CardTitle>Daily Costs</CardTitle>
              </CardHeader>
              <CardContent>
                <ResponsiveContainer width="100%" height={300}>
                  <BarChart data={costs?.daily || []}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="date" tickFormatter={(v) => format(new Date(v), "MMM d")} />
                    <YAxis tickFormatter={(v) => `$${v}`} />
                    <Tooltip formatter={(value: number) => `$${value.toFixed(2)}`} />
                    <Legend />
                    <Bar dataKey="anthropic" stackId="a" fill="#8884d8" name="Anthropic" />
                    <Bar dataKey="elevenlabs" stackId="a" fill="#82ca9d" name="ElevenLabs" />
                    <Bar dataKey="s3" stackId="a" fill="#ffc658" name="S3" />
                  </BarChart>
                </ResponsiveContainer>
              </CardContent>
            </Card>
          </div>
        </TabsContent>

        <TabsContent value="users" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>User Growth</CardTitle>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={300}>
                <LineChart data={growth?.daily || []}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="date" tickFormatter={(v) => format(new Date(v), "MMM d")} />
                  <YAxis />
                  <Tooltip labelFormatter={(v) => format(new Date(v), "MMM d, yyyy")} />
                  <Legend />
                  <Line type="monotone" dataKey="total_users" stroke="#8884d8" name="Total Users" />
                  <Line type="monotone" dataKey="active_users" stroke="#82ca9d" name="Active Users" />
                </LineChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}
```

## File Structure
```
src/codestory/
├── tools/
│   └── analytics.py          # @tool decorated analytics tools
├── hooks/
│   └── analytics_hooks.py    # Security hooks for analytics
├── agents/
│   └── analytics_config.py   # SDK configuration
├── models/
│   └── analytics.py          # Database models
└── backend/
    └── api/
        └── routers/
            └── admin_analytics.py  # FastAPI endpoints

apps/admin-dashboard/
└── src/
    └── pages/
        └── AnalyticsPage.tsx  # React dashboard
```

## Validation Gates

### Gate 1: SDK Rate Limiting
```python
def test_analytics_rate_limiting():
    """Verify SDK hook enforces rate limits."""
    from src.codestory.hooks.analytics_hooks import validate_analytics_request

    # Simulate 31 requests (over limit of 30)
    for i in range(31):
        result = await validate_analytics_request(
            {"tool_name": "mcp__analytics__get_dashboard_metrics", "tool_input": {}},
            f"tool_{i}",
            {"admin_id": "admin-123"}
        )

        if i < 30:
            assert result == {}  # Allowed
        else:
            assert result["hookSpecificOutput"]["permissionDecision"] == "deny"
            assert "Rate limit" in result["hookSpecificOutput"]["permissionDecisionReason"]
```

### Gate 2: Date Range Validation
```python
def test_date_range_validation():
    """Verify SDK hook validates date ranges."""
    from src.codestory.hooks.analytics_hooks import validate_analytics_request

    # Test > 365 days rejected
    result = await validate_analytics_request(
        {
            "tool_name": "mcp__analytics__get_dashboard_metrics",
            "tool_input": {"start_date": "2023-01-01", "end_date": "2024-12-31"}
        },
        "tool_1",
        {"admin_id": "admin-123"}
    )

    assert result["hookSpecificOutput"]["permissionDecision"] == "deny"
    assert "365 days" in result["hookSpecificOutput"]["permissionDecisionReason"]
```

### Gate 3: Audit Logging
```python
def test_analytics_audit_logging():
    """Verify all analytics access is logged."""
    from src.codestory.hooks.analytics_hooks import audit_analytics_access

    await audit_analytics_access(
        {
            "tool_name": "mcp__analytics__export_analytics",
            "tool_input": {"start_date": "2024-01-01", "end_date": "2024-01-31", "format": "csv"}
        },
        "tool_1",
        {"admin_id": "admin-123", "admin_email": "admin@example.com"}
    )

    # Verify audit log entry
    from src.codestory.core.database import get_db_session
    from src.codestory.models.admin import AuditLog

    async with get_db_session() as db:
        log = db.query(AuditLog).filter(
            AuditLog.action == "analytics_data_exported"
        ).first()

        assert log is not None
        assert log.details["alert"] == "DATA_EXPORT"
```

### Gate 4: Dashboard Metrics
```python
def test_dashboard_metrics():
    """Verify dashboard returns aggregated metrics."""
    response = client.get(
        "/admin/analytics/dashboard",
        params={"start_date": "2024-01-01", "end_date": "2024-01-31"},
        headers=admin_headers
    )

    assert response.status_code == 200
    data = response.json()

    assert "totals" in data
    assert "daily" in data
    assert "new_users" in data["totals"]
    assert "total_cost_cents" in data["totals"]
```

### Gate 5: Charts Render (Playwright)
```typescript
test("analytics charts render with SDK data", async ({ page }) => {
  await page.goto("/admin/analytics");

  // Wait for SDK response
  await page.waitForSelector(".recharts-wrapper");

  // Check KPI cards populated
  await expect(page.locator("text=New Users")).toBeVisible();
  await expect(page.locator("text=Total Cost")).toBeVisible();

  // Check charts rendered
  await expect(page.locator(".recharts-area")).toBeVisible();

  // Switch to costs tab
  await page.click('button:has-text("Costs")');
  await expect(page.locator(".recharts-pie")).toBeVisible();

  // Test export button (should trigger SDK export_analytics tool)
  await page.click('button:has-text("Export")');
  // Download should start
});
```

## Definition of Done
- [ ] Analytics tools with @tool decorator
- [ ] Security hooks (rate limiting, date validation, audit logging)
- [ ] SDK configuration with SandboxSettings
- [ ] Daily metrics model and aggregation
- [ ] User activity tracking
- [ ] API call logging with costs
- [ ] Dashboard metrics endpoint via SDK
- [ ] Cost breakdown by service
- [ ] User growth metrics
- [ ] Top users by usage/cost
- [ ] CSV/JSON export functionality
- [ ] Analytics dashboard UI with charts
- [ ] Date range picker with validation
- [ ] All validation gates passing
