# Plan 11-02: User Management Interface

## Overview
Build comprehensive user management capabilities for admins using Claude Agent SDK patterns including @tool decorated functions, security hooks (rate limiting, audit logging), and proper SDK configuration with permission_mode="default".

## Dependencies
- Plan 11-01: Admin authentication with SDK patterns
- Phase 6: User models and database

## Claude Agent SDK Integration

### 1. User Management Tools

**tools/user_management.py:**
```python
"""User management tools using Claude Agent SDK @tool pattern."""
from claude_agent_sdk import tool
from datetime import datetime
from typing import Optional
import uuid

# -----------------------------------------------------------------------------
# User Search & Listing Tools
# -----------------------------------------------------------------------------

@tool(
    "search_users",
    "Search and filter users with pagination. Returns user list with metadata.",
    {
        "search": str,        # Search term for email/name
        "status": str,        # active, suspended, inactive
        "plan": str,          # free, pro, enterprise
        "page": int,
        "per_page": int
    }
)
async def search_users(args: dict) -> dict:
    """Search users with filtering."""
    # Implementation fetches from database with filters
    return {
        "content": [{
            "type": "text",
            "text": f"Found users matching criteria: search={args.get('search')}, status={args.get('status')}"
        }]
    }


@tool(
    "get_user_details",
    "Get detailed user information including stats and quotas.",
    {"user_id": str}
)
async def get_user_details(args: dict) -> dict:
    """Get comprehensive user details for admin view."""
    user_id = args["user_id"]
    # Implementation fetches user with stats
    return {
        "content": [{
            "type": "text",
            "text": f"User details for {user_id}: profile, stats, quotas"
        }]
    }


# -----------------------------------------------------------------------------
# User Modification Tools
# -----------------------------------------------------------------------------

@tool(
    "update_user",
    "Update user profile fields (name, email, plan). Logs changes for audit.",
    {
        "user_id": str,
        "name": str,
        "email": str,
        "plan": str
    }
)
async def update_user(args: dict) -> dict:
    """Update user profile with change tracking."""
    return {
        "content": [{
            "type": "text",
            "text": f"Updated user {args['user_id']}"
        }]
    }


@tool(
    "update_user_quotas",
    "Update user quotas (stories_per_month, api_requests_per_day, storage_bytes).",
    {
        "user_id": str,
        "stories_per_month": int,
        "api_requests_per_day": int,
        "storage_bytes": int
    }
)
async def update_user_quotas(args: dict) -> dict:
    """Update user quotas with validation."""
    return {
        "content": [{
            "type": "text",
            "text": f"Updated quotas for user {args['user_id']}"
        }]
    }


# -----------------------------------------------------------------------------
# User Status Tools
# -----------------------------------------------------------------------------

@tool(
    "suspend_user",
    "Suspend a user account with reason. User cannot access platform until unsuspended.",
    {"user_id": str, "reason": str}
)
async def suspend_user(args: dict) -> dict:
    """Suspend user account."""
    return {
        "content": [{
            "type": "text",
            "text": f"Suspended user {args['user_id']}: {args['reason']}"
        }]
    }


@tool(
    "unsuspend_user",
    "Remove suspension from user account.",
    {"user_id": str}
)
async def unsuspend_user(args: dict) -> dict:
    """Unsuspend user account."""
    return {
        "content": [{
            "type": "text",
            "text": f"Unsuspended user {args['user_id']}"
        }]
    }


@tool(
    "delete_user",
    "Delete user account. Soft delete by default, hard delete removes all data.",
    {"user_id": str, "hard_delete": bool}
)
async def delete_user(args: dict) -> dict:
    """Delete user account."""
    delete_type = "hard" if args.get("hard_delete") else "soft"
    return {
        "content": [{
            "type": "text",
            "text": f"{delete_type.capitalize()} deleted user {args['user_id']}"
        }]
    }


# -----------------------------------------------------------------------------
# Impersonation Tool
# -----------------------------------------------------------------------------

@tool(
    "create_impersonation_token",
    "Create temporary token to impersonate user for support. Token expires in 15 minutes.",
    {"user_id": str}
)
async def create_impersonation_token(args: dict) -> dict:
    """Create impersonation token for support purposes."""
    # CRITICAL: This action is always audit logged via PostToolUse hook
    return {
        "content": [{
            "type": "text",
            "text": f"Created 15-minute impersonation token for user {args['user_id']}"
        }]
    }
```

### 2. Security Hooks

**hooks/user_management_hooks.py:**
```python
"""Security hooks for user management operations."""
from datetime import datetime
import json
import redis

redis_client = redis.Redis(host='localhost', port=6379, db=0)

# Sensitive operations requiring extra validation
SENSITIVE_OPERATIONS = [
    "delete_user",
    "create_impersonation_token",
    "update_user_quotas"
]


async def validate_user_management_request(input_data: dict, tool_use_id: str, context: dict) -> dict:
    """
    PreToolUse hook: Validate user management requests.

    Enforces:
    - Rate limiting (10 requests per minute for regular ops, 5 for sensitive)
    - User existence validation
    - Permission checks
    """
    tool_name = input_data.get("tool_name", "")
    tool_input = input_data.get("tool_input", {})
    admin_id = context.get("admin_id")

    if not tool_name.startswith("mcp__user_mgmt__"):
        return {}

    operation = tool_name.replace("mcp__user_mgmt__", "")

    # Rate limiting
    rate_limit = 5 if operation in SENSITIVE_OPERATIONS else 10
    rate_key = f"user_mgmt_rate:{admin_id}:{operation}"

    current_count = redis_client.incr(rate_key)
    if current_count == 1:
        redis_client.expire(rate_key, 60)  # 1 minute window

    if current_count > rate_limit:
        return {
            "hookSpecificOutput": {
                "hookEventName": "PreToolUse",
                "permissionDecision": "deny",
                "permissionDecisionReason": f"Rate limit exceeded: {rate_limit} {operation} requests per minute"
            }
        }

    # Validate user_id exists for user-specific operations
    user_id = tool_input.get("user_id")
    if user_id:
        # Check user exists in database
        user_exists = await check_user_exists(user_id)
        if not user_exists:
            return {
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "permissionDecision": "deny",
                    "permissionDecisionReason": f"User {user_id} not found"
                }
            }

    # Additional validation for sensitive operations
    if operation in SENSITIVE_OPERATIONS:
        # Require confirmation for dangerous actions
        if operation == "delete_user" and tool_input.get("hard_delete"):
            # Log extra warning for hard deletes
            await log_security_event(
                "hard_delete_initiated",
                admin_id,
                {"user_id": user_id}
            )

    return {}


async def audit_user_management_action(input_data: dict, tool_use_id: str, context: dict) -> dict:
    """
    PostToolUse hook: Audit log all user management actions.

    Creates comprehensive audit entries with:
    - Actor (admin) info
    - Target (user) info
    - Action performed
    - Changes made
    - IP address and user agent
    """
    tool_name = input_data.get("tool_name", "")
    tool_input = input_data.get("tool_input", {})
    tool_response = input_data.get("tool_response", "")

    if not tool_name.startswith("mcp__user_mgmt__"):
        return {}

    admin_id = context.get("admin_id")
    admin_email = context.get("admin_email")
    ip_address = context.get("ip_address")
    user_agent = context.get("user_agent")

    operation = tool_name.replace("mcp__user_mgmt__", "")

    # Sanitize input - remove any sensitive fields
    sanitized_input = {
        k: v for k, v in tool_input.items()
        if k not in ["password", "token", "secret"]
    }

    audit_entry = {
        "id": str(uuid.uuid4()),
        "timestamp": datetime.utcnow().isoformat(),
        "actor_type": "admin",
        "actor_id": admin_id,
        "actor_email": admin_email,
        "action": f"user_mgmt_{operation}",
        "category": "user_management",
        "target_type": "user",
        "target_id": tool_input.get("user_id"),
        "details": sanitized_input,
        "ip_address": ip_address,
        "user_agent": user_agent,
        "tool_response_summary": str(tool_response)[:500]
    }

    # Store in audit log
    await store_audit_log(audit_entry)

    # For impersonation, send security alert
    if operation == "create_impersonation_token":
        await send_security_alert(
            "user_impersonation",
            f"Admin {admin_email} created impersonation token for user {tool_input.get('user_id')}",
            audit_entry
        )

    return {}


async def cleanup_user_management_session(input_data: dict, tool_use_id: str, context: dict) -> dict:
    """
    Stop hook: Cleanup when user management session ends.

    - Updates session activity timestamp
    - Clears any temporary caches
    - Logs session end
    """
    admin_id = context.get("admin_id")
    session_id = context.get("session_id")

    # Update session last activity
    await update_session_activity(session_id)

    # Clear rate limit keys for this session
    pattern = f"user_mgmt_rate:{admin_id}:*"
    for key in redis_client.scan_iter(pattern):
        redis_client.delete(key)

    return {}


# Helper functions
async def check_user_exists(user_id: str) -> bool:
    """Check if user exists in database."""
    # Implementation queries database
    return True

async def log_security_event(event_type: str, actor_id: str, details: dict):
    """Log security-relevant events."""
    pass

async def store_audit_log(entry: dict):
    """Store audit log entry to database."""
    pass

async def send_security_alert(alert_type: str, message: str, context: dict):
    """Send security alert for sensitive operations."""
    pass

async def update_session_activity(session_id: str):
    """Update session last activity timestamp."""
    pass
```

### 3. MCP Server Configuration

**tools/user_management_server.py:**
```python
"""User management MCP server with Claude Agent SDK."""
from claude_agent_sdk import (
    create_sdk_mcp_server,
    ClaudeAgentOptions,
    SandboxSettings,
    HookMatcher
)
from tools.user_management import (
    search_users,
    get_user_details,
    update_user,
    update_user_quotas,
    suspend_user,
    unsuspend_user,
    delete_user,
    create_impersonation_token
)
from hooks.user_management_hooks import (
    validate_user_management_request,
    audit_user_management_action,
    cleanup_user_management_session
)


def create_user_management_server():
    """Create in-process MCP server for user management tools."""
    return create_sdk_mcp_server(
        name="user_mgmt",
        version="1.0.0",
        tools=[
            search_users,
            get_user_details,
            update_user,
            update_user_quotas,
            suspend_user,
            unsuspend_user,
            delete_user,
            create_impersonation_token
        ]
    )


def get_user_management_sdk_options(request, db, admin) -> ClaudeAgentOptions:
    """
    Get SDK options for user management operations.

    CRITICAL: Uses permission_mode="default" - NEVER use bypassPermissions in production.
    """
    user_mgmt_server = create_user_management_server()

    return ClaudeAgentOptions(
        mcp_servers={
            "user_mgmt": user_mgmt_server
        },
        allowed_tools=[
            # User management tools
            "mcp__user_mgmt__search_users",
            "mcp__user_mgmt__get_user_details",
            "mcp__user_mgmt__update_user",
            "mcp__user_mgmt__update_user_quotas",
            "mcp__user_mgmt__suspend_user",
            "mcp__user_mgmt__unsuspend_user",
            "mcp__user_mgmt__delete_user",
            "mcp__user_mgmt__create_impersonation_token",
            # Built-in tools for database queries
            "Read",
            "Grep"
        ],
        # CRITICAL: Never use bypassPermissions in production
        permission_mode="default",
        sandbox=SandboxSettings(
            enabled=True,
            network="host"  # Allow database connections
        ),
        hooks={
            # PreToolUse: Validate and rate limit
            "PreToolUse": [
                HookMatcher(
                    matcher="mcp__user_mgmt__*",
                    hooks=[validate_user_management_request],
                    context={
                        "admin_id": admin.id,
                        "admin_email": admin.user.email,
                        "ip_address": request.client.host,
                        "user_agent": request.headers.get("user-agent")
                    }
                )
            ],
            # PostToolUse: Audit logging
            "PostToolUse": [
                HookMatcher(
                    matcher="*",
                    hooks=[audit_user_management_action],
                    context={
                        "admin_id": admin.id,
                        "admin_email": admin.user.email,
                        "ip_address": request.client.host,
                        "user_agent": request.headers.get("user-agent")
                    }
                )
            ],
            # Stop: Session cleanup
            "Stop": [
                HookMatcher(
                    matcher="*",
                    hooks=[cleanup_user_management_session],
                    context={
                        "admin_id": admin.id,
                        "session_id": request.state.session_id
                    }
                )
            ]
        },
        max_turns=15
    )
```

### 4. FastAPI Integration

**routers/admin_users.py:**
```python
"""Admin user management endpoints with Claude Agent SDK."""
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from claude_agent_sdk import ClaudeSDKClient

from database import get_db
from models.admin import AdminUser, Permission
from auth.admin_auth import get_current_admin, require_permission
from tools.user_management_server import get_user_management_sdk_options

router = APIRouter(prefix="/admin/users", tags=["admin-users"])


@router.get("")
async def list_users(
    search: str = None,
    status: str = None,
    plan: str = None,
    page: int = Query(1, ge=1),
    per_page: int = Query(20, ge=1, le=100),
    admin: AdminUser = Depends(require_permission(Permission.VIEW_USERS)),
    db: Session = Depends(get_db),
    request: Request
):
    """List and search users using SDK tools."""
    options = get_user_management_sdk_options(request, db, admin)

    async with ClaudeSDKClient(options=options) as client:
        prompt = f"Search users with: search={search}, status={status}, plan={plan}, page={page}, per_page={per_page}"
        await client.query(prompt)

        async for msg in client.receive_response():
            if hasattr(msg, 'content'):
                # Extract results from tool response
                return extract_user_list_response(msg.content)

    return {"users": [], "total": 0, "page": page, "per_page": per_page}


@router.get("/{user_id}")
async def get_user(
    user_id: str,
    admin: AdminUser = Depends(require_permission(Permission.VIEW_USERS)),
    db: Session = Depends(get_db),
    request: Request
):
    """Get detailed user information."""
    options = get_user_management_sdk_options(request, db, admin)

    async with ClaudeSDKClient(options=options) as client:
        await client.query(f"Get details for user {user_id}")

        async for msg in client.receive_response():
            if hasattr(msg, 'content'):
                return extract_user_detail_response(msg.content)

    raise HTTPException(status_code=404, detail="User not found")


@router.patch("/{user_id}/quotas")
async def update_quotas(
    user_id: str,
    quotas: QuotaUpdate,
    admin: AdminUser = Depends(require_permission(Permission.MANAGE_QUOTAS)),
    db: Session = Depends(get_db),
    request: Request
):
    """Update user quotas."""
    options = get_user_management_sdk_options(request, db, admin)

    async with ClaudeSDKClient(options=options) as client:
        prompt = f"Update quotas for user {user_id}: {quotas.model_dump_json()}"
        await client.query(prompt)

        async for msg in client.receive_response():
            return {"message": "Quotas updated", "user_id": user_id}


@router.post("/{user_id}/suspend")
async def suspend_user(
    user_id: str,
    request_body: SuspendRequest,
    admin: AdminUser = Depends(require_permission(Permission.EDIT_USERS)),
    db: Session = Depends(get_db),
    request: Request
):
    """Suspend a user account."""
    options = get_user_management_sdk_options(request, db, admin)

    async with ClaudeSDKClient(options=options) as client:
        await client.query(f"Suspend user {user_id} with reason: {request_body.reason}")

        async for msg in client.receive_response():
            return {"message": "User suspended", "user_id": user_id}


@router.post("/{user_id}/impersonate")
async def impersonate_user(
    user_id: str,
    admin: AdminUser = Depends(require_permission(Permission.EDIT_USERS)),
    db: Session = Depends(get_db),
    request: Request
):
    """Create impersonation token for support."""
    options = get_user_management_sdk_options(request, db, admin)

    async with ClaudeSDKClient(options=options) as client:
        await client.query(f"Create impersonation token for user {user_id}")

        async for msg in client.receive_response():
            # Token extracted from tool response
            return {
                "impersonation_token": extract_token(msg.content),
                "expires_in": 900,  # 15 minutes
                "warning": "This action is logged for audit purposes"
            }
```

## File Structure
```
backend/
├── tools/
│   ├── user_management.py           # @tool decorated functions
│   └── user_management_server.py    # MCP server + SDK options
├── hooks/
│   └── user_management_hooks.py     # Security hooks
└── routers/
    └── admin_users.py               # FastAPI endpoints

apps/admin-dashboard/
└── src/
    ├── pages/
    │   └── UsersPage.tsx
    └── components/
        ├── UserDetailSheet.tsx
        └── Pagination.tsx
```

## Validation Gates

### Gate 1: SDK Hook Rate Limiting
```python
def test_user_mgmt_rate_limiting():
    """Verify PreToolUse hook enforces rate limits."""
    # Make 11 requests rapidly (limit is 10 for regular ops)
    for i in range(11):
        response = client.get("/admin/users", headers=admin_headers)
        if i < 10:
            assert response.status_code == 200
        else:
            # 11th request should be rate limited
            assert response.status_code == 429
            assert "Rate limit exceeded" in response.json()["detail"]
```

### Gate 2: SDK Audit Logging
```python
def test_user_mgmt_audit_logging():
    """Verify PostToolUse hook creates audit entries."""
    # Perform user update
    response = client.patch(
        f"/admin/users/{user_id}",
        json={"name": "Updated Name"},
        headers=admin_headers
    )
    assert response.status_code == 200

    # Check audit log was created
    audit_resp = client.get(
        "/admin/audit/logs",
        params={"action": "user_mgmt_update_user", "target_id": user_id},
        headers=admin_headers
    )
    logs = audit_resp.json()["logs"]
    assert len(logs) >= 1
    assert logs[0]["actor_id"] == admin_id
```

### Gate 3: Impersonation Security
```python
def test_impersonation_audit():
    """Verify impersonation creates security alert."""
    response = client.post(
        f"/admin/users/{user_id}/impersonate",
        headers=admin_headers
    )

    assert response.status_code == 200
    assert "impersonation_token" in response.json()

    # Verify security alert was sent
    alerts = get_security_alerts(type="user_impersonation")
    assert len(alerts) >= 1
    assert alerts[0]["target_user_id"] == user_id
```

### Gate 4: Sensitive Operation Validation
```python
def test_hard_delete_validation():
    """Verify hard delete has extra validation."""
    # Attempt hard delete
    response = client.delete(
        f"/admin/users/{user_id}?hard_delete=true",
        headers=admin_headers
    )

    # Should succeed but with security event logged
    assert response.status_code == 200

    # Check security event was logged
    events = get_security_events(type="hard_delete_initiated")
    assert len(events) >= 1
```

## Security Considerations

1. **Rate Limiting via Hooks**: PreToolUse enforces 10 req/min for regular ops, 5 for sensitive
2. **Comprehensive Audit Trail**: PostToolUse logs all actions with sanitized inputs
3. **Impersonation Alerts**: Security alerts sent for impersonation tokens
4. **Session Cleanup**: Stop hook clears rate limit caches and updates activity
5. **Permission Mode**: Uses "default" mode - NEVER bypassPermissions
6. **Sandbox Enabled**: Tools run in sandboxed environment

## Definition of Done
- [ ] @tool decorated user management functions
- [ ] PreToolUse hook for rate limiting and validation
- [ ] PostToolUse hook for comprehensive audit logging
- [ ] Stop hook for session cleanup
- [ ] ClaudeAgentOptions with proper security configuration
- [ ] FastAPI endpoints using ClaudeSDKClient
- [ ] Admin dashboard UI components
- [ ] All SDK hook validation gates passing
