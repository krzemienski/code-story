# Plan 11-01: Admin Authentication and Authorization with Claude Agent SDK

## Overview
Implement secure admin authentication with role-based access control using Claude Agent SDK production patterns. Includes security hooks for rate limiting, audit logging, and proper sandbox isolation for admin operations.

## Dependencies
- Phase 6: FastAPI backend with JWT authentication
- Plan 10-01: API key management infrastructure
- Claude Agent SDK installed (`pip install claude-agent-sdk`)

## Claude Agent SDK Production Patterns

### Security Hooks Architecture

```python
"""Admin authentication with Claude Agent SDK security patterns."""
from datetime import datetime, timedelta
from typing import Optional
import hashlib
import uuid
import pyotp
import logging

from claude_agent_sdk import (
    tool, create_sdk_mcp_server, ClaudeAgentOptions,
    ClaudeSDKClient, AgentDefinition, HookMatcher, SandboxSettings
)
from fastapi import Request, HTTPException, status
from sqlalchemy.orm import Session

logger = logging.getLogger(__name__)


# =============================================================================
# PRODUCTION SECURITY HOOKS
# =============================================================================

async def validate_admin_request(input_data: dict, tool_use_id: str, context: dict) -> dict:
    """
    PreToolUse hook for admin authentication validation.

    Validates:
    - Rate limiting per IP/user
    - Session validity
    - Permission checks
    - IP allowlist (if configured)
    """
    tool_name = input_data.get("tool_name", "")
    tool_input = input_data.get("tool_input", {})

    # Rate limiting check
    ip_address = context.get("ip_address", "unknown")
    rate_limit_key = f"admin_rate:{ip_address}"

    # Check rate limit (5 requests per minute for auth endpoints)
    if tool_name.startswith("mcp__admin__auth"):
        rate_count = await context.get("redis").incr(rate_limit_key)
        if rate_count == 1:
            await context.get("redis").expire(rate_limit_key, 60)

        if rate_count > 5:
            logger.warning(f"Rate limit exceeded for admin auth: {ip_address}")
            return {
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "permissionDecision": "deny",
                    "permissionDecisionReason": "Rate limit exceeded. Try again later."
                }
            }

    # IP allowlist check for sensitive operations
    if tool_name in ["mcp__admin__manage_admins", "mcp__admin__system_settings"]:
        allowed_ips = context.get("admin_allowed_ips", [])
        if allowed_ips and ip_address not in allowed_ips:
            logger.warning(f"Admin action from non-allowlisted IP: {ip_address}")
            return {
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "permissionDecision": "deny",
                    "permissionDecisionReason": "Access denied from this IP address."
                }
            }

    return {}


async def audit_admin_log(input_data: dict, tool_use_id: str, context: dict) -> dict:
    """
    PostToolUse hook for comprehensive audit logging.

    Logs:
    - Actor (admin user)
    - Action performed
    - Target resource
    - IP address and user agent
    - Timestamp
    - Success/failure status
    """
    tool_name = input_data.get("tool_name", "")
    tool_input = input_data.get("tool_input", {})
    tool_response = input_data.get("tool_response", {})

    # Create audit log entry
    audit_entry = {
        "id": str(uuid.uuid4()),
        "timestamp": datetime.utcnow().isoformat(),
        "actor_type": "admin",
        "actor_id": context.get("admin_id"),
        "actor_email": context.get("admin_email"),
        "action": tool_name,
        "tool_input": _sanitize_for_audit(tool_input),
        "ip_address": context.get("ip_address"),
        "user_agent": context.get("user_agent"),
        "request_id": context.get("request_id"),
        "status": "success" if not tool_response.get("error") else "failure",
        "error_message": tool_response.get("error"),
    }

    # Log to audit service
    logger.info(f"[ADMIN AUDIT] {audit_entry['action']}: {audit_entry['status']}",
                extra={"audit": audit_entry})

    # Store in database
    if context.get("db"):
        await _store_audit_log(context.get("db"), audit_entry)

    return {}


async def cleanup_admin_session(input_data: dict, tool_use_id: str, context: dict) -> dict:
    """
    Stop hook for session cleanup and resource release.
    """
    session_id = context.get("session_id")
    if session_id:
        logger.info(f"Admin session ended: {session_id}")
        # Update session last_activity
        if context.get("db"):
            await _update_session_activity(context.get("db"), session_id)

    return {}


def _sanitize_for_audit(data: dict) -> dict:
    """Remove sensitive fields from audit logs."""
    sensitive_fields = {"password", "totp_code", "secret", "token"}
    return {k: "***" if k in sensitive_fields else v for k, v in data.items()}


# =============================================================================
# ADMIN TOOLS (MCP Server)
# =============================================================================

@tool("admin_login", "Authenticate admin user with optional 2FA", {
    "email": str,
    "password": str,
    "totp_code": str  # Optional
})
async def admin_login(args: dict) -> dict:
    """Authenticate admin and create session."""
    from services.admin_auth_service import AdminAuthService

    db = args.get("_context", {}).get("db")
    service = AdminAuthService(db)

    admin, error = service.authenticate(
        email=args["email"],
        password=args["password"],
        ip_address=args.get("_context", {}).get("ip_address", "unknown"),
        user_agent=args.get("_context", {}).get("user_agent")
    )

    if error:
        return {"content": [{"type": "text", "text": f"Authentication failed: {error}"}]}

    # Check 2FA if enabled
    if admin.totp_enabled:
        if not args.get("totp_code"):
            return {"content": [{"type": "text", "text": "2FA code required"}]}

        if not service.verify_totp(admin, args["totp_code"]):
            return {"content": [{"type": "text", "text": "Invalid 2FA code"}]}

    # Create session
    token = service.create_admin_session(
        admin,
        args.get("_context", {}).get("ip_address", "unknown"),
        args.get("_context", {}).get("user_agent")
    )

    return {
        "content": [{
            "type": "text",
            "text": f"Login successful. Token: {token[:20]}..."
        }],
        "data": {
            "access_token": token,
            "admin_id": admin.id,
            "role": admin.role.value,
            "permissions": [p.value for p in admin.get_permissions()]
        }
    }


@tool("admin_logout", "End admin session", {})
async def admin_logout(args: dict) -> dict:
    """Logout and revoke all admin sessions."""
    from services.admin_auth_service import AdminAuthService

    db = args.get("_context", {}).get("db")
    admin_id = args.get("_context", {}).get("admin_id")

    service = AdminAuthService(db)
    service.revoke_all_sessions(admin_id)

    return {"content": [{"type": "text", "text": "Logged out successfully"}]}


@tool("setup_2fa", "Initialize 2FA setup for admin", {})
async def setup_2fa(args: dict) -> dict:
    """Generate TOTP secret for 2FA setup."""
    from services.admin_auth_service import AdminAuthService

    db = args.get("_context", {}).get("db")
    admin_id = args.get("_context", {}).get("admin_id")

    service = AdminAuthService(db)
    admin = db.query(AdminUser).filter(AdminUser.id == admin_id).first()

    if admin.totp_enabled:
        return {"content": [{"type": "text", "text": "2FA already enabled"}]}

    provisioning_uri = service.setup_totp(admin)

    return {
        "content": [{"type": "text", "text": "Scan QR code with authenticator app"}],
        "data": {
            "secret": admin.totp_secret,
            "provisioning_uri": provisioning_uri
        }
    }


@tool("verify_2fa", "Verify and enable 2FA", {"code": str})
async def verify_2fa(args: dict) -> dict:
    """Verify TOTP code and enable 2FA."""
    from services.admin_auth_service import AdminAuthService

    db = args.get("_context", {}).get("db")
    admin_id = args.get("_context", {}).get("admin_id")

    service = AdminAuthService(db)
    admin = db.query(AdminUser).filter(AdminUser.id == admin_id).first()

    if service.enable_totp(admin, args["code"]):
        return {"content": [{"type": "text", "text": "2FA enabled successfully"}]}

    return {"content": [{"type": "text", "text": "Invalid verification code"}]}


# =============================================================================
# SDK CLIENT CONFIGURATION
# =============================================================================

def create_admin_sdk_server():
    """Create in-process MCP server for admin operations."""
    return create_sdk_mcp_server(
        name="admin-auth",
        version="1.0.0",
        tools=[admin_login, admin_logout, setup_2fa, verify_2fa]
    )


def get_admin_sdk_options(request: Request, db: Session) -> ClaudeAgentOptions:
    """
    Configure Claude Agent SDK for admin operations.

    CRITICAL: Uses permission_mode="default" in production.
    NEVER use bypassPermissions in production environments.
    """
    admin_server = create_admin_sdk_server()

    return ClaudeAgentOptions(
        mcp_servers={"admin": admin_server},
        allowed_tools=[
            "mcp__admin__admin_login",
            "mcp__admin__admin_logout",
            "mcp__admin__setup_2fa",
            "mcp__admin__verify_2fa",
        ],
        permission_mode="default",  # CRITICAL: NOT bypassPermissions in production
        sandbox=SandboxSettings(
            enabled=True,
            network="host",  # Allow network for auth services
        ),
        hooks={
            "PreToolUse": [
                HookMatcher(matcher="mcp__admin__*", hooks=[validate_admin_request])
            ],
            "PostToolUse": [
                HookMatcher(matcher="*", hooks=[audit_admin_log])
            ],
            "Stop": [
                HookMatcher(matcher="*", hooks=[cleanup_admin_session])
            ]
        },
        max_turns=10,  # Limit turns for security
    )
```

## Implementation

### 1. Admin Role Models

**models/admin.py:**
```python
"""Admin role and permission models."""
from enum import Enum
from datetime import datetime
from sqlalchemy import Column, String, DateTime, Boolean, ForeignKey, Enum as SQLEnum
from sqlalchemy.orm import relationship

from database import Base


class AdminRole(str, Enum):
    """Admin role levels."""
    SUPER_ADMIN = "super_admin"  # Full system access
    ADMIN = "admin"              # User and content management
    SUPPORT = "support"          # Read-only access, limited actions


class Permission(str, Enum):
    """Granular permissions."""
    # User management
    VIEW_USERS = "view_users"
    EDIT_USERS = "edit_users"
    DELETE_USERS = "delete_users"
    MANAGE_QUOTAS = "manage_quotas"

    # Content management
    VIEW_STORIES = "view_stories"
    DELETE_STORIES = "delete_stories"

    # API key management
    VIEW_API_KEYS = "view_api_keys"
    REVOKE_API_KEYS = "revoke_api_keys"

    # Analytics
    VIEW_ANALYTICS = "view_analytics"
    EXPORT_DATA = "export_data"

    # System
    VIEW_AUDIT_LOGS = "view_audit_logs"
    MANAGE_ADMINS = "manage_admins"
    SYSTEM_SETTINGS = "system_settings"


# Role to permissions mapping
ROLE_PERMISSIONS = {
    AdminRole.SUPER_ADMIN: list(Permission),
    AdminRole.ADMIN: [
        Permission.VIEW_USERS, Permission.EDIT_USERS, Permission.MANAGE_QUOTAS,
        Permission.VIEW_STORIES, Permission.DELETE_STORIES,
        Permission.VIEW_API_KEYS, Permission.REVOKE_API_KEYS,
        Permission.VIEW_ANALYTICS, Permission.EXPORT_DATA,
        Permission.VIEW_AUDIT_LOGS,
    ],
    AdminRole.SUPPORT: [
        Permission.VIEW_USERS,
        Permission.VIEW_STORIES,
        Permission.VIEW_API_KEYS,
        Permission.VIEW_ANALYTICS,
    ],
}


class AdminUser(Base):
    """Admin user with elevated privileges."""
    __tablename__ = "admin_users"

    id = Column(String(36), primary_key=True)
    user_id = Column(String(36), ForeignKey("users.id"), unique=True, nullable=False)
    role = Column(SQLEnum(AdminRole), nullable=False, default=AdminRole.SUPPORT)

    # Status
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    created_by = Column(String(36), ForeignKey("admin_users.id"), nullable=True)
    deactivated_at = Column(DateTime, nullable=True)

    # Two-factor authentication
    totp_secret = Column(String(32), nullable=True)
    totp_enabled = Column(Boolean, default=False)

    # Session management
    last_login_at = Column(DateTime, nullable=True)
    last_login_ip = Column(String(45), nullable=True)

    # Relationships
    user = relationship("User", back_populates="admin_profile")
    audit_logs = relationship("AuditLog", back_populates="admin")

    def has_permission(self, permission: Permission) -> bool:
        """Check if admin has a specific permission."""
        if not self.is_active:
            return False
        return permission in ROLE_PERMISSIONS.get(self.role, [])

    def get_permissions(self) -> list[Permission]:
        """Get all permissions for this admin."""
        return ROLE_PERMISSIONS.get(self.role, [])


class AdminSession(Base):
    """Track admin sessions for security."""
    __tablename__ = "admin_sessions"

    id = Column(String(36), primary_key=True)
    admin_id = Column(String(36), ForeignKey("admin_users.id"), nullable=False)

    # Session data
    token_hash = Column(String(64), nullable=False, unique=True)
    ip_address = Column(String(45), nullable=False)
    user_agent = Column(String(500), nullable=True)

    # Lifecycle
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=False)
    revoked_at = Column(DateTime, nullable=True)

    # Activity
    last_activity_at = Column(DateTime, default=datetime.utcnow)
```

### 2. Admin Authentication Service

**services/admin_auth_service.py:**
```python
"""Admin authentication service with 2FA and SDK hooks support."""
import uuid
import pyotp
import hashlib
from datetime import datetime, timedelta
from typing import Optional
from sqlalchemy.orm import Session

from models.admin import AdminUser, AdminSession, AdminRole, Permission
from models.user import User
from auth import create_access_token, verify_password


class AdminAuthService:
    """Service for admin authentication with SDK integration."""

    def __init__(self, db: Session):
        self.db = db
        self.session_duration = timedelta(hours=8)
        self.max_sessions = 3

    def authenticate(
        self,
        email: str,
        password: str,
        ip_address: str,
        user_agent: Optional[str] = None
    ) -> tuple[Optional[AdminUser], Optional[str]]:
        """Authenticate admin and return admin user or error."""
        user = self.db.query(User).filter(User.email == email).first()
        if not user:
            return None, "Invalid credentials"

        if not verify_password(password, user.password_hash):
            return None, "Invalid credentials"

        admin = self.db.query(AdminUser).filter(
            AdminUser.user_id == user.id,
            AdminUser.is_active == True
        ).first()

        if not admin:
            return None, "Not authorized for admin access"

        admin.last_login_at = datetime.utcnow()
        admin.last_login_ip = ip_address
        self.db.commit()

        return admin, None

    def verify_totp(self, admin: AdminUser, code: str) -> bool:
        """Verify TOTP code for 2FA."""
        if not admin.totp_enabled or not admin.totp_secret:
            return True

        totp = pyotp.TOTP(admin.totp_secret)
        return totp.verify(code, valid_window=1)

    def create_admin_session(
        self,
        admin: AdminUser,
        ip_address: str,
        user_agent: Optional[str] = None
    ) -> str:
        """Create admin session and return JWT token."""
        # Enforce max sessions
        active_sessions = self.db.query(AdminSession).filter(
            AdminSession.admin_id == admin.id,
            AdminSession.revoked_at.is_(None),
            AdminSession.expires_at > datetime.utcnow()
        ).order_by(AdminSession.created_at.asc()).all()

        if len(active_sessions) >= self.max_sessions:
            oldest = active_sessions[0]
            oldest.revoked_at = datetime.utcnow()

        # Create JWT with admin claims
        token_data = {
            "sub": admin.user_id,
            "admin_id": admin.id,
            "role": admin.role.value,
            "permissions": [p.value for p in admin.get_permissions()],
            "type": "admin",
        }
        token = create_access_token(token_data, expires_delta=self.session_duration)

        # Store session
        session = AdminSession(
            id=str(uuid.uuid4()),
            admin_id=admin.id,
            token_hash=hashlib.sha256(token.encode()).hexdigest(),
            ip_address=ip_address,
            user_agent=user_agent,
            expires_at=datetime.utcnow() + self.session_duration
        )
        self.db.add(session)
        self.db.commit()

        return token

    def validate_session(self, token: str) -> Optional[AdminSession]:
        """Validate admin session token."""
        token_hash = hashlib.sha256(token.encode()).hexdigest()

        session = self.db.query(AdminSession).filter(
            AdminSession.token_hash == token_hash,
            AdminSession.revoked_at.is_(None),
            AdminSession.expires_at > datetime.utcnow()
        ).first()

        if session:
            session.last_activity_at = datetime.utcnow()
            self.db.commit()

        return session

    def revoke_session(self, session_id: str, admin_id: str) -> bool:
        """Revoke an admin session."""
        session = self.db.query(AdminSession).filter(
            AdminSession.id == session_id,
            AdminSession.admin_id == admin_id
        ).first()

        if not session:
            return False

        session.revoked_at = datetime.utcnow()
        self.db.commit()
        return True

    def revoke_all_sessions(self, admin_id: str) -> int:
        """Revoke all sessions for an admin."""
        result = self.db.query(AdminSession).filter(
            AdminSession.admin_id == admin_id,
            AdminSession.revoked_at.is_(None)
        ).update({"revoked_at": datetime.utcnow()})

        self.db.commit()
        return result

    def setup_totp(self, admin: AdminUser) -> str:
        """Generate TOTP secret for 2FA setup."""
        secret = pyotp.random_base32()
        admin.totp_secret = secret
        self.db.commit()

        return pyotp.totp.TOTP(secret).provisioning_uri(
            name=admin.user.email,
            issuer_name="Code Story Admin"
        )

    def enable_totp(self, admin: AdminUser, code: str) -> bool:
        """Enable 2FA after verifying setup code."""
        if not admin.totp_secret:
            return False

        totp = pyotp.TOTP(admin.totp_secret)
        if totp.verify(code):
            admin.totp_enabled = True
            self.db.commit()
            return True

        return False
```

### 3. FastAPI Router with SDK Integration

**routers/admin_auth.py:**
```python
"""Admin authentication endpoints with SDK hooks."""
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.orm import Session

from database import get_db
from models.admin import AdminUser
from schemas.admin import (
    AdminLoginRequest,
    AdminLoginResponse,
    AdminTOTPSetup,
    AdminTOTPVerify,
    AdminSessionList,
)
from services.admin_auth_service import AdminAuthService
from auth.admin_auth import get_current_admin
from sdk.admin_hooks import audit_admin_action

router = APIRouter(prefix="/admin/auth", tags=["admin-auth"])


@router.post("/login", response_model=AdminLoginResponse)
async def admin_login(
    request: Request,
    login_data: AdminLoginRequest,
    db: Session = Depends(get_db)
):
    """Authenticate admin user with SDK audit hooks."""
    service = AdminAuthService(db)

    ip_address = request.client.host if request.client else "unknown"
    user_agent = request.headers.get("user-agent")

    admin, error = service.authenticate(
        email=login_data.email,
        password=login_data.password,
        ip_address=ip_address,
        user_agent=user_agent
    )

    if error:
        # Log failed attempt
        await audit_admin_action(
            action="admin_login_failed",
            actor_email=login_data.email,
            ip_address=ip_address,
            status="failure",
            error_message=error
        )
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=error
        )

    # Check 2FA if enabled
    if admin.totp_enabled:
        if not login_data.totp_code:
            return AdminLoginResponse(
                requires_2fa=True,
                message="2FA code required"
            )

        if not service.verify_totp(admin, login_data.totp_code):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid 2FA code"
            )

    # Create session
    token = service.create_admin_session(admin, ip_address, user_agent)

    # Audit successful login
    await audit_admin_action(
        action="admin_login",
        actor_id=admin.id,
        actor_email=admin.user.email,
        ip_address=ip_address,
        status="success"
    )

    return AdminLoginResponse(
        access_token=token,
        token_type="bearer",
        admin_id=admin.id,
        role=admin.role.value,
        permissions=[p.value for p in admin.get_permissions()]
    )


@router.post("/logout")
async def admin_logout(
    request: Request,
    admin: AdminUser = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """Logout current admin session with audit."""
    service = AdminAuthService(db)
    service.revoke_all_sessions(admin.id)

    await audit_admin_action(
        action="admin_logout",
        actor_id=admin.id,
        actor_email=admin.user.email,
        ip_address=request.client.host if request.client else "unknown",
        status="success"
    )

    return {"message": "Logged out successfully"}


@router.get("/me", response_model=dict)
async def get_current_admin_info(
    admin: AdminUser = Depends(get_current_admin)
):
    """Get current admin user info."""
    return {
        "id": admin.id,
        "user_id": admin.user_id,
        "email": admin.user.email,
        "role": admin.role.value,
        "permissions": [p.value for p in admin.get_permissions()],
        "totp_enabled": admin.totp_enabled,
        "last_login_at": admin.last_login_at,
    }


@router.post("/2fa/setup", response_model=AdminTOTPSetup)
async def setup_2fa(
    admin: AdminUser = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """Generate 2FA setup QR code."""
    if admin.totp_enabled:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="2FA already enabled"
        )

    service = AdminAuthService(db)
    provisioning_uri = service.setup_totp(admin)

    return AdminTOTPSetup(
        secret=admin.totp_secret,
        provisioning_uri=provisioning_uri
    )


@router.post("/2fa/verify")
async def verify_2fa(
    request: Request,
    data: AdminTOTPVerify,
    admin: AdminUser = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """Verify 2FA code and enable 2FA."""
    service = AdminAuthService(db)

    if not service.enable_totp(admin, data.code):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid verification code"
        )

    await audit_admin_action(
        action="admin_2fa_enabled",
        actor_id=admin.id,
        actor_email=admin.user.email,
        ip_address=request.client.host if request.client else "unknown",
        status="success"
    )

    return {"message": "2FA enabled successfully"}
```

## Security Reasoning

**Authentication Hardening:**
- Require strong passwords (12+ chars, complexity requirements)
- Enforce MFA for all admin accounts (TOTP or WebAuthn)
- Rate limit login attempts (5 attempts, then 15-min lockout via SDK hooks)
- Log all authentication events with IP and user agent
- Session timeout: 1 hour inactive, 8 hours absolute

**SDK Security Integration:**
- PreToolUse hooks validate rate limits and IP allowlists
- PostToolUse hooks create comprehensive audit logs
- Stop hooks clean up sessions properly
- SandboxSettings with network="host" for auth services
- permission_mode="default" (NEVER bypassPermissions in production)

**Privilege Escalation Prevention:**
- Super-admin can't be created via API (seed data only)
- Role changes require higher-role approval
- Self-modification limits (can't elevate own role)

## File Structure
```
backend/
├── models/
│   └── admin.py
├── schemas/
│   └── admin.py
├── services/
│   └── admin_auth_service.py
├── routers/
│   └── admin_auth.py
├── auth/
│   └── admin_auth.py
└── sdk/
    └── admin_hooks.py
```

## Validation Gates

### Gate 1: SDK Hooks Execute
```python
def test_sdk_hooks_execute():
    """Verify SDK security hooks are called."""
    # Login should trigger PreToolUse and PostToolUse hooks
    with patch('sdk.admin_hooks.validate_admin_request') as mock_pre:
        with patch('sdk.admin_hooks.audit_admin_log') as mock_post:
            response = client.post("/admin/auth/login", json={
                "email": "admin@codestory.dev",
                "password": "secure_password"
            })

            # Hooks should be called
            mock_pre.assert_called()
            mock_post.assert_called()
```

### Gate 2: Rate Limiting via Hooks
```python
def test_rate_limiting_via_hooks():
    """Verify rate limiting works through SDK hooks."""
    # Make 6 requests (over limit of 5)
    for i in range(6):
        response = client.post("/admin/auth/login", json={
            "email": "admin@codestory.dev",
            "password": "wrong_password"
        })

    # 6th request should be rate limited
    assert response.status_code == 429
    assert "Rate limit" in response.json()["detail"]
```

### Gate 3: Audit Logging
```python
def test_audit_logging():
    """Verify admin actions are logged via SDK hooks."""
    response = client.post("/admin/auth/login", json={
        "email": "admin@codestory.dev",
        "password": "secure_password"
    })

    # Check audit log was created
    logs = client.get("/admin/audit/logs",
                      params={"action": "admin_login"},
                      headers=admin_headers)

    assert logs.status_code == 200
    assert len(logs.json()["logs"]) >= 1
```

### Gate 4: 2FA Flow
```python
def test_2fa_with_sdk():
    """Verify 2FA works with SDK integration."""
    # Setup 2FA
    setup_resp = client.post(
        "/admin/auth/2fa/setup",
        headers=admin_headers
    )
    secret = setup_resp.json()["secret"]

    # Generate valid TOTP
    totp = pyotp.TOTP(secret)
    code = totp.now()

    # Verify and enable
    client.post("/admin/auth/2fa/verify",
                json={"code": code},
                headers=admin_headers)

    # Login with 2FA required
    login_resp = client.post("/admin/auth/login", json={
        "email": "admin@codestory.dev",
        "password": "secure_password",
        "totp_code": totp.now()
    })
    assert "access_token" in login_resp.json()
```

## Definition of Done
- [ ] Admin user model with roles
- [ ] Permission system with role-based access
- [ ] Admin authentication service with SDK hooks
- [ ] TOTP 2FA setup and verification
- [ ] SDK PreToolUse hook for rate limiting
- [ ] SDK PostToolUse hook for audit logging
- [ ] SDK Stop hook for session cleanup
- [ ] SandboxSettings configured properly
- [ ] permission_mode="default" (NOT bypassPermissions)
- [ ] All validation gates passing
