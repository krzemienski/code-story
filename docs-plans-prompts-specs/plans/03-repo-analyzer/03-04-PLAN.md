# Plan 03-04: Pattern Recognition Tools

## Overview

**Phase**: 3 - Repo Analyzer Agent
**Plan**: 04 of 05
**Depends on**: 03-03 (Caching and Pipeline)
**Enables**: 03-05 (Key Component Identification)

## Goal

Create pattern recognition tools using Claude Agent SDK's `@tool` decorator that identify architectural patterns, design patterns, and framework conventions in analyzed repositories.

## Claude Agent SDK Pattern

Pattern tools use the `@tool` decorator for MCP server integration:

```python
from claude_agent_sdk import tool

@tool(
    name="detect_architectural_patterns",
    description="Detect architectural patterns from repository structure",
    input_schema={
        "type": "object",
        "properties": {...},
        "required": [...]
    }
)
async def detect_architectural_patterns(args: dict) -> dict:
    return {"content": [{"type": "text", "text": json.dumps(result)}]}
```

## Tasks

### Task 1: Create Pattern Recognition Tools

**File**: `src/codestory/tools/patterns.py`

```python
"""Pattern recognition tools for Code Story.

Uses Claude Agent SDK @tool decorator for architectural and design pattern detection.
"""

import json
from dataclasses import dataclass, field
from enum import Enum
from typing import Any

from claude_agent_sdk import tool


class ArchitecturalPattern(str, Enum):
    """High-level architectural patterns."""
    MVC = "mvc"
    MVP = "mvp"
    MVVM = "mvvm"
    LAYERED = "layered"
    MICROSERVICES = "microservices"
    MONOLITH = "monolith"
    EVENT_DRIVEN = "event_driven"
    HEXAGONAL = "hexagonal"
    CLEAN = "clean_architecture"
    CQRS = "cqrs"
    SERVERLESS = "serverless"


class DesignPattern(str, Enum):
    """GoF and common design patterns."""
    SINGLETON = "singleton"
    FACTORY = "factory"
    ABSTRACT_FACTORY = "abstract_factory"
    BUILDER = "builder"
    ADAPTER = "adapter"
    DECORATOR = "decorator"
    FACADE = "facade"
    OBSERVER = "observer"
    STRATEGY = "strategy"
    COMMAND = "command"
    REPOSITORY = "repository"
    DEPENDENCY_INJECTION = "dependency_injection"


@dataclass
class PatternMatch:
    """Represents a detected pattern with evidence."""
    pattern_type: str
    pattern_name: str
    confidence: float  # 0.0 to 1.0
    evidence: list[str] = field(default_factory=list)
    locations: list[str] = field(default_factory=list)
    description: str = ""

    def to_dict(self) -> dict[str, Any]:
        return {
            "pattern_type": self.pattern_type,
            "pattern_name": self.pattern_name,
            "confidence": self.confidence,
            "evidence": self.evidence,
            "locations": self.locations,
            "description": self.description,
        }


# Pattern detection rules
ARCHITECTURAL_INDICATORS = {
    ArchitecturalPattern.MVC: {
        "directories": ["models", "views", "controllers"],
        "files": ["controller.py", "view.py", "model.py"],
        "imports": ["flask", "django", "rails"],
    },
    ArchitecturalPattern.LAYERED: {
        "directories": ["presentation", "business", "data", "domain", "infrastructure"],
        "files": ["service.py", "repository.py", "entity.py"],
    },
    ArchitecturalPattern.HEXAGONAL: {
        "directories": ["adapters", "ports", "domain", "application"],
        "files": ["port.py", "adapter.py"],
    },
    ArchitecturalPattern.CLEAN: {
        "directories": ["entities", "use_cases", "interfaces", "frameworks"],
        "files": ["use_case.py", "interactor.py"],
    },
    ArchitecturalPattern.MICROSERVICES: {
        "directories": ["services", "api-gateway"],
        "files": ["docker-compose.yml", "kubernetes"],
    },
    ArchitecturalPattern.EVENT_DRIVEN: {
        "imports": ["kafka", "rabbitmq", "celery", "dramatiq"],
        "files": ["events.py", "handlers.py", "subscribers.py"],
    },
    ArchitecturalPattern.CQRS: {
        "directories": ["commands", "queries"],
        "files": ["command.py", "query.py", "command_handler.py"],
    },
}

DESIGN_PATTERN_SIGNATURES = {
    DesignPattern.SINGLETON: {
        "code_patterns": ["_instance", "__new__", "getInstance"],
        "class_patterns": ["Singleton", "single_instance"],
    },
    DesignPattern.FACTORY: {
        "code_patterns": ["create_", "make_", "build_"],
        "class_patterns": ["Factory", "Creator", "Builder"],
    },
    DesignPattern.REPOSITORY: {
        "class_patterns": ["Repository", "Repo"],
        "method_patterns": ["find", "save", "delete", "get_by_id"],
    },
    DesignPattern.STRATEGY: {
        "code_patterns": ["strategy", "algorithm"],
        "class_patterns": ["Strategy", "Policy"],
    },
    DesignPattern.OBSERVER: {
        "code_patterns": ["subscribe", "notify", "observer", "listener"],
        "class_patterns": ["Observer", "Listener", "Subscriber"],
    },
    DesignPattern.DEPENDENCY_INJECTION: {
        "code_patterns": ["inject", "container", "provider"],
        "imports": ["dependency_injector", "inject", "punq"],
    },
}

PATTERN_DESCRIPTIONS = {
    ArchitecturalPattern.MVC: "Model-View-Controller separates data, presentation, and control logic",
    ArchitecturalPattern.LAYERED: "Layered architecture with distinct presentation, business, and data layers",
    ArchitecturalPattern.HEXAGONAL: "Hexagonal/Ports & Adapters isolates core domain from external systems",
    ArchitecturalPattern.CLEAN: "Clean Architecture with entities, use cases, and interface adapters",
    ArchitecturalPattern.MICROSERVICES: "Microservices with independent, loosely-coupled services",
    ArchitecturalPattern.EVENT_DRIVEN: "Event-driven architecture using message queues and handlers",
    ArchitecturalPattern.CQRS: "Command Query Responsibility Segregation separates reads from writes",
}


@tool(
    name="detect_architectural_patterns",
    description="Analyze repository structure to identify high-level architectural patterns like MVC, layered, hexagonal, microservices, etc.",
    input_schema={
        "type": "object",
        "properties": {
            "directory_structure": {
                "type": "array",
                "items": {"type": "string"},
                "description": "List of directory paths in the repository"
            },
            "file_list": {
                "type": "array",
                "items": {"type": "string"},
                "description": "List of file paths in the repository"
            },
            "imports_found": {
                "type": "array",
                "items": {"type": "string"},
                "description": "List of import statements found in codebase"
            }
        },
        "required": ["directory_structure", "file_list"]
    }
)
async def detect_architectural_patterns(args: dict) -> dict:
    """Detect architectural patterns from repository structure."""
    directory_structure = args.get("directory_structure", [])
    file_list = args.get("file_list", [])
    imports_found = args.get("imports_found", [])

    detected_patterns: list[PatternMatch] = []

    # Normalize inputs
    dirs_lower = [d.lower() for d in directory_structure]
    files_lower = [f.lower() for f in file_list]
    imports_lower = [i.lower() for i in imports_found]

    for pattern, indicators in ARCHITECTURAL_INDICATORS.items():
        evidence = []
        confidence = 0.0
        locations = []

        # Check directories
        if "directories" in indicators:
            for dir_pattern in indicators["directories"]:
                matches = [d for d in dirs_lower if dir_pattern in d]
                if matches:
                    evidence.append(f"Directory pattern '{dir_pattern}' found")
                    locations.extend(matches[:3])
                    confidence += 0.3 / len(indicators["directories"])

        # Check files
        if "files" in indicators:
            for file_pattern in indicators["files"]:
                matches = [f for f in files_lower if file_pattern in f]
                if matches:
                    evidence.append(f"File pattern '{file_pattern}' found")
                    locations.extend(matches[:3])
                    confidence += 0.3 / len(indicators["files"])

        # Check imports
        if "imports" in indicators:
            for import_pattern in indicators["imports"]:
                if any(import_pattern in imp for imp in imports_lower):
                    evidence.append(f"Import '{import_pattern}' suggests pattern")
                    confidence += 0.2 / len(indicators["imports"])

        # Only include if confidence is meaningful
        if confidence >= 0.2 and evidence:
            detected_patterns.append(PatternMatch(
                pattern_type="architectural",
                pattern_name=pattern.value,
                confidence=min(confidence, 1.0),
                evidence=evidence,
                locations=locations[:5],
                description=PATTERN_DESCRIPTIONS.get(pattern, ""),
            ))

    # Sort by confidence
    detected_patterns.sort(key=lambda x: x.confidence, reverse=True)

    result = {
        "patterns": [p.to_dict() for p in detected_patterns],
        "primary_pattern": detected_patterns[0].to_dict() if detected_patterns else None,
        "pattern_count": len(detected_patterns),
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


@tool(
    name="detect_design_patterns",
    description="Analyze code structure to identify design patterns like Factory, Singleton, Repository, Observer, Strategy, etc.",
    input_schema={
        "type": "object",
        "properties": {
            "class_definitions": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "name": {"type": "string"},
                        "methods": {"type": "array", "items": {"type": "string"}},
                        "bases": {"type": "array", "items": {"type": "string"}}
                    }
                },
                "description": "List of class info dicts with name, methods, bases"
            },
            "function_definitions": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "name": {"type": "string"},
                        "decorators": {"type": "array", "items": {"type": "string"}}
                    }
                },
                "description": "List of function info dicts with name and decorators"
            },
            "code_snippets": {
                "type": "array",
                "items": {"type": "string"},
                "description": "List of code snippets to analyze for patterns"
            }
        },
        "required": ["class_definitions"]
    }
)
async def detect_design_patterns(args: dict) -> dict:
    """Detect design patterns from code structure."""
    class_definitions = args.get("class_definitions", [])
    function_definitions = args.get("function_definitions", [])
    code_snippets = args.get("code_snippets", [])

    detected_patterns: list[PatternMatch] = []

    class_names = [c.get("name", "").lower() for c in class_definitions]
    method_names = []
    for cls in class_definitions:
        method_names.extend([m.lower() for m in cls.get("methods", [])])

    func_names = [f.get("name", "").lower() for f in function_definitions]
    all_code = " ".join(code_snippets).lower()

    design_descriptions = {
        DesignPattern.SINGLETON: "Singleton ensures only one instance exists globally",
        DesignPattern.FACTORY: "Factory creates objects without specifying exact class",
        DesignPattern.REPOSITORY: "Repository abstracts data persistence behind collection-like interface",
        DesignPattern.STRATEGY: "Strategy defines family of interchangeable algorithms",
        DesignPattern.OBSERVER: "Observer notifies dependents of state changes",
        DesignPattern.DEPENDENCY_INJECTION: "Dependency Injection provides dependencies externally",
    }

    for pattern, signatures in DESIGN_PATTERN_SIGNATURES.items():
        evidence = []
        confidence = 0.0
        locations = []

        # Check class name patterns
        if "class_patterns" in signatures:
            for class_pattern in signatures["class_patterns"]:
                matches = [c for c in class_names if class_pattern.lower() in c]
                if matches:
                    evidence.append(f"Class naming suggests {pattern.value}")
                    locations.extend(matches[:3])
                    confidence += 0.35 / len(signatures["class_patterns"])

        # Check method patterns
        if "method_patterns" in signatures:
            for method_pattern in signatures["method_patterns"]:
                if any(method_pattern in m for m in method_names + func_names):
                    evidence.append(f"Method '{method_pattern}' indicates pattern")
                    confidence += 0.25 / len(signatures["method_patterns"])

        # Check code patterns
        if "code_patterns" in signatures:
            for code_pattern in signatures["code_patterns"]:
                if code_pattern.lower() in all_code:
                    evidence.append(f"Code contains '{code_pattern}'")
                    confidence += 0.2 / len(signatures["code_patterns"])

        if confidence >= 0.2 and evidence:
            detected_patterns.append(PatternMatch(
                pattern_type="design",
                pattern_name=pattern.value,
                confidence=min(confidence, 1.0),
                evidence=evidence,
                locations=locations[:5],
                description=design_descriptions.get(pattern, ""),
            ))

    detected_patterns.sort(key=lambda x: x.confidence, reverse=True)

    result = {
        "patterns": [p.to_dict() for p in detected_patterns],
        "pattern_count": len(detected_patterns),
        "top_patterns": [p.pattern_name for p in detected_patterns[:5]],
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


@tool(
    name="detect_framework_patterns",
    description="Identify framework-specific patterns and conventions (FastAPI, Django, React, Next.js, Express) based on dependencies and code structure.",
    input_schema={
        "type": "object",
        "properties": {
            "dependencies": {
                "type": "array",
                "items": {"type": "string"},
                "description": "List of project dependencies/packages"
            },
            "file_structure": {
                "type": "array",
                "items": {"type": "string"},
                "description": "List of file paths"
            },
            "config_files": {
                "type": "array",
                "items": {"type": "string"},
                "description": "List of configuration file names"
            }
        },
        "required": ["dependencies", "file_structure"]
    }
)
async def detect_framework_patterns(args: dict) -> dict:
    """Detect framework-specific patterns."""
    dependencies = args.get("dependencies", [])
    file_structure = args.get("file_structure", [])
    config_files = args.get("config_files", [])

    patterns: list[PatternMatch] = []
    deps_lower = [d.lower() for d in dependencies]
    files_lower = [f.lower() for f in file_structure]

    # FastAPI patterns
    if "fastapi" in deps_lower:
        evidence = ["FastAPI dependency detected"]
        if any("routers" in f or "routes" in f for f in files_lower):
            evidence.append("Router-based organization")
        if any("schemas" in f or "models" in f for f in files_lower):
            evidence.append("Pydantic schema separation")
        patterns.append(PatternMatch(
            pattern_type="framework",
            pattern_name="fastapi_standard",
            confidence=0.8,
            evidence=evidence,
            description="FastAPI with routers and Pydantic schemas",
        ))

    # Django patterns
    if "django" in deps_lower:
        evidence = ["Django framework detected"]
        if any("apps.py" in f for f in files_lower):
            evidence.append("Django app structure")
        if any("admin.py" in f for f in files_lower):
            evidence.append("Django admin integration")
        patterns.append(PatternMatch(
            pattern_type="framework",
            pattern_name="django_standard",
            confidence=0.85,
            evidence=evidence,
            description="Standard Django project structure",
        ))

    # React patterns
    if "react" in deps_lower or any("jsx" in f or "tsx" in f for f in files_lower):
        evidence = ["React framework detected"]
        if any("components" in f for f in files_lower):
            evidence.append("Component-based architecture")
        if any("hooks" in f for f in files_lower):
            evidence.append("Custom hooks pattern")
        patterns.append(PatternMatch(
            pattern_type="framework",
            pattern_name="react_component",
            confidence=0.75,
            evidence=evidence,
            description="React component-based architecture",
        ))

    # Next.js patterns
    if "next" in deps_lower:
        evidence = ["Next.js framework detected"]
        if any("app/" in f or "pages/" in f for f in files_lower):
            evidence.append("File-based routing")
        if any("api/" in f for f in files_lower):
            evidence.append("API routes")
        patterns.append(PatternMatch(
            pattern_type="framework",
            pattern_name="nextjs_app",
            confidence=0.8,
            evidence=evidence,
            description="Next.js with App Router or Pages Router",
        ))

    # Express patterns
    if "express" in deps_lower:
        evidence = ["Express.js detected"]
        if any("middleware" in f for f in files_lower):
            evidence.append("Middleware architecture")
        if any("routes" in f for f in files_lower):
            evidence.append("Route separation")
        patterns.append(PatternMatch(
            pattern_type="framework",
            pattern_name="express_mvc",
            confidence=0.7,
            evidence=evidence,
            description="Express.js MVC-style pattern",
        ))

    result = {
        "patterns": [p.to_dict() for p in patterns],
        "frameworks_detected": [p.pattern_name for p in patterns],
        "pattern_count": len(patterns),
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


@tool(
    name="analyze_pattern_confidence",
    description="Analyze and explain confidence levels for detected patterns, providing reasoning for each score.",
    input_schema={
        "type": "object",
        "properties": {
            "patterns": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "pattern_name": {"type": "string"},
                        "confidence": {"type": "number"},
                        "evidence": {"type": "array", "items": {"type": "string"}}
                    }
                },
                "description": "List of detected patterns with confidence scores"
            }
        },
        "required": ["patterns"]
    }
)
async def analyze_pattern_confidence(args: dict) -> dict:
    """Analyze and explain confidence levels for patterns."""
    patterns = args.get("patterns", [])

    analysis = []
    for pattern in patterns:
        name = pattern.get("pattern_name", "unknown")
        confidence = pattern.get("confidence", 0)
        evidence = pattern.get("evidence", [])

        # Determine confidence level description
        if confidence >= 0.8:
            level = "HIGH"
            explanation = "Strong evidence from multiple indicators"
        elif confidence >= 0.5:
            level = "MEDIUM"
            explanation = "Reasonable evidence but some uncertainty"
        else:
            level = "LOW"
            explanation = "Suggestive evidence but inconclusive"

        analysis.append({
            "pattern": name,
            "confidence": confidence,
            "level": level,
            "explanation": explanation,
            "evidence_count": len(evidence),
            "recommendation": "Include in narrative" if confidence >= 0.5 else "Mention with caution",
        })

    result = {
        "analysis": analysis,
        "high_confidence_patterns": [a["pattern"] for a in analysis if a["level"] == "HIGH"],
        "total_analyzed": len(analysis),
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}
```

### Task 2: Create Pattern Tools MCP Server

**File**: `src/codestory/tools/patterns_server.py`

```python
"""MCP server for pattern recognition tools."""

from claude_agent_sdk import create_sdk_mcp_server

from codestory.tools.patterns import (
    detect_architectural_patterns,
    detect_design_patterns,
    detect_framework_patterns,
    analyze_pattern_confidence,
)


def create_pattern_mcp_server():
    """Create MCP server with pattern recognition tools."""
    return create_sdk_mcp_server(
        name="pattern-analyzer",
        version="1.0.0",
        tools=[
            detect_architectural_patterns,
            detect_design_patterns,
            detect_framework_patterns,
            analyze_pattern_confidence,
        ],
    )
```

### Task 3: Create Pattern Tools Tests

**File**: `tests/tools/test_patterns.py`

```python
"""Tests for pattern recognition tools."""

import pytest
import json

from codestory.tools.patterns import (
    detect_architectural_patterns,
    detect_design_patterns,
    detect_framework_patterns,
    analyze_pattern_confidence,
)


@pytest.mark.asyncio
async def test_detect_architectural_patterns_mvc():
    """Test MVC pattern detection."""
    result = await detect_architectural_patterns({
        "directory_structure": ["src/models", "src/views", "src/controllers"],
        "file_list": ["controller.py", "model.py", "view.py"],
        "imports_found": ["flask"],
    })

    content = json.loads(result["content"][0]["text"])
    assert content["pattern_count"] >= 1
    assert any(p["pattern_name"] == "mvc" for p in content["patterns"])


@pytest.mark.asyncio
async def test_detect_architectural_patterns_layered():
    """Test layered architecture detection."""
    result = await detect_architectural_patterns({
        "directory_structure": ["domain", "infrastructure", "presentation"],
        "file_list": ["service.py", "repository.py"],
        "imports_found": [],
    })

    content = json.loads(result["content"][0]["text"])
    assert content["pattern_count"] >= 1


@pytest.mark.asyncio
async def test_detect_design_patterns_repository():
    """Test Repository pattern detection."""
    result = await detect_design_patterns({
        "class_definitions": [
            {"name": "UserRepository", "methods": ["find", "save", "delete"], "bases": []},
        ],
        "function_definitions": [],
        "code_snippets": [],
    })

    content = json.loads(result["content"][0]["text"])
    assert content["pattern_count"] >= 1
    assert any(p["pattern_name"] == "repository" for p in content["patterns"])


@pytest.mark.asyncio
async def test_detect_design_patterns_factory():
    """Test Factory pattern detection."""
    result = await detect_design_patterns({
        "class_definitions": [
            {"name": "ConnectionFactory", "methods": ["create_connection"], "bases": []},
        ],
        "function_definitions": [{"name": "create_user", "decorators": []}],
        "code_snippets": [],
    })

    content = json.loads(result["content"][0]["text"])
    assert content["pattern_count"] >= 1


@pytest.mark.asyncio
async def test_detect_framework_patterns_fastapi():
    """Test FastAPI pattern detection."""
    result = await detect_framework_patterns({
        "dependencies": ["fastapi", "pydantic", "uvicorn"],
        "file_structure": ["api/routers/users.py", "schemas/user.py"],
        "config_files": [],
    })

    content = json.loads(result["content"][0]["text"])
    assert "fastapi_standard" in content["frameworks_detected"]


@pytest.mark.asyncio
async def test_detect_framework_patterns_react():
    """Test React pattern detection."""
    result = await detect_framework_patterns({
        "dependencies": ["react", "react-dom"],
        "file_structure": ["src/components/Button.tsx", "src/hooks/useAuth.ts"],
        "config_files": [],
    })

    content = json.loads(result["content"][0]["text"])
    assert "react_component" in content["frameworks_detected"]


@pytest.mark.asyncio
async def test_analyze_pattern_confidence():
    """Test confidence analysis."""
    result = await analyze_pattern_confidence({
        "patterns": [
            {"pattern_name": "mvc", "confidence": 0.85, "evidence": ["dir", "file", "import"]},
            {"pattern_name": "singleton", "confidence": 0.3, "evidence": ["code"]},
        ]
    })

    content = json.loads(result["content"][0]["text"])
    assert len(content["analysis"]) == 2
    assert content["analysis"][0]["level"] == "HIGH"
    assert content["analysis"][1]["level"] == "LOW"


@pytest.mark.asyncio
async def test_no_patterns_detected():
    """Test when no patterns are found."""
    result = await detect_architectural_patterns({
        "directory_structure": ["random", "stuff"],
        "file_list": ["file.txt"],
        "imports_found": [],
    })

    content = json.loads(result["content"][0]["text"])
    assert content["pattern_count"] == 0
    assert content["primary_pattern"] is None
```

## Files Created/Modified

| File | Action | Purpose |
|------|--------|---------|
| `src/codestory/tools/patterns.py` | Create | Pattern detection tools with @tool decorators |
| `src/codestory/tools/patterns_server.py` | Create | MCP server for pattern tools |
| `tests/tools/test_patterns.py` | Create | Pattern tool tests |

## Validation Criteria

1. All @tool decorated functions return proper `{"content": [{"type": "text", "text": "..."}]}` format
2. detect_architectural_patterns identifies MVC from Flask/Django repos
3. detect_design_patterns finds Repository pattern from class names
4. detect_framework_patterns correctly identifies FastAPI, Django, React
5. Confidence scores are between 0.0 and 1.0
6. Evidence lists contain meaningful descriptions
7. All tests pass

## Tool Naming

When integrated with MCP server, tools are accessed as:
- `mcp__pattern-analyzer__detect_architectural_patterns`
- `mcp__pattern-analyzer__detect_design_patterns`
- `mcp__pattern-analyzer__detect_framework_patterns`
- `mcp__pattern-analyzer__analyze_pattern_confidence`

## Notes

- Pattern detection is heuristic-based (no ML required)
- Confidence thresholds tuned to minimize false positives
- Framework patterns help Story Architect tailor narratives
- All tools are async and stateless
