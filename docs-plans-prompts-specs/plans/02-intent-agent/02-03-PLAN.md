---
phase: 02-intent-agent
type: execute
domain: claude-agent-sdk
---

# Phase 2 Plan 03: Story Plan Data Structures

## Objective

Define data structures for story plans that flow between agents in the pipeline.

**Purpose**: Create standardized data models for story plans with chapters and timing.
**Output**: Pydantic models for StoryPlan, ChapterOutline, and UserIntent.

## Context

- @BRIEF.md
- @plans/02-intent-agent/02-01-SUMMARY.md
- @plans/02-intent-agent/02-02-SUMMARY.md

## Tasks

### Task 1: Create Story Plan Data Models

**File**: `src/codestory/agents/intent/models.py`

```python
"""Data models for story plans and user intent."""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any


class IntentCategory(str, Enum):
    """Categories of user learning intent."""
    ONBOARDING = "onboarding"
    ARCHITECTURE = "architecture"
    FEATURE = "feature"
    DEBUGGING = "debugging"
    REVIEW = "review"
    DOCUMENTATION = "documentation"


class ExpertiseLevel(str, Enum):
    """User expertise levels."""
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    EXPERT = "expert"


class NarrativeStyle(str, Enum):
    """Narrative styles for story generation."""
    FICTION = "fiction"
    DOCUMENTARY = "documentary"
    TUTORIAL = "tutorial"
    PODCAST = "podcast"
    TECHNICAL = "technical"


@dataclass
class ChapterOutline:
    """Outline for a single chapter in the story."""
    number: int
    title: str
    focus: str
    duration_minutes: float
    key_concepts: list[str] = field(default_factory=list)
    code_elements: list[str] = field(default_factory=list)
    
    def to_dict(self) -> dict[str, Any]:
        return {
            "number": self.number,
            "title": self.title,
            "focus": self.focus,
            "duration_minutes": self.duration_minutes,
            "key_concepts": self.key_concepts,
            "code_elements": self.code_elements,
        }
    
    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "ChapterOutline":
        return cls(
            number=data["number"],
            title=data["title"],
            focus=data["focus"],
            duration_minutes=data["duration_minutes"],
            key_concepts=data.get("key_concepts", []),
            code_elements=data.get("code_elements", []),
        )


@dataclass
class UserIntent:
    """Structured representation of user intent."""
    category: IntentCategory
    expertise_level: ExpertiseLevel
    focus_areas: list[str] = field(default_factory=list)
    learning_goals: str = ""
    preferred_style: NarrativeStyle = NarrativeStyle.DOCUMENTARY
    time_preference_minutes: int = 15
    specific_questions: list[str] = field(default_factory=list)
    
    def to_dict(self) -> dict[str, Any]:
        return {
            "category": self.category.value,
            "expertise_level": self.expertise_level.value,
            "focus_areas": self.focus_areas,
            "learning_goals": self.learning_goals,
            "preferred_style": self.preferred_style.value,
            "time_preference_minutes": self.time_preference_minutes,
            "specific_questions": self.specific_questions,
        }
    
    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "UserIntent":
        return cls(
            category=IntentCategory(data["category"]),
            expertise_level=ExpertiseLevel(data["expertise_level"]),
            focus_areas=data.get("focus_areas", []),
            learning_goals=data.get("learning_goals", ""),
            preferred_style=NarrativeStyle(data.get("preferred_style", "documentary")),
            time_preference_minutes=data.get("time_preference_minutes", 15),
            specific_questions=data.get("specific_questions", []),
        )


@dataclass
class StoryPlan:
    """Complete story plan generated from user intent."""
    title: str
    description: str
    narrative_style: NarrativeStyle
    total_duration_minutes: float
    expertise_level: ExpertiseLevel
    intent_category: IntentCategory
    chapters: list[ChapterOutline] = field(default_factory=list)
    learning_objectives: list[str] = field(default_factory=list)
    prerequisites: list[str] = field(default_factory=list)
    repo_url: str = ""
    created_at: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    
    def to_dict(self) -> dict[str, Any]:
        return {
            "title": self.title,
            "description": self.description,
            "narrative_style": self.narrative_style.value,
            "total_duration_minutes": self.total_duration_minutes,
            "expertise_level": self.expertise_level.value,
            "intent_category": self.intent_category.value,
            "chapters": [c.to_dict() for c in self.chapters],
            "learning_objectives": self.learning_objectives,
            "prerequisites": self.prerequisites,
            "repo_url": self.repo_url,
            "created_at": self.created_at,
        }
    
    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "StoryPlan":
        return cls(
            title=data["title"],
            description=data["description"],
            narrative_style=NarrativeStyle(data["narrative_style"]),
            total_duration_minutes=data["total_duration_minutes"],
            expertise_level=ExpertiseLevel(data["expertise_level"]),
            intent_category=IntentCategory(data["intent_category"]),
            chapters=[ChapterOutline.from_dict(c) for c in data.get("chapters", [])],
            learning_objectives=data.get("learning_objectives", []),
            prerequisites=data.get("prerequisites", []),
            repo_url=data.get("repo_url", ""),
            created_at=data.get("created_at", datetime.utcnow().isoformat()),
        )
    
    def get_chapter(self, number: int) -> ChapterOutline | None:
        """Get a chapter by number."""
        for chapter in self.chapters:
            if chapter.number == number:
                return chapter
        return None
    
    def calculate_total_duration(self) -> float:
        """Recalculate total duration from chapters."""
        return sum(c.duration_minutes for c in self.chapters)


@dataclass
class ConversationState:
    """Tracks the state of an intent conversation."""
    turn_count: int = 0
    has_stated_goal: bool = False
    has_background: bool = False
    has_focus_areas: bool = False
    has_time_preference: bool = False
    stated_goal: str = ""
    technical_background: str = ""
    focus_areas: list[str] = field(default_factory=list)
    time_preference_minutes: int = 15
    preferred_style: str = "documentary"
    expertise_level: str = "intermediate"
    
    def update_from_message(self, message: str) -> None:
        """Update state based on user message content."""
        self.turn_count += 1
        message_lower = message.lower()
        
        # Detect goal statements
        goal_indicators = ["want to", "trying to", "need to", "learn about", "understand"]
        if any(ind in message_lower for ind in goal_indicators):
            self.has_stated_goal = True
            self.stated_goal = message
        
        # Detect background
        bg_indicators = ["experience", "worked with", "familiar", "new to", "years"]
        if any(ind in message_lower for ind in bg_indicators):
            self.has_background = True
            self.technical_background = message
        
        # Detect focus areas
        if any(ind in message_lower for ind in ["interested in", "focus on", "specifically"]):
            self.has_focus_areas = True
        
        # Detect time preferences
        if any(ind in message_lower for ind in ["minutes", "quick", "detailed"]):
            self.has_time_preference = True
            import re
            match = re.search(r'(\d+)\s*min', message_lower)
            if match:
                self.time_preference_minutes = int(match.group(1))
    
    def is_complete(self) -> bool:
        """Check if enough information has been gathered."""
        return self.has_stated_goal and self.has_background
    
    def completeness_score(self) -> float:
        """Calculate how complete the conversation is."""
        factors = [
            self.has_stated_goal,
            self.has_background,
            self.has_focus_areas,
            self.has_time_preference,
        ]
        return sum(factors) / len(factors)
    
    def to_dict(self) -> dict[str, Any]:
        return {
            "turn_count": self.turn_count,
            "has_stated_goal": self.has_stated_goal,
            "has_background": self.has_background,
            "has_focus_areas": self.has_focus_areas,
            "has_time_preference": self.has_time_preference,
            "stated_goal": self.stated_goal,
            "expertise_level": self.expertise_level,
            "completeness": self.completeness_score(),
            "ready_for_plan": self.is_complete(),
        }
```

### Task 2: Add Model Validation Tool

**File**: `src/codestory/agents/intent/tools.py` (append)

```python
from .models import StoryPlan, ChapterOutline, UserIntent, IntentCategory, ExpertiseLevel, NarrativeStyle


@tool(
    name="validate_story_plan",
    description="Validate a story plan structure before passing to next agent",
    input_schema={
        "type": "object",
        "properties": {
            "plan": {
                "type": "object",
                "description": "Story plan to validate"
            }
        },
        "required": ["plan"]
    }
)
async def validate_story_plan(args: dict) -> dict:
    """Validate story plan has required fields and valid values."""
    plan_data = args["plan"]
    errors = []
    warnings = []
    
    # Required fields
    required = ["title", "narrative_style", "chapters", "repo_url"]
    for field in required:
        if field not in plan_data:
            errors.append(f"Missing required field: {field}")
    
    # Validate narrative style
    if "narrative_style" in plan_data:
        try:
            NarrativeStyle(plan_data["narrative_style"])
        except ValueError:
            errors.append(f"Invalid narrative style: {plan_data['narrative_style']}")
    
    # Validate chapters
    chapters = plan_data.get("chapters", [])
    if len(chapters) == 0:
        errors.append("Story must have at least one chapter")
    
    for i, ch in enumerate(chapters):
        if "title" not in ch:
            errors.append(f"Chapter {i+1} missing title")
        if "duration_minutes" not in ch:
            warnings.append(f"Chapter {i+1} missing duration")
    
    # Calculate total duration
    total_duration = sum(ch.get("duration_minutes", 0) for ch in chapters)
    if total_duration > 60:
        warnings.append(f"Story is {total_duration} minutes - consider shortening")
    elif total_duration < 5:
        warnings.append(f"Story is only {total_duration} minutes - consider expanding")
    
    is_valid = len(errors) == 0
    
    result = {
        "valid": is_valid,
        "errors": errors,
        "warnings": warnings,
        "chapter_count": len(chapters),
        "total_duration_minutes": total_duration,
    }
    
    return {"content": [{"type": "text", "text": str(result)}]}
```

### Task 3: Update Package Exports

**File**: `src/codestory/agents/intent/__init__.py` (update)

```python
"""Intent Agent package using Claude Agent SDK."""

from .tools import (
    analyze_user_intent,
    generate_story_plan,
    suggest_follow_up_questions,
    track_conversation_state,
    summarize_intent,
    validate_story_plan,
    INTENT_CATEGORIES,
    EXPERTISE_LEVELS,
    NARRATIVE_STYLES,
)
from .agent import (
    IntentAgent,
    intent_mcp_server,
    create_intent_agent_options,
    INTENT_AGENT_PROMPT,
)
from .models import (
    IntentCategory,
    ExpertiseLevel,
    NarrativeStyle,
    ChapterOutline,
    UserIntent,
    StoryPlan,
    ConversationState,
)

__all__ = [
    # Tools
    "analyze_user_intent",
    "generate_story_plan",
    "suggest_follow_up_questions",
    "track_conversation_state",
    "summarize_intent",
    "validate_story_plan",
    # Constants
    "INTENT_CATEGORIES",
    "EXPERTISE_LEVELS",
    "NARRATIVE_STYLES",
    # Agent
    "IntentAgent",
    "intent_mcp_server",
    "create_intent_agent_options",
    "INTENT_AGENT_PROMPT",
    # Models
    "IntentCategory",
    "ExpertiseLevel",
    "NarrativeStyle",
    "ChapterOutline",
    "UserIntent",
    "StoryPlan",
    "ConversationState",
]
```

## Verification

```bash
uv run python -c "from codestory.agents.intent import StoryPlan, ChapterOutline, UserIntent; print('Models OK')"
```

## Success Criteria

- StoryPlan, ChapterOutline, UserIntent models defined
- Models have to_dict and from_dict methods for serialization
- ConversationState tracks conversation progress
- validate_story_plan tool checks plan validity

## Next Step

Proceed to 02-04-PLAN.md for complete Intent Agent integration.
