---
phase: 02-intent-agent
type: execute
domain: claude-agent-sdk
---

# Phase 2 Plan 01: Intent Agent Core Setup

## Objective

Create the Intent Agent using Claude Agent SDK patterns with AgentDefinition and @tool decorators.

**Purpose**: The Intent Agent conducts onboarding conversations to understand user learning goals.
**Output**: Working Intent Agent with MCP server, tools, and AgentDefinition configuration.

## Context

- @BRIEF.md
- @ROADMAP.md
- @plans/01-foundation/01-03-SUMMARY.md

## Claude Agent SDK Pattern

The Intent Agent uses the SDK pattern:
1. Define tools with `@tool` decorator
2. Create MCP server with `create_sdk_mcp_server`
3. Configure agent with `AgentDefinition`

## Tasks

### Task 1: Create Intent Agent Tools

**File**: `src/codestory/agents/intent/tools.py`

```python
"""Intent Agent tools using Claude Agent SDK @tool decorator."""

from claude_agent_sdk import tool

# Intent categories for classification
INTENT_CATEGORIES = [
    "onboarding",      # New to codebase, want general overview
    "architecture",    # Understanding system design and patterns
    "feature",         # Deep dive into specific functionality
    "debugging",       # Understanding code flow for troubleshooting
    "review",          # Preparing to review or contribute code
    "documentation",   # Creating or improving documentation
]

EXPERTISE_LEVELS = ["beginner", "intermediate", "expert"]

NARRATIVE_STYLES = [
    "fiction",         # Story-driven with characters and plot
    "documentary",     # Informative, like a documentary film
    "tutorial",        # Step-by-step instructional
    "podcast",         # Conversational, discussion-style
    "technical",       # Precise, reference-style
]


@tool(
    name="analyze_user_intent",
    description="Analyze conversation to categorize user's learning intent and expertise level",
    input_schema={
        "type": "object",
        "properties": {
            "conversation_summary": {
                "type": "string",
                "description": "Summary of the conversation so far"
            },
            "stated_goal": {
                "type": "string",
                "description": "User's explicitly stated goal"
            },
            "technical_background": {
                "type": "string",
                "description": "Description of user's technical background"
            },
            "specific_interests": {
                "type": "string",
                "description": "Specific areas or features user mentioned"
            }
        },
        "required": ["conversation_summary", "stated_goal"]
    }
)
async def analyze_user_intent(args: dict) -> dict:
    """Analyze user responses to determine intent category and expertise."""
    conversation = args.get("conversation_summary", "").lower()
    goal = args.get("stated_goal", "").lower()
    background = args.get("technical_background", "").lower()
    interests = args.get("specific_interests", "")
    
    # Categorize goal
    category = _categorize_goal(goal, conversation)
    expertise = _assess_expertise(background)
    focus_areas = _extract_focus_areas(interests)
    style = _recommend_style(category, expertise)
    duration = _estimate_duration(category, len(focus_areas))
    
    result = {
        "category": category,
        "expertise_level": expertise,
        "focus_areas": focus_areas,
        "recommended_style": style,
        "recommended_duration_minutes": duration,
        "confidence": _calculate_confidence(goal, background, interests),
        "needs_clarification": _needs_clarification(goal, background),
    }
    
    return {"content": [{"type": "text", "text": str(result)}]}


@tool(
    name="generate_story_plan",
    description="Generate a structured story plan with chapters, timing, and focus areas",
    input_schema={
        "type": "object",
        "properties": {
            "repo_url": {"type": "string", "description": "GitHub repository URL"},
            "intent_category": {"type": "string", "description": "User's learning intent category"},
            "expertise_level": {"type": "string", "description": "User's technical expertise level"},
            "narrative_style": {"type": "string", "description": "Chosen narrative style"},
            "focus_areas": {
                "type": "array",
                "items": {"type": "string"},
                "description": "List of specific areas to cover"
            },
            "learning_goals": {"type": "string", "description": "User's stated learning objectives"},
            "target_duration_minutes": {
                "type": "integer",
                "default": 15,
                "description": "Target story duration"
            }
        },
        "required": ["repo_url", "intent_category", "expertise_level", "narrative_style"]
    }
)
async def generate_story_plan(args: dict) -> dict:
    """Generate a complete story plan from analyzed intent."""
    repo_url = args["repo_url"]
    category = args["intent_category"]
    expertise = args["expertise_level"]
    style = args["narrative_style"]
    focus_areas = args.get("focus_areas", [])
    goals = args.get("learning_goals", "")
    duration = args.get("target_duration_minutes", 15)
    
    # Validate inputs
    if category not in INTENT_CATEGORIES:
        category = "onboarding"
    if expertise not in EXPERTISE_LEVELS:
        expertise = "intermediate"
    if style not in NARRATIVE_STYLES:
        style = "documentary"
    
    # Generate title and chapters
    title = _generate_title(repo_url, category, style)
    chapters = _create_chapter_outlines(category, expertise, focus_areas, duration, style)
    objectives = _generate_objectives(category, focus_areas, goals)
    prerequisites = _determine_prerequisites(expertise, category)
    
    plan = {
        "title": title,
        "description": _generate_description(category, focus_areas),
        "narrative_style": style,
        "total_duration_minutes": sum(c["duration_minutes"] for c in chapters),
        "expertise_level": expertise,
        "intent_category": category,
        "chapters": chapters,
        "learning_objectives": objectives,
        "prerequisites": prerequisites,
        "repo_url": repo_url,
    }
    
    return {"content": [{"type": "text", "text": str(plan)}]}


@tool(
    name="suggest_follow_up_questions",
    description="Generate contextual follow-up questions based on conversation progress",
    input_schema={
        "type": "object",
        "properties": {
            "has_stated_goal": {"type": "boolean"},
            "has_background": {"type": "boolean"},
            "has_focus_areas": {"type": "boolean"},
            "has_time_preference": {"type": "boolean"},
            "conversation_turn": {"type": "integer"},
            "last_response_topic": {"type": "string", "default": ""}
        },
        "required": ["has_stated_goal", "has_background", "conversation_turn"]
    }
)
async def suggest_follow_up_questions(args: dict) -> dict:
    """Generate appropriate follow-up questions based on what's missing."""
    has_goal = args["has_stated_goal"]
    has_bg = args["has_background"]
    has_focus = args.get("has_focus_areas", False)
    has_time = args.get("has_time_preference", False)
    turn = args["conversation_turn"]
    
    questions = []
    priority = "high"
    ready = False
    
    if turn <= 2:
        if not has_goal:
            questions.append({
                "question": "What would you like to learn about this codebase?",
                "purpose": "Understand primary learning goal",
            })
        elif not has_bg:
            questions.append({
                "question": "How familiar are you with this type of project?",
                "purpose": "Gauge expertise level",
            })
    elif turn <= 4:
        if not has_focus and has_goal:
            questions.append({
                "question": "Are there specific parts you're most interested in?",
                "purpose": "Identify focus areas",
            })
            priority = "medium"
    else:
        if has_goal and has_bg:
            ready = True
            questions.append({
                "question": "Should I create your story plan now?",
                "purpose": "Confirm readiness",
            })
            priority = "confirmation"
    
    completeness = sum([has_goal, has_bg, has_focus, has_time]) / 4.0
    
    result = {
        "suggested_questions": questions,
        "priority": priority,
        "ready_to_generate_plan": ready,
        "completeness": completeness,
    }
    
    return {"content": [{"type": "text", "text": str(result)}]}


# Helper functions
def _categorize_goal(goal: str, summary: str) -> str:
    combined = (goal + " " + summary).lower()
    if any(kw in combined for kw in ["new to", "first time", "getting started"]):
        return "onboarding"
    elif any(kw in combined for kw in ["architecture", "design", "structure"]):
        return "architecture"
    elif any(kw in combined for kw in ["feature", "specific", "implement"]):
        return "feature"
    elif any(kw in combined for kw in ["debug", "bug", "issue"]):
        return "debugging"
    elif any(kw in combined for kw in ["review", "contribute", "pr"]):
        return "review"
    elif any(kw in combined for kw in ["document", "explain"]):
        return "documentation"
    return "onboarding"


def _assess_expertise(background: str) -> str:
    bg = background.lower()
    if any(kw in bg for kw in ["senior", "lead", "expert", "years"]):
        return "expert"
    elif any(kw in bg for kw in ["learning", "student", "new", "beginner"]):
        return "beginner"
    return "intermediate"


def _extract_focus_areas(interests: str) -> list:
    if not interests.strip():
        return []
    for delim in [",", ";", "and", "\n"]:
        if delim in interests:
            return [a.strip() for a in interests.split(delim) if a.strip()][:5]
    return [interests.strip()]


def _recommend_style(category: str, expertise: str) -> str:
    style_map = {
        ("onboarding", "beginner"): "fiction",
        ("onboarding", "intermediate"): "documentary",
        ("architecture", "expert"): "technical",
        ("feature", "intermediate"): "documentary",
        ("debugging", "expert"): "technical",
    }
    return style_map.get((category, expertise), "documentary")


def _estimate_duration(category: str, num_areas: int) -> int:
    base = {"onboarding": 15, "architecture": 20, "feature": 10, "debugging": 8}.get(category, 10)
    return min(base + min(num_areas * 3, 15), 30)


def _calculate_confidence(goal: str, background: str, interests: str) -> float:
    conf = 0.5
    if len(goal) > 20: conf += 0.15
    if len(background) > 20: conf += 0.15
    if len(interests) > 10: conf += 0.1
    return min(conf, 1.0)


def _needs_clarification(goal: str, background: str) -> list:
    needs = []
    if len(goal) < 10: needs.append("More detail about learning goals")
    if len(background) < 5: needs.append("Technical background")
    return needs


def _generate_title(repo_url: str, category: str, style: str) -> str:
    repo_name = repo_url.rstrip("/").split("/")[-1].replace("-", " ").title()
    prefixes = {"fiction": "The Tale of", "documentary": "Inside", "tutorial": "Learning"}
    return f"{prefixes.get(style, 'Exploring')} {repo_name}"


def _create_chapter_outlines(category: str, expertise: str, focus_areas: list, duration: int, style: str) -> list:
    templates = {
        "onboarding": [
            ("Introduction", "Overview and purpose"),
            ("Getting Started", "Setup and basic usage"),
            ("Core Concepts", "Key abstractions"),
            ("Project Structure", "Codebase organization"),
        ],
        "architecture": [
            ("System Overview", "High-level architecture"),
            ("Components", "Major system components"),
            ("Data Flow", "How data moves"),
            ("Design Decisions", "Key choices"),
        ],
    }
    base = templates.get(category, templates["onboarding"])
    time_per = duration / len(base)
    multiplier = {"beginner": 1.2, "intermediate": 1.0, "expert": 0.8}.get(expertise, 1.0)
    
    chapters = []
    for i, (title, focus) in enumerate(base, 1):
        chapters.append({
            "number": i,
            "title": title,
            "focus": focus,
            "duration_minutes": round(time_per * multiplier, 1),
        })
    return chapters


def _generate_objectives(category: str, focus_areas: list, goals: str) -> list:
    base = {
        "onboarding": ["Understand project purpose", "Navigate codebase"],
        "architecture": ["Explain system architecture", "Identify patterns"],
    }
    return base.get(category, ["Understand the codebase"])[:3]


def _determine_prerequisites(expertise: str, category: str) -> list:
    prereqs = {
        "beginner": ["Basic programming concepts"],
        "intermediate": ["Comfortable reading code"],
        "expert": [],
    }
    return prereqs.get(expertise, [])


def _generate_description(category: str, focus_areas: list) -> str:
    desc = {
        "onboarding": "A guided tour of the codebase for newcomers.",
        "architecture": "An exploration of the system's design.",
    }
    base = desc.get(category, "An exploration of the codebase.")
    if focus_areas:
        base += f" Focusing on: {', '.join(focus_areas[:3])}."
    return base
```

### Task 2: Create Intent Agent MCP Server and AgentDefinition

**File**: `src/codestory/agents/intent/agent.py`

```python
"""Intent Agent using Claude Agent SDK patterns."""

from claude_agent_sdk import (
    tool,
    create_sdk_mcp_server,
    ClaudeAgentOptions,
    ClaudeSDKClient,
    AgentDefinition,
)

from .tools import (
    analyze_user_intent,
    generate_story_plan,
    suggest_follow_up_questions,
)


# Intent Agent system prompt
INTENT_AGENT_PROMPT = """You are the Intent Agent for Code Story, an AI that helps users understand codebases through audio narratives.

Your role is to conduct a friendly, conversational onboarding to understand:
1. What the user wants to learn about the repository
2. Their technical background and expertise level
3. Specific components or features they're interested in
4. How they prefer to learn (high-level overview vs. deep dive)

## Conversation Guidelines

Start by warmly greeting the user and asking about their primary goal. Guide the conversation naturally:

- Ask one or two questions at a time, not a long list
- Acknowledge what the user shares before asking more
- Use their responses to tailor follow-up questions
- When you have enough information, summarize and confirm

## Tools Available

- analyze_user_intent: Categorize user's learning goals and expertise
- generate_story_plan: Create structured plan with chapters and timing
- suggest_follow_up_questions: Get appropriate questions based on progress

## Process

1. Greet user and ask primary goal
2. Understand their background with the codebase
3. Learn about their technical expertise
4. Identify specific interests or concerns
5. Use analyze_user_intent to structure findings
6. Use generate_story_plan to create the plan
7. Confirm understanding with user

Remember: Your goal is to create a personalized learning experience."""


# Create MCP server with intent tools
intent_mcp_server = create_sdk_mcp_server(
    name="intent",
    version="1.0.0",
    tools=[
        analyze_user_intent,
        generate_story_plan,
        suggest_follow_up_questions,
    ]
)


def create_intent_agent_options() -> ClaudeAgentOptions:
    """Create ClaudeAgentOptions with Intent Agent configuration."""
    return ClaudeAgentOptions(
        mcp_servers={"intent": intent_mcp_server},
        agents={
            "intent-agent": AgentDefinition(
                description="Understands user intent from repository URL through conversation",
                prompt=INTENT_AGENT_PROMPT,
                tools=[
                    "mcp__intent__analyze_user_intent",
                    "mcp__intent__generate_story_plan",
                    "mcp__intent__suggest_follow_up_questions",
                ],
                model="sonnet",  # Balanced for conversation
            )
        }
    )


class IntentAgent:
    """High-level wrapper for Intent Agent operations."""
    
    def __init__(self):
        self.options = create_intent_agent_options()
        self.client = ClaudeSDKClient(self.options)
        self.conversation_history = []
        self.intent_gathered = False
        self.story_plan = None
    
    async def start_conversation(self, repo_url: str) -> str:
        """Start a new onboarding conversation."""
        self.conversation_history = []
        self.intent_gathered = False
        self.story_plan = None
        
        message = f"I'd like to create an audio story about this repository: {repo_url}\n\nPlease help me understand your goals so I can tailor the story."
        
        response = await self.client.run_agent(
            agent_name="intent-agent",
            message=message,
        )
        
        self.conversation_history.append({"role": "user", "content": message})
        self.conversation_history.append({"role": "assistant", "content": response})
        
        return response
    
    async def continue_conversation(self, user_message: str) -> str:
        """Continue the onboarding conversation."""
        self.conversation_history.append({"role": "user", "content": user_message})
        
        response = await self.client.run_agent(
            agent_name="intent-agent",
            message=user_message,
            conversation_history=self.conversation_history[:-1],
        )
        
        self.conversation_history.append({"role": "assistant", "content": response})
        
        # Check for story plan in response
        if "generate_story_plan" in str(response):
            self.intent_gathered = True
        
        return response
    
    def is_complete(self) -> bool:
        """Check if onboarding is complete."""
        return self.intent_gathered
    
    def get_story_plan(self) -> dict | None:
        """Get the generated story plan."""
        return self.story_plan
```

### Task 3: Create Package Structure

**File**: `src/codestory/agents/intent/__init__.py`

```python
"""Intent Agent package using Claude Agent SDK."""

from .tools import (
    analyze_user_intent,
    generate_story_plan,
    suggest_follow_up_questions,
    INTENT_CATEGORIES,
    EXPERTISE_LEVELS,
    NARRATIVE_STYLES,
)
from .agent import (
    IntentAgent,
    intent_mcp_server,
    create_intent_agent_options,
    INTENT_AGENT_PROMPT,
)

__all__ = [
    # Tools
    "analyze_user_intent",
    "generate_story_plan",
    "suggest_follow_up_questions",
    # Constants
    "INTENT_CATEGORIES",
    "EXPERTISE_LEVELS",
    "NARRATIVE_STYLES",
    # Agent
    "IntentAgent",
    "intent_mcp_server",
    "create_intent_agent_options",
    "INTENT_AGENT_PROMPT",
]
```

## Verification

```bash
uv run python -c "from codestory.agents.intent import IntentAgent, intent_mcp_server; print('Intent Agent OK')"
```

## Success Criteria

- Intent Agent uses @tool decorator for all tools
- AgentDefinition configures the agent with proper model selection
- MCP server created with create_sdk_mcp_server
- Tool names follow mcp__<server>__<tool> pattern
- Conversation state tracking works

## Next Step

Proceed to 02-02-PLAN.md for additional intent analysis capabilities.
