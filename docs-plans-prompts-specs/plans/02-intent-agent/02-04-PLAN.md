---
phase: 02-intent-agent
type: execute
domain: claude-agent-sdk
---

# Phase 2 Plan 04: Intent Agent Integration and Testing

## Objective

Complete Intent Agent integration with API endpoints and pipeline orchestration.

**Purpose**: Make Intent Agent accessible via API and ready for pipeline integration.
**Output**: FastAPI endpoints, pipeline stage integration, and comprehensive tests.

## Context

- @BRIEF.md
- @plans/02-intent-agent/02-01-SUMMARY.md
- @plans/02-intent-agent/02-02-SUMMARY.md
- @plans/02-intent-agent/02-03-SUMMARY.md

## Tasks

### Task 1: Create API Endpoints

**File**: `src/codestory/api/routes/intent.py`

```python
"""Intent Agent API endpoints."""

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel

from codestory.agents.intent import IntentAgent, StoryPlan


router = APIRouter(prefix="/intent", tags=["intent"])


class StartConversationRequest(BaseModel):
    """Request to start intent conversation."""
    repo_url: str


class ContinueConversationRequest(BaseModel):
    """Request to continue conversation."""
    session_id: str
    message: str


class ConversationResponse(BaseModel):
    """Response from intent conversation."""
    session_id: str
    response: str
    state: dict
    is_complete: bool


class StoryPlanResponse(BaseModel):
    """Response with generated story plan."""
    session_id: str
    plan: dict
    valid: bool


# Session storage (in production, use Redis or database)
_sessions: dict[str, IntentAgent] = {}


@router.post("/start", response_model=ConversationResponse)
async def start_conversation(request: StartConversationRequest):
    """Start a new intent gathering conversation."""
    import uuid
    
    session_id = str(uuid.uuid4())
    agent = IntentAgent()
    _sessions[session_id] = agent
    
    try:
        response = await agent.start_conversation(request.repo_url)
        return ConversationResponse(
            session_id=session_id,
            response=response,
            state=agent.get_conversation_state(),
            is_complete=agent.is_complete(),
        )
    except Exception as e:
        del _sessions[session_id]
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/continue", response_model=ConversationResponse)
async def continue_conversation(request: ContinueConversationRequest):
    """Continue an existing intent conversation."""
    agent = _sessions.get(request.session_id)
    if not agent:
        raise HTTPException(status_code=404, detail="Session not found")
    
    try:
        response = await agent.continue_conversation(request.message)
        return ConversationResponse(
            session_id=request.session_id,
            response=response,
            state=agent.get_conversation_state(),
            is_complete=agent.is_complete(),
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/state/{session_id}")
async def get_conversation_state(session_id: str):
    """Get current conversation state."""
    agent = _sessions.get(session_id)
    if not agent:
        raise HTTPException(status_code=404, detail="Session not found")
    
    return {
        "session_id": session_id,
        "state": agent.get_conversation_state(),
        "is_complete": agent.is_complete(),
    }


@router.delete("/session/{session_id}")
async def end_session(session_id: str):
    """End and cleanup a conversation session."""
    if session_id in _sessions:
        del _sessions[session_id]
        return {"message": "Session ended"}
    raise HTTPException(status_code=404, detail="Session not found")


@router.get("/health")
async def health_check():
    """Health check for intent agent service."""
    return {
        "status": "healthy",
        "agent": "intent",
        "active_sessions": len(_sessions),
    }
```

### Task 2: Create Pipeline Stage Integration

**File**: `src/codestory/agents/intent/stage.py`

```python
"""Intent Agent pipeline stage integration."""

from typing import Any

from claude_agent_sdk import AgentDefinition

from .agent import IntentAgent, create_intent_agent_options
from .models import StoryPlan


class IntentStage:
    """Pipeline stage wrapper for Intent Agent.
    
    Integrates with the orchestrator pipeline as the INTENT stage.
    """
    
    stage_name = "INTENT"
    
    def __init__(self):
        self.agent = IntentAgent()
    
    async def run_stage(self, context: dict[str, Any]) -> dict[str, Any]:
        """Run the intent stage of the pipeline.
        
        Args:
            context: Pipeline context with repo_url and optional conversation
        
        Returns:
            Updated context with story_plan
        """
        repo_url = context.get("repo_url")
        if not repo_url:
            raise ValueError("repo_url required in context")
        
        # Check for existing intent data
        if context.get("story_plan"):
            return context
        
        # Check for pre-gathered intent
        if context.get("intent"):
            intent = context["intent"]
            # Convert intent to story plan
            plan = await self._create_plan_from_intent(repo_url, intent)
            context["story_plan"] = plan.to_dict()
            return context
        
        # Start interactive conversation if no intent provided
        response = await self.agent.start_conversation(repo_url)
        
        # For non-interactive mode, return with prompt for input
        context["intent_response"] = response
        context["intent_state"] = self.agent.get_conversation_state()
        context["awaiting_input"] = True
        
        return context
    
    async def continue_stage(
        self, 
        context: dict[str, Any], 
        user_input: str
    ) -> dict[str, Any]:
        """Continue the intent stage with user input.
        
        Args:
            context: Current pipeline context
            user_input: User's response
        
        Returns:
            Updated context
        """
        response = await self.agent.continue_conversation(user_input)
        
        context["intent_response"] = response
        context["intent_state"] = self.agent.get_conversation_state()
        
        if self.agent.is_complete():
            plan = self.agent.get_story_plan()
            if plan:
                context["story_plan"] = plan
                context["awaiting_input"] = False
        
        return context
    
    async def _create_plan_from_intent(
        self, 
        repo_url: str, 
        intent: dict
    ) -> StoryPlan:
        """Create story plan from pre-gathered intent."""
        from .tools import generate_story_plan
        
        result = await generate_story_plan({
            "repo_url": repo_url,
            "intent_category": intent.get("category", "onboarding"),
            "expertise_level": intent.get("expertise_level", "intermediate"),
            "narrative_style": intent.get("preferred_style", "documentary"),
            "focus_areas": intent.get("focus_areas", []),
            "learning_goals": intent.get("learning_goals", ""),
            "target_duration_minutes": intent.get("time_preference_minutes", 15),
        })
        
        # Parse result and create StoryPlan
        plan_data = eval(result["content"][0]["text"])
        return StoryPlan.from_dict(plan_data)
    
    def get_agent_definition(self) -> AgentDefinition:
        """Get the AgentDefinition for this stage."""
        options = create_intent_agent_options()
        return options.agents["intent-agent"]


# Singleton instance for pipeline
intent_stage = IntentStage()
```

### Task 3: Create Tests

**File**: `tests/agents/test_intent_agent.py`

```python
"""Tests for Intent Agent."""

import pytest
from unittest.mock import AsyncMock, patch

from codestory.agents.intent import (
    IntentAgent,
    analyze_user_intent,
    generate_story_plan,
    suggest_follow_up_questions,
    track_conversation_state,
    summarize_intent,
    validate_story_plan,
    StoryPlan,
    ChapterOutline,
    UserIntent,
    ConversationState,
    IntentCategory,
    ExpertiseLevel,
    NarrativeStyle,
)


class TestIntentTools:
    """Tests for Intent Agent tools."""
    
    @pytest.mark.asyncio
    async def test_analyze_user_intent_onboarding(self):
        """Test intent analysis for onboarding category."""
        result = await analyze_user_intent({
            "conversation_summary": "I'm new to this project",
            "stated_goal": "I want to learn how this codebase works",
            "technical_background": "I'm a beginner programmer",
            "specific_interests": "the main features",
        })
        
        content = result["content"][0]["text"]
        assert "onboarding" in content or "category" in content
    
    @pytest.mark.asyncio
    async def test_analyze_user_intent_architecture(self):
        """Test intent analysis for architecture category."""
        result = await analyze_user_intent({
            "conversation_summary": "Understanding the system design",
            "stated_goal": "I want to understand the architecture and patterns",
            "technical_background": "I'm a senior developer with 10 years experience",
            "specific_interests": "design patterns, data flow",
        })
        
        content = result["content"][0]["text"]
        assert "architecture" in content or "expert" in content
    
    @pytest.mark.asyncio
    async def test_generate_story_plan(self):
        """Test story plan generation."""
        result = await generate_story_plan({
            "repo_url": "https://github.com/example/repo",
            "intent_category": "onboarding",
            "expertise_level": "intermediate",
            "narrative_style": "documentary",
            "focus_areas": ["API", "database"],
            "learning_goals": "understand the codebase",
        })
        
        content = result["content"][0]["text"]
        assert "title" in content
        assert "chapters" in content
    
    @pytest.mark.asyncio
    async def test_suggest_follow_up_questions_early(self):
        """Test follow-up questions early in conversation."""
        result = await suggest_follow_up_questions({
            "has_stated_goal": False,
            "has_background": False,
            "has_focus_areas": False,
            "has_time_preference": False,
            "conversation_turn": 1,
        })
        
        content = result["content"][0]["text"]
        assert "question" in content.lower()
    
    @pytest.mark.asyncio
    async def test_suggest_follow_up_questions_ready(self):
        """Test follow-up when ready to generate."""
        result = await suggest_follow_up_questions({
            "has_stated_goal": True,
            "has_background": True,
            "has_focus_areas": True,
            "has_time_preference": True,
            "conversation_turn": 5,
        })
        
        content = result["content"][0]["text"]
        assert "ready" in content.lower() or "plan" in content.lower()
    
    @pytest.mark.asyncio
    async def test_track_conversation_state(self):
        """Test conversation state tracking."""
        result = await track_conversation_state({
            "message": "I want to learn about the architecture",
            "current_state": {"turn_count": 0, "has_stated_goal": False},
        })
        
        content = result["content"][0]["text"]
        assert "has_stated_goal" in content
    
    @pytest.mark.asyncio
    async def test_summarize_intent(self):
        """Test intent summarization."""
        result = await summarize_intent({
            "stated_goal": "Understand the API layer",
            "expertise_level": "intermediate",
            "focus_areas": ["REST endpoints", "authentication"],
            "preferred_style": "tutorial",
            "time_preference": 20,
        })
        
        content = result["content"][0]["text"]
        assert "Goal" in content or "summary" in content.lower()
    
    @pytest.mark.asyncio
    async def test_validate_story_plan_valid(self):
        """Test story plan validation with valid plan."""
        result = await validate_story_plan({
            "plan": {
                "title": "Test Story",
                "narrative_style": "documentary",
                "chapters": [
                    {"number": 1, "title": "Intro", "duration_minutes": 5},
                    {"number": 2, "title": "Main", "duration_minutes": 10},
                ],
                "repo_url": "https://github.com/test/repo",
            }
        })
        
        content = result["content"][0]["text"]
        assert "valid" in content.lower()
    
    @pytest.mark.asyncio
    async def test_validate_story_plan_invalid(self):
        """Test story plan validation with invalid plan."""
        result = await validate_story_plan({
            "plan": {
                "title": "Test Story",
                # Missing required fields
            }
        })
        
        content = result["content"][0]["text"]
        assert "error" in content.lower() or "missing" in content.lower()


class TestDataModels:
    """Tests for Intent Agent data models."""
    
    def test_chapter_outline_to_dict(self):
        """Test ChapterOutline serialization."""
        chapter = ChapterOutline(
            number=1,
            title="Introduction",
            focus="Overview",
            duration_minutes=5.0,
            key_concepts=["basics"],
        )
        
        data = chapter.to_dict()
        assert data["number"] == 1
        assert data["title"] == "Introduction"
        assert data["duration_minutes"] == 5.0
    
    def test_chapter_outline_from_dict(self):
        """Test ChapterOutline deserialization."""
        data = {
            "number": 2,
            "title": "Deep Dive",
            "focus": "Details",
            "duration_minutes": 10.0,
            "key_concepts": ["advanced"],
            "code_elements": ["main.py"],
        }
        
        chapter = ChapterOutline.from_dict(data)
        assert chapter.number == 2
        assert chapter.title == "Deep Dive"
        assert "advanced" in chapter.key_concepts
    
    def test_story_plan_to_dict(self):
        """Test StoryPlan serialization."""
        plan = StoryPlan(
            title="Test Story",
            description="A test story",
            narrative_style=NarrativeStyle.DOCUMENTARY,
            total_duration_minutes=15.0,
            expertise_level=ExpertiseLevel.INTERMEDIATE,
            intent_category=IntentCategory.ONBOARDING,
            chapters=[
                ChapterOutline(1, "Intro", "Overview", 5.0),
                ChapterOutline(2, "Main", "Details", 10.0),
            ],
            repo_url="https://github.com/test/repo",
        )
        
        data = plan.to_dict()
        assert data["title"] == "Test Story"
        assert data["narrative_style"] == "documentary"
        assert len(data["chapters"]) == 2
    
    def test_story_plan_from_dict(self):
        """Test StoryPlan deserialization."""
        data = {
            "title": "From Dict Story",
            "description": "Loaded from dict",
            "narrative_style": "tutorial",
            "total_duration_minutes": 20.0,
            "expertise_level": "beginner",
            "intent_category": "onboarding",
            "chapters": [
                {"number": 1, "title": "Start", "focus": "Begin", "duration_minutes": 5.0}
            ],
            "learning_objectives": ["Learn basics"],
            "prerequisites": [],
            "repo_url": "https://github.com/test/repo",
        }
        
        plan = StoryPlan.from_dict(data)
        assert plan.title == "From Dict Story"
        assert plan.narrative_style == NarrativeStyle.TUTORIAL
        assert len(plan.chapters) == 1
    
    def test_conversation_state_update(self):
        """Test ConversationState updates from messages."""
        state = ConversationState()
        
        state.update_from_message("I want to learn about the API")
        assert state.has_stated_goal is True
        assert state.turn_count == 1
        
        state.update_from_message("I have 5 years of experience")
        assert state.has_background is True
        assert state.expertise_level == "expert"
        assert state.turn_count == 2
    
    def test_conversation_state_completeness(self):
        """Test ConversationState completeness calculation."""
        state = ConversationState()
        assert state.completeness_score() == 0.0
        assert state.is_complete() is False
        
        state.has_stated_goal = True
        state.has_background = True
        assert state.is_complete() is True
        assert state.completeness_score() == 0.5
        
        state.has_focus_areas = True
        state.has_time_preference = True
        assert state.completeness_score() == 1.0


class TestIntentAgent:
    """Tests for IntentAgent class."""
    
    @pytest.mark.asyncio
    @patch("codestory.agents.intent.agent.ClaudeSDKClient")
    async def test_start_conversation(self, mock_client_class):
        """Test starting a conversation."""
        mock_client = AsyncMock()
        mock_client.run_agent.return_value = "Welcome! What would you like to learn?"
        mock_client_class.return_value = mock_client
        
        agent = IntentAgent()
        response = await agent.start_conversation("https://github.com/test/repo")
        
        assert "Welcome" in response or response is not None
        assert len(agent.conversation_history) == 2
    
    def test_get_conversation_state(self):
        """Test getting conversation state."""
        agent = IntentAgent()
        state = agent.get_conversation_state()
        
        assert "turn_count" in state
        assert "completeness" in state
        assert state["ready_for_plan"] is False
```

### Task 4: Update Package Structure

**File**: `src/codestory/agents/intent/__init__.py` (final)

```python
"""Intent Agent package using Claude Agent SDK.

This package provides the Intent Agent for understanding user learning goals
through conversational onboarding. It uses the Claude Agent SDK pattern with
@tool decorators and AgentDefinition.

Usage:
    from codestory.agents.intent import IntentAgent
    
    agent = IntentAgent()
    response = await agent.start_conversation("https://github.com/user/repo")
    response = await agent.continue_conversation("I want to understand the API")
"""

from .tools import (
    analyze_user_intent,
    generate_story_plan,
    suggest_follow_up_questions,
    track_conversation_state,
    summarize_intent,
    validate_story_plan,
    INTENT_CATEGORIES,
    EXPERTISE_LEVELS,
    NARRATIVE_STYLES,
)
from .agent import (
    IntentAgent,
    intent_mcp_server,
    create_intent_agent_options,
    INTENT_AGENT_PROMPT,
)
from .models import (
    IntentCategory,
    ExpertiseLevel,
    NarrativeStyle,
    ChapterOutline,
    UserIntent,
    StoryPlan,
    ConversationState,
)
from .stage import (
    IntentStage,
    intent_stage,
)

__all__ = [
    # Tools
    "analyze_user_intent",
    "generate_story_plan",
    "suggest_follow_up_questions",
    "track_conversation_state",
    "summarize_intent",
    "validate_story_plan",
    # Constants
    "INTENT_CATEGORIES",
    "EXPERTISE_LEVELS",
    "NARRATIVE_STYLES",
    # Agent
    "IntentAgent",
    "intent_mcp_server",
    "create_intent_agent_options",
    "INTENT_AGENT_PROMPT",
    # Models
    "IntentCategory",
    "ExpertiseLevel",
    "NarrativeStyle",
    "ChapterOutline",
    "UserIntent",
    "StoryPlan",
    "ConversationState",
    # Pipeline
    "IntentStage",
    "intent_stage",
]
```

## Verification

```bash
# Run tests
uv run pytest tests/agents/test_intent_agent.py -v

# Check imports
uv run python -c "from codestory.agents.intent import IntentAgent, intent_stage; print('Integration OK')"
```

## Success Criteria

- API endpoints handle conversation flow
- Pipeline stage integrates with orchestrator
- All tests pass
- Agent can complete full conversation flow

## Phase 2 Complete

The Intent Agent is now complete with:
- 6 tools using @tool decorator
- MCP server with create_sdk_mcp_server
- AgentDefinition with sonnet model
- Data models for story plans
- API endpoints for web interface
- Pipeline stage for orchestrator
- Comprehensive tests

Ready for Phase 3: Repo Analyzer Agent.
