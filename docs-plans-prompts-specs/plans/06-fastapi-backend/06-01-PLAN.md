---
phase: 06-fastapi-backend
plan: 01
type: execute
domain: python-api
---

<objective>
Set up FastAPI application with Claude Agent SDK integration, MCP server configuration, and hook-based SSE progress events.
</objective>

<context>
@BRIEF.md
@codestory/backend/core/config.py
@claude_agent_sdk patterns
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create Claude Agent SDK tools module</n>
  <files>src/codestory/backend/sdk/tools.py, src/codestory/backend/sdk/__init__.py</files>
  <action>
Create the Code Story MCP tools using Claude Agent SDK:

```python
"""Code Story MCP tools using Claude Agent SDK."""

from claude_agent_sdk import tool, create_sdk_mcp_server
from typing import Any

# Story creation tool
@tool(
    name="create_story",
    description="Create a new code story from a GitHub repository URL",
    input_schema={
        "type": "object",
        "properties": {
            "repo_url": {
                "type": "string",
                "description": "GitHub repository URL"
            },
            "style": {
                "type": "string",
                "enum": ["fiction", "documentary", "tutorial", "podcast", "technical"],
                "description": "Narrative style for the story"
            },
            "expertise_level": {
                "type": "string",
                "enum": ["beginner", "intermediate", "advanced"],
                "description": "Target audience expertise level"
            },
            "focus_areas": {
                "type": "array",
                "items": {"type": "string"},
                "description": "Specific areas of code to focus on"
            }
        },
        "required": ["repo_url"]
    }
)
async def create_story(args: dict) -> dict:
    """Create a new code story."""
    repo_url = args["repo_url"]
    style = args.get("style", "documentary")
    expertise = args.get("expertise_level", "intermediate")
    focus_areas = args.get("focus_areas", [])

    # Story creation logic handled by pipeline
    return {
        "content": [{
            "type": "text",
            "text": f"Creating story for {repo_url} with style={style}, expertise={expertise}"
        }]
    }


# Repository analysis tool
@tool(
    name="analyze_repository",
    description="Analyze a GitHub repository structure and code patterns",
    input_schema={
        "type": "object",
        "properties": {
            "repo_url": {
                "type": "string",
                "description": "GitHub repository URL"
            },
            "focus_areas": {
                "type": "array",
                "items": {"type": "string"},
                "description": "Specific areas to analyze"
            }
        },
        "required": ["repo_url"]
    }
)
async def analyze_repository(args: dict) -> dict:
    """Analyze repository structure."""
    repo_url = args["repo_url"]
    focus_areas = args.get("focus_areas", [])

    return {
        "content": [{
            "type": "text",
            "text": f"Analyzing repository: {repo_url}"
        }]
    }


# Script generation tool
@tool(
    name="generate_script",
    description="Generate narrative script from code analysis",
    input_schema={
        "type": "object",
        "properties": {
            "analysis": {
                "type": "object",
                "description": "Repository analysis data"
            },
            "style": {
                "type": "string",
                "description": "Narrative style"
            },
            "expertise_level": {
                "type": "string",
                "description": "Target expertise level"
            }
        },
        "required": ["analysis", "style"]
    }
)
async def generate_script(args: dict) -> dict:
    """Generate narrative script."""
    return {
        "content": [{
            "type": "text",
            "text": "Generating narrative script..."
        }]
    }


# Audio synthesis tool
@tool(
    name="synthesize_audio",
    description="Synthesize audio from narrative script using ElevenLabs",
    input_schema={
        "type": "object",
        "properties": {
            "script": {
                "type": "object",
                "description": "Narrative script with chapters"
            },
            "voice_id": {
                "type": "string",
                "description": "ElevenLabs voice ID"
            },
            "output_path": {
                "type": "string",
                "description": "Output file path"
            }
        },
        "required": ["script"]
    }
)
async def synthesize_audio(args: dict) -> dict:
    """Synthesize audio from script."""
    return {
        "content": [{
            "type": "text",
            "text": "Synthesizing audio..."
        }]
    }


# Progress update tool
@tool(
    name="update_progress",
    description="Update story generation progress",
    input_schema={
        "type": "object",
        "properties": {
            "story_id": {"type": "string"},
            "status": {"type": "string"},
            "progress_percent": {"type": "integer"},
            "current_step": {"type": "string"}
        },
        "required": ["story_id", "status", "progress_percent"]
    }
)
async def update_progress(args: dict) -> dict:
    """Update progress status."""
    story_id = args["story_id"]
    status = args["status"]
    progress = args["progress_percent"]
    step = args.get("current_step", "")

    return {
        "content": [{
            "type": "text",
            "text": f"Progress: {story_id} - {status} ({progress}%) - {step}"
        }]
    }


# Create MCP server with all tools
def create_codestory_server():
    """Create Code Story MCP server with all tools."""
    return create_sdk_mcp_server(
        name="codestory",
        version="1.0.0",
        tools=[
            create_story,
            analyze_repository,
            generate_script,
            synthesize_audio,
            update_progress,
        ]
    )


# Export server instance
codestory_server = create_codestory_server()
```

Create __init__.py:

```python
"""Code Story SDK package."""

from src.codestory.backend.sdk.tools import (
    codestory_server,
    create_codestory_server,
    create_story,
    analyze_repository,
    generate_script,
    synthesize_audio,
    update_progress,
)

__all__ = [
    "codestory_server",
    "create_codestory_server",
    "create_story",
    "analyze_repository",
    "generate_script",
    "synthesize_audio",
    "update_progress",
]
```
  </action>
  <verify>python -c "from src.codestory.backend.sdk.tools import codestory_server; print('SDK tools OK')"</verify>
  <done>Claude Agent SDK tools created</done>
</task>

<task type="auto">
  <n>Task 2: Create SDK hooks for SSE progress events</n>
  <files>src/codestory/backend/sdk/hooks.py</files>
  <action>
Create hook handlers for request validation and progress events:

```python
"""Claude Agent SDK hooks for Code Story."""

import json
import logging
from typing import Any
from datetime import datetime
from collections import defaultdict

logger = logging.getLogger(__name__)

# SSE event queues per story_id
_sse_queues: dict[str, list[dict]] = defaultdict(list)


async def validate_api_request(
    input_data: dict,
    tool_use_id: str,
    context: dict
) -> dict:
    """
    PreToolUse hook to validate API requests.

    Validates:
    - User authentication
    - Rate limiting
    - Input sanitization
    """
    tool_name = input_data.get("tool_name", "")
    tool_input = input_data.get("tool_input", {})

    # Log tool invocation
    logger.info(f"PreToolUse: {tool_name} with input: {json.dumps(tool_input)[:200]}")

    # Validate repository URL for story creation
    if tool_name == "mcp__codestory__create_story":
        repo_url = tool_input.get("repo_url", "")
        if not repo_url.startswith("https://github.com/"):
            return {
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "permissionDecision": "deny",
                    "permissionDecisionReason": "Invalid repository URL. Must be a GitHub URL."
                }
            }

    # Validate story_id format for progress updates
    if tool_name == "mcp__codestory__update_progress":
        story_id = tool_input.get("story_id", "")
        if not story_id or len(story_id) != 36:  # UUID format check
            return {
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "permissionDecision": "deny",
                    "permissionDecisionReason": "Invalid story_id format"
                }
            }

    # Allow by default
    return {}


async def emit_progress_event(
    input_data: dict,
    tool_use_id: str,
    context: dict
) -> dict:
    """
    PostToolUse hook to emit SSE progress events.

    Captures tool results and broadcasts to connected clients.
    """
    tool_name = input_data.get("tool_name", "")
    tool_response = input_data.get("tool_response", "")

    # Log tool completion
    logger.info(f"PostToolUse: {tool_name} completed")

    # Extract story_id from context or tool input
    story_id = None
    if "story_id" in context:
        story_id = context["story_id"]
    elif "tool_input" in input_data:
        story_id = input_data["tool_input"].get("story_id")

    if not story_id:
        return {}

    # Create SSE event based on tool
    event = {
        "timestamp": datetime.utcnow().isoformat(),
        "tool": tool_name,
        "story_id": story_id,
    }

    # Map tool to progress status
    tool_progress_map = {
        "mcp__codestory__analyze_repository": {
            "status": "analyzing",
            "progress": 25,
            "step": "Analyzing repository structure"
        },
        "mcp__codestory__generate_script": {
            "status": "generating",
            "progress": 50,
            "step": "Generating narrative script"
        },
        "mcp__codestory__synthesize_audio": {
            "status": "synthesizing",
            "progress": 75,
            "step": "Synthesizing audio"
        },
        "mcp__codestory__update_progress": {
            "status": "updating",
            "progress": None,  # Use from tool input
            "step": None
        }
    }

    if tool_name in tool_progress_map:
        progress_info = tool_progress_map[tool_name]
        event["status"] = progress_info["status"]
        event["progress_percent"] = progress_info["progress"]
        event["current_step"] = progress_info["step"]

        # For update_progress, use actual values from input
        if tool_name == "mcp__codestory__update_progress":
            tool_input = input_data.get("tool_input", {})
            event["status"] = tool_input.get("status", "processing")
            event["progress_percent"] = tool_input.get("progress_percent", 0)
            event["current_step"] = tool_input.get("current_step", "")

    # Queue event for SSE broadcast
    _sse_queues[story_id].append(event)

    # Emit to any registered callbacks
    await _broadcast_sse_event(story_id, event)

    return {}


async def log_tool_execution(
    input_data: dict,
    tool_use_id: str,
    context: dict
) -> dict:
    """
    PostToolUse hook for audit logging.
    """
    tool_name = input_data.get("tool_name", "")
    tool_response = input_data.get("tool_response", "")[:500]  # Truncate

    logger.info(
        f"[AUDIT] Tool: {tool_name}, "
        f"ID: {tool_use_id}, "
        f"Response: {tool_response}"
    )

    return {}


# SSE callback registry
_sse_callbacks: dict[str, list] = defaultdict(list)


def register_sse_callback(story_id: str, callback):
    """Register a callback for SSE events."""
    _sse_callbacks[story_id].append(callback)


def unregister_sse_callback(story_id: str, callback):
    """Unregister SSE callback."""
    if callback in _sse_callbacks[story_id]:
        _sse_callbacks[story_id].remove(callback)


async def _broadcast_sse_event(story_id: str, event: dict):
    """Broadcast SSE event to all registered callbacks."""
    for callback in _sse_callbacks.get(story_id, []):
        try:
            await callback(event)
        except Exception as e:
            logger.warning(f"SSE callback error: {e}")


def get_pending_events(story_id: str) -> list[dict]:
    """Get and clear pending SSE events for a story."""
    events = _sse_queues.pop(story_id, [])
    return events
```
  </action>
  <verify>python -c "from src.codestory.backend.sdk.hooks import validate_api_request, emit_progress_event; print('Hooks OK')"</verify>
  <done>SDK hooks created</done>
</task>

<task type="auto">
  <n>Task 3: Create SDK client configuration</n>
  <files>src/codestory/backend/sdk/client.py</files>
  <action>
Create the Claude Agent SDK client configuration:

```python
"""Claude Agent SDK client configuration for Code Story."""

from claude_agent_sdk import (
    ClaudeAgentOptions,
    ClaudeSDKClient,
    AgentDefinition,
    HookMatcher,
)

from src.codestory.backend.sdk.tools import codestory_server
from src.codestory.backend.sdk.hooks import (
    validate_api_request,
    emit_progress_event,
    log_tool_execution,
)


def create_sdk_options(
    story_id: str | None = None,
    user_id: str | None = None,
) -> ClaudeAgentOptions:
    """
    Create Claude Agent SDK options for Code Story pipeline.

    Args:
        story_id: Story being generated (for context)
        user_id: User making the request (for auth context)

    Returns:
        Configured ClaudeAgentOptions
    """
    # Build context for hooks
    context = {}
    if story_id:
        context["story_id"] = story_id
    if user_id:
        context["user_id"] = user_id

    return ClaudeAgentOptions(
        # MCP server with Code Story tools
        mcp_servers={
            "codestory": codestory_server,
        },

        # Allow all codestory tools
        allowed_tools=[
            "mcp__codestory__create_story",
            "mcp__codestory__analyze_repository",
            "mcp__codestory__generate_script",
            "mcp__codestory__synthesize_audio",
            "mcp__codestory__update_progress",
            # Also allow built-in tools
            "Read",
            "Bash",
            "Grep",
            "Glob",
        ],

        # Hook configuration
        hooks={
            "PreToolUse": [
                HookMatcher(
                    matcher="mcp__codestory__*",
                    hooks=[validate_api_request],
                    context=context,
                )
            ],
            "PostToolUse": [
                HookMatcher(
                    matcher="mcp__codestory__*",
                    hooks=[emit_progress_event, log_tool_execution],
                    context=context,
                )
            ],
        },

        # Agent definitions for pipeline stages
        agents={
            "repo-analyzer": AgentDefinition(
                description="Analyzes GitHub repository structure and code patterns",
                prompt="""You are a repository analysis expert. Your job is to:
1. Fetch and analyze repository structure
2. Identify key files, patterns, and architecture
3. Extract important code components for storytelling
4. Map relationships between modules

Use the analyze_repository tool to perform analysis.""",
                tools=["mcp__codestory__analyze_repository", "Read", "Grep"],
                model="sonnet",
            ),
            "story-architect": AgentDefinition(
                description="Creates narrative scripts from code analysis",
                prompt="""You are a story architect. Transform code analysis into engaging narratives.
Create scripts with clear chapters, appropriate pacing, and technical accuracy.""",
                tools=["mcp__codestory__generate_script"],
                model="sonnet",
            ),
            "voice-director": AgentDefinition(
                description="Synthesizes audio from narrative scripts",
                prompt="""You are a voice director. Convert narrative scripts to audio.
Handle voice selection, pacing, and audio quality.""",
                tools=["mcp__codestory__synthesize_audio"],
                model="haiku",  # Faster for simple coordination
            ),
        },

        # Execution settings
        max_turns=50,
        permission_mode="acceptEdits",
    )


async def create_story_pipeline(
    story_id: str,
    user_id: str,
    repo_url: str,
    style: str = "documentary",
    expertise_level: str = "intermediate",
) -> dict:
    """
    Run the full story generation pipeline.

    Args:
        story_id: Unique story identifier
        user_id: User requesting the story
        repo_url: GitHub repository URL
        style: Narrative style
        expertise_level: Target audience level

    Returns:
        Pipeline result with story data
    """
    options = create_sdk_options(story_id=story_id, user_id=user_id)

    async with ClaudeSDKClient(options=options) as client:
        # Run the pipeline with a comprehensive prompt
        prompt = f"""
Generate a code story for the repository: {repo_url}

Configuration:
- Story ID: {story_id}
- Style: {style}
- Expertise Level: {expertise_level}

Pipeline Steps:
1. Use analyze_repository to understand the codebase
2. Use generate_script to create the narrative
3. Use synthesize_audio to create the audio file
4. Use update_progress to report status at each step

Begin by analyzing the repository.
"""

        await client.query(prompt)

        result = {
            "story_id": story_id,
            "status": "complete",
            "messages": [],
        }

        async for msg in client.receive_response():
            result["messages"].append(msg)

        return result


# Singleton client for reuse
_shared_options: ClaudeAgentOptions | None = None


def get_shared_options() -> ClaudeAgentOptions:
    """Get shared SDK options (creates on first call)."""
    global _shared_options
    if _shared_options is None:
        _shared_options = create_sdk_options()
    return _shared_options
```
  </action>
  <verify>python -c "from src.codestory.backend.sdk.client import create_sdk_options; print('Client config OK')"</verify>
  <done>SDK client configuration created</done>
</task>

<task type="auto">
  <n>Task 4: Create FastAPI application with SDK integration</n>
  <files>src/codestory/backend/api/app.py, src/codestory/backend/api/__init__.py</files>
  <action>
Create the main FastAPI application with Claude Agent SDK integration:

```python
"""FastAPI application factory for Code Story with Claude Agent SDK."""

from contextlib import asynccontextmanager
from typing import AsyncGenerator

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware

from src.codestory.backend.core.config import get_settings
from src.codestory.backend.api.routers import auth, stories, health, users, sse
from src.codestory.backend.api.middleware import RequestLoggingMiddleware, RateLimitMiddleware
from src.codestory.backend.api.exceptions import register_exception_handlers
from src.codestory.backend.core.database import engine, init_db
from src.codestory.backend.sdk.tools import codestory_server


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """Application lifespan handler with SDK initialization."""
    # Startup
    await init_db()

    # Initialize SDK server (MCP tools are ready)
    app.state.sdk_server = codestory_server

    yield

    # Shutdown
    await engine.dispose()


def create_app() -> FastAPI:
    """Create and configure the FastAPI application with Claude Agent SDK."""
    settings = get_settings()

    app = FastAPI(
        title="Code Story API",
        description="Transform code repositories into audio narratives using Claude Agent SDK",
        version="1.0.0",
        docs_url="/api/docs" if not settings.is_production else None,
        redoc_url="/api/redoc" if not settings.is_production else None,
        lifespan=lifespan,
    )

    # Configure CORS
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.cors_origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Add compression
    app.add_middleware(GZipMiddleware, minimum_size=1000)

    # Add custom middleware
    app.add_middleware(RequestLoggingMiddleware)

    if settings.rate_limit_enabled:
        app.add_middleware(RateLimitMiddleware)

    # Register exception handlers
    register_exception_handlers(app)

    # Include routers
    app.include_router(health.router, prefix="/api", tags=["health"])
    app.include_router(auth.router, prefix="/api/auth", tags=["auth"])
    app.include_router(users.router, prefix="/api/users", tags=["users"])
    app.include_router(stories.router, prefix="/api/stories", tags=["stories"])
    app.include_router(sse.router, prefix="/api/sse", tags=["sse"])

    return app


# Application instance
app = create_app()
```

Create __init__.py:

```python
"""Code Story API package."""

from src.codestory.backend.api.app import app, create_app

__all__ = ["app", "create_app"]
```
  </action>
  <verify>python -c "from src.codestory.backend.api.app import create_app; print('App OK')"</verify>
  <done>FastAPI application with SDK integration created</done>
</task>

<task type="auto">
  <n>Task 5: Create middleware modules</n>
  <files>src/codestory/backend/api/middleware.py</files>
  <action>
Create custom middleware:

```python
"""Custom middleware for Code Story API."""

import time
import logging
from typing import Callable
from collections import defaultdict

from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware

from src.codestory.backend.core.config import get_settings

logger = logging.getLogger(__name__)


class RequestLoggingMiddleware(BaseHTTPMiddleware):
    """Log all requests with timing."""

    async def dispatch(
        self,
        request: Request,
        call_next: Callable,
    ) -> Response:
        start_time = time.time()

        # Log request
        logger.info(
            f"Request: {request.method} {request.url.path}",
            extra={
                "method": request.method,
                "path": request.url.path,
                "client": request.client.host if request.client else None,
            },
        )

        response = await call_next(request)

        # Log response with timing
        duration = time.time() - start_time
        logger.info(
            f"Response: {response.status_code} in {duration:.3f}s",
            extra={
                "status_code": response.status_code,
                "duration_seconds": duration,
            },
        )

        # Add timing header
        response.headers["X-Process-Time"] = f"{duration:.3f}"

        return response


class RateLimitMiddleware(BaseHTTPMiddleware):
    """Simple in-memory rate limiting."""

    def __init__(self, app, requests_per_minute: int = 60):
        super().__init__(app)
        self.requests_per_minute = requests_per_minute
        self.request_counts: dict[str, list[float]] = defaultdict(list)

    async def dispatch(
        self,
        request: Request,
        call_next: Callable,
    ) -> Response:
        # Get client identifier
        client_id = self._get_client_id(request)
        current_time = time.time()

        # Clean old entries
        self.request_counts[client_id] = [
            t for t in self.request_counts[client_id]
            if current_time - t < 60
        ]

        # Check rate limit
        if len(self.request_counts[client_id]) >= self.requests_per_minute:
            return Response(
                content='{"detail": "Rate limit exceeded"}',
                status_code=429,
                media_type="application/json",
                headers={"Retry-After": "60"},
            )

        # Record request
        self.request_counts[client_id].append(current_time)

        response = await call_next(request)

        # Add rate limit headers
        remaining = self.requests_per_minute - len(self.request_counts[client_id])
        response.headers["X-RateLimit-Limit"] = str(self.requests_per_minute)
        response.headers["X-RateLimit-Remaining"] = str(remaining)

        return response

    def _get_client_id(self, request: Request) -> str:
        """Get unique client identifier."""
        # Use API key if present, else IP
        api_key = request.headers.get("X-API-Key")
        if api_key:
            return f"api:{api_key[:16]}"

        forwarded = request.headers.get("X-Forwarded-For")
        if forwarded:
            return f"ip:{forwarded.split(',')[0].strip()}"

        if request.client:
            return f"ip:{request.client.host}"

        return "unknown"
```
  </action>
  <verify>python -c "from src.codestory.backend.api.middleware import RequestLoggingMiddleware; print('Middleware OK')"</verify>
  <done>Middleware modules created</done>
</task>

<task type="auto">
  <n>Task 6: Create exception handlers</n>
  <files>src/codestory/backend/api/exceptions.py</files>
  <action>
Create exception handling:

```python
"""Exception handlers for Code Story API."""

import logging
from typing import Any

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from pydantic import ValidationError

logger = logging.getLogger(__name__)


class APIError(Exception):
    """Base API error."""

    def __init__(
        self,
        message: str,
        status_code: int = 400,
        details: dict[str, Any] | None = None,
    ):
        self.message = message
        self.status_code = status_code
        self.details = details or {}
        super().__init__(message)


class NotFoundError(APIError):
    """Resource not found."""

    def __init__(self, resource: str, resource_id: str | None = None):
        message = f"{resource} not found"
        if resource_id:
            message = f"{resource} '{resource_id}' not found"
        super().__init__(message, status_code=404)


class UnauthorizedError(APIError):
    """Authentication required."""

    def __init__(self, message: str = "Authentication required"):
        super().__init__(message, status_code=401)


class ForbiddenError(APIError):
    """Access denied."""

    def __init__(self, message: str = "Access denied"):
        super().__init__(message, status_code=403)


class ConflictError(APIError):
    """Resource conflict."""

    def __init__(self, message: str):
        super().__init__(message, status_code=409)


class RateLimitError(APIError):
    """Rate limit exceeded."""

    def __init__(self, retry_after: int = 60):
        super().__init__(
            "Rate limit exceeded",
            status_code=429,
            details={"retry_after": retry_after},
        )


class SDKError(APIError):
    """Claude Agent SDK error."""

    def __init__(self, message: str, details: dict | None = None):
        super().__init__(
            f"SDK error: {message}",
            status_code=500,
            details=details or {},
        )


async def api_error_handler(request: Request, exc: APIError) -> JSONResponse:
    """Handle APIError exceptions."""
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": exc.message,
            "details": exc.details,
        },
    )


async def validation_error_handler(request: Request, exc: ValidationError) -> JSONResponse:
    """Handle Pydantic validation errors."""
    return JSONResponse(
        status_code=422,
        content={
            "error": "Validation error",
            "details": exc.errors(),
        },
    )


async def generic_error_handler(request: Request, exc: Exception) -> JSONResponse:
    """Handle unexpected exceptions."""
    logger.exception("Unexpected error", exc_info=exc)
    return JSONResponse(
        status_code=500,
        content={
            "error": "Internal server error",
            "details": {},
        },
    )


def register_exception_handlers(app: FastAPI) -> None:
    """Register all exception handlers."""
    app.add_exception_handler(APIError, api_error_handler)
    app.add_exception_handler(ValidationError, validation_error_handler)
    app.add_exception_handler(Exception, generic_error_handler)
```
  </action>
  <verify>python -c "from src.codestory.backend.api.exceptions import APIError, SDKError; print('Exceptions OK')"</verify>
  <done>Exception handlers created</done>
</task>

</tasks>

<playwright_validation_gate>
```
Playwright Action: HTTP GET /api/docs
Expected: 200 OK (in development)

Playwright Action: HTTP GET /api/health
Expected: 200 OK with status "healthy"

# Verify SDK server is initialized
Playwright Action: Check app.state.sdk_server is not None
Expected: SDK server available
```
</playwright_validation_gate>
