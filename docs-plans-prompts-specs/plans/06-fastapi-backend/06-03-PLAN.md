---
phase: 06-fastapi-backend
plan: 03
type: execute
domain: python-api
---

<objective>
Implement story CRUD endpoints with Claude Agent SDK integration for async story generation via BackgroundTasks.
</objective>

<context>
@BRIEF.md
@src/codestory/backend/models/story.py
@src/codestory/backend/api/deps.py
@src/codestory/backend/sdk/client.py
</context>

<tasks>

<task type="auto">
  <n>Task 1: Create story schemas</n>
  <files>src/codestory/backend/api/schemas/story.py</files>
  <action>
Create story request/response schemas:

```python
"""Story schemas for Code Story API."""

from datetime import datetime
from enum import Enum
from typing import Any
from pydantic import BaseModel, Field, HttpUrl


class StoryStatus(str, Enum):
    """Story generation status."""

    PENDING = "pending"
    ANALYZING = "analyzing"
    GENERATING = "generating"
    SYNTHESIZING = "synthesizing"
    COMPLETE = "complete"
    FAILED = "failed"


class NarrativeStyle(str, Enum):
    """Narrative style options."""

    FICTION = "fiction"
    DOCUMENTARY = "documentary"
    TUTORIAL = "tutorial"
    PODCAST = "podcast"
    TECHNICAL = "technical"


class ExpertiseLevel(str, Enum):
    """User expertise level."""

    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"


class StoryCreate(BaseModel):
    """Create story request."""

    repository_url: HttpUrl
    style: NarrativeStyle = NarrativeStyle.DOCUMENTARY
    expertise_level: ExpertiseLevel = ExpertiseLevel.INTERMEDIATE
    focus_areas: list[str] = Field(default_factory=list)
    custom_intent: str | None = None


class StoryQuickCreate(BaseModel):
    """Quick story creation (minimal input)."""

    repository_url: HttpUrl
    style: NarrativeStyle = NarrativeStyle.DOCUMENTARY


class ChapterResponse(BaseModel):
    """Chapter in a story."""

    number: int
    title: str
    duration_seconds: float
    start_time_seconds: float
    summary: str | None = None


class StoryResponse(BaseModel):
    """Story response."""

    id: str
    repository_url: str
    title: str
    status: StoryStatus
    style: NarrativeStyle
    expertise_level: ExpertiseLevel

    # Timing
    total_duration_seconds: float | None = None
    total_duration_formatted: str | None = None

    # Content
    chapters: list[ChapterResponse] = Field(default_factory=list)

    # URLs
    audio_url: str | None = None
    thumbnail_url: str | None = None

    # Metadata
    created_at: datetime
    completed_at: datetime | None = None
    error_message: str | None = None

    class Config:
        from_attributes = True


class StoryListResponse(BaseModel):
    """Paginated story list."""

    stories: list[StoryResponse]
    total: int
    page: int
    page_size: int
    has_more: bool


class StoryProgress(BaseModel):
    """Story generation progress."""

    story_id: str
    status: StoryStatus
    progress_percent: int = 0
    current_step: str = ""
    steps_completed: list[str] = Field(default_factory=list)
    estimated_seconds_remaining: int | None = None


class IntentMessage(BaseModel):
    """Message in intent conversation."""

    role: str  # "user" or "assistant"
    content: str


class IntentConversation(BaseModel):
    """Intent conversation for custom story creation."""

    story_id: str
    messages: list[IntentMessage]
    is_complete: bool
    extracted_intent: dict[str, Any] | None = None
```
  </action>
  <verify>python -c "from src.codestory.backend.api.schemas.story import StoryCreate; print('Story schemas OK')"</verify>
  <done>Story schemas created</done>
</task>

<task type="auto">
  <n>Task 2: Create stories router with Claude Agent SDK integration</n>
  <files>src/codestory/backend/api/routers/stories.py</files>
  <action>
Create story endpoints with SDK-powered background generation:

```python
"""Stories router for Code Story API with Claude Agent SDK integration."""

from datetime import datetime
from typing import Annotated
from uuid import UUID, uuid4

from fastapi import APIRouter, Query, BackgroundTasks
from sqlalchemy import select, func

from claude_agent_sdk import ClaudeSDKClient

from src.codestory.backend.api.deps import CurrentUser, DBSession
from src.codestory.backend.api.schemas.story import (
    StoryCreate,
    StoryQuickCreate,
    StoryResponse,
    StoryListResponse,
    StoryProgress,
    ChapterResponse,
)
from src.codestory.backend.api.exceptions import NotFoundError, ForbiddenError
from src.codestory.backend.models.story import Story, StoryChapter, StoryIntent
from src.codestory.backend.sdk.client import create_sdk_options
from src.codestory.backend.sdk.hooks import register_sse_callback, unregister_sse_callback

router = APIRouter()


@router.post("", response_model=StoryResponse)
async def create_story(
    data: StoryCreate,
    user: CurrentUser,
    db: DBSession,
    background_tasks: BackgroundTasks,
) -> StoryResponse:
    """
    Create a new story from a repository URL.

    Uses Claude Agent SDK to orchestrate the 4-agent pipeline:
    1. Intent Agent (if custom_intent provided)
    2. Repo Analyzer Agent
    3. Story Architect Agent
    4. Voice Director Agent
    """
    # Create story record
    story = Story(
        user_id=user.id,
        repository_url=str(data.repository_url),
        title=f"Story: {_extract_repo_name(str(data.repository_url))}",
        status="pending",
        style=data.style.value,
        expertise_level=data.expertise_level.value,
    )
    db.add(story)

    # Create intent record
    intent = StoryIntent(
        story_id=story.id,
        focus_areas=data.focus_areas,
        custom_intent=data.custom_intent,
    )
    db.add(intent)

    await db.commit()
    await db.refresh(story)

    # Queue SDK pipeline as background task
    background_tasks.add_task(
        _run_story_pipeline,
        story_id=str(story.id),
        user_id=str(user.id),
        repo_url=str(data.repository_url),
        style=data.style.value,
        expertise_level=data.expertise_level.value,
        focus_areas=data.focus_areas,
    )

    return StoryResponse.model_validate(story)


@router.post("/quick", response_model=StoryResponse)
async def create_quick_story(
    data: StoryQuickCreate,
    user: CurrentUser,
    db: DBSession,
    background_tasks: BackgroundTasks,
) -> StoryResponse:
    """Create a story with minimal input (Quick Mode)."""
    story = Story(
        user_id=user.id,
        repository_url=str(data.repository_url),
        title=f"Story: {_extract_repo_name(str(data.repository_url))}",
        status="pending",
        style=data.style.value,
        expertise_level="intermediate",
    )
    db.add(story)
    await db.commit()
    await db.refresh(story)

    # Queue SDK pipeline
    background_tasks.add_task(
        _run_story_pipeline,
        story_id=str(story.id),
        user_id=str(user.id),
        repo_url=str(data.repository_url),
        style=data.style.value,
        expertise_level="intermediate",
        focus_areas=[],
    )

    return StoryResponse.model_validate(story)


async def _run_story_pipeline(
    story_id: str,
    user_id: str,
    repo_url: str,
    style: str,
    expertise_level: str,
    focus_areas: list[str],
) -> None:
    """
    Run the Claude Agent SDK story generation pipeline.

    This runs in a background task and uses hooks to emit SSE progress events.
    """
    from src.codestory.backend.core.database import async_session_factory
    from src.codestory.backend.models.story import Story, StoryChapter

    # Create SDK options with hooks for progress events
    options = create_sdk_options(story_id=story_id, user_id=user_id)

    try:
        async with ClaudeSDKClient(options=options) as client:
            # Build the pipeline prompt
            prompt = f"""
Generate a code story for the repository: {repo_url}

Configuration:
- Story ID: {story_id}
- Style: {style}
- Expertise Level: {expertise_level}
- Focus Areas: {', '.join(focus_areas) if focus_areas else 'General overview'}

Pipeline Steps:
1. First, use mcp__codestory__update_progress to set status to "analyzing"
2. Use mcp__codestory__analyze_repository to understand the codebase
3. Use mcp__codestory__update_progress to set status to "generating"
4. Use mcp__codestory__generate_script to create the narrative
5. Use mcp__codestory__update_progress to set status to "synthesizing"
6. Use mcp__codestory__synthesize_audio to create the audio file
7. Use mcp__codestory__update_progress to set status to "complete"

Begin by updating progress and then analyzing the repository.
"""

            await client.query(prompt)

            # Collect pipeline results
            result = {"story_id": story_id, "status": "complete", "messages": []}

            async for msg in client.receive_response():
                result["messages"].append(msg)

            # Update story in database
            async with async_session_factory() as db:
                story = await db.get(Story, UUID(story_id))
                if story:
                    story.status = "complete"
                    story.completed_at = datetime.utcnow()
                    await db.commit()

    except Exception as e:
        # Mark story as failed
        async with async_session_factory() as db:
            story = await db.get(Story, UUID(story_id))
            if story:
                story.status = "failed"
                story.error_message = str(e)[:500]
                await db.commit()


@router.get("", response_model=StoryListResponse)
async def list_stories(
    user: CurrentUser,
    db: DBSession,
    page: Annotated[int, Query(ge=1)] = 1,
    page_size: Annotated[int, Query(ge=1, le=50)] = 20,
) -> StoryListResponse:
    """List user's stories with pagination."""
    offset = (page - 1) * page_size

    # Get total count
    count_result = await db.execute(
        select(func.count()).select_from(Story).where(Story.user_id == user.id)
    )
    total = count_result.scalar()

    # Get stories
    result = await db.execute(
        select(Story)
        .where(Story.user_id == user.id)
        .order_by(Story.created_at.desc())
        .offset(offset)
        .limit(page_size)
    )
    stories = result.scalars().all()

    return StoryListResponse(
        stories=[StoryResponse.model_validate(s) for s in stories],
        total=total,
        page=page,
        page_size=page_size,
        has_more=offset + len(stories) < total,
    )


@router.get("/{story_id}", response_model=StoryResponse)
async def get_story(
    story_id: str,
    user: CurrentUser,
    db: DBSession,
) -> StoryResponse:
    """Get a specific story by ID."""
    story = await _get_user_story(db, story_id, user.id)

    # Load chapters
    result = await db.execute(
        select(StoryChapter)
        .where(StoryChapter.story_id == story.id)
        .order_by(StoryChapter.chapter_number)
    )
    chapters = result.scalars().all()

    response = StoryResponse.model_validate(story)
    response.chapters = [
        ChapterResponse(
            number=c.chapter_number,
            title=c.title,
            duration_seconds=c.duration_seconds or 0,
            start_time_seconds=c.start_time_seconds or 0,
            summary=c.summary,
        )
        for c in chapters
    ]

    return response


@router.get("/{story_id}/progress", response_model=StoryProgress)
async def get_story_progress(
    story_id: str,
    user: CurrentUser,
    db: DBSession,
) -> StoryProgress:
    """Get story generation progress."""
    story = await _get_user_story(db, story_id, user.id)

    # Calculate progress based on status
    progress_map = {
        "pending": 0,
        "analyzing": 25,
        "generating": 50,
        "synthesizing": 75,
        "complete": 100,
        "failed": 0,
    }

    steps_map = {
        "pending": [],
        "analyzing": ["Repository fetched"],
        "generating": ["Repository fetched", "Analysis complete"],
        "synthesizing": ["Repository fetched", "Analysis complete", "Script generated"],
        "complete": ["Repository fetched", "Analysis complete", "Script generated", "Audio synthesized"],
        "failed": [],
    }

    return StoryProgress(
        story_id=str(story.id),
        status=story.status,
        progress_percent=progress_map.get(story.status, 0),
        current_step=story.status.replace("_", " ").title(),
        steps_completed=steps_map.get(story.status, []),
    )


@router.delete("/{story_id}")
async def delete_story(
    story_id: str,
    user: CurrentUser,
    db: DBSession,
) -> dict:
    """Delete a story."""
    story = await _get_user_story(db, story_id, user.id)

    await db.delete(story)
    await db.commit()

    return {"message": "Story deleted successfully"}


async def _get_user_story(db: DBSession, story_id: str, user_id: UUID) -> Story:
    """Get story and verify ownership."""
    try:
        story_uuid = UUID(story_id)
    except ValueError:
        raise NotFoundError("Story", story_id)

    story = await db.get(Story, story_uuid)

    if not story:
        raise NotFoundError("Story", story_id)

    if story.user_id != user_id:
        raise ForbiddenError("You don't have access to this story")

    return story


def _extract_repo_name(url: str) -> str:
    """Extract repository name from URL."""
    parts = url.rstrip("/").split("/")
    return parts[-1] if parts else "Repository"
```
  </action>
  <verify>python -c "from src.codestory.backend.api.routers.stories import router; print('Stories router OK')"</verify>
  <done>Stories router created with SDK integration</done>
</task>

</tasks>

<playwright_validation_gate>
```
# Create story (triggers SDK pipeline)
Playwright Action: HTTP POST /api/stories
Headers: Authorization: Bearer {token}
Body: {"repository_url": "https://github.com/owner/repo", "style": "documentary"}
Expected: 200 OK with story_id and status "pending"

# List stories
Playwright Action: HTTP GET /api/stories
Headers: Authorization: Bearer {token}
Expected: 200 OK with stories array

# Get story
Playwright Action: HTTP GET /api/stories/{story_id}
Expected: 200 OK with full story details

# Get progress (shows SDK pipeline status)
Playwright Action: HTTP GET /api/stories/{story_id}/progress
Expected: 200 OK with status and progress_percent
```
</playwright_validation_gate>
