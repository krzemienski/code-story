---
phase: 06-fastapi-backend
plan: 05
type: execute
domain: python-api
---

<objective>
Implement SDK hooks module for progress event emission and tool validation, enabling SSE streaming from Claude Agent SDK pipeline execution.
</objective>

<context>
@BRIEF.md
@src/codestory/backend/sdk/hooks.py
@src/codestory/backend/api/routers/sse.py
</context>

<reasoning_guidance>
This plan creates the hooks system that bridges Claude Agent SDK tool execution with SSE progress streaming.

**Hook Architecture:**
- PreToolUse hooks validate tool inputs before execution
- PostToolUse hooks emit progress events after tool completion
- Callbacks registered per-story enable SSE streaming to connected clients

**Event Flow:**
1. SDK executes tool (e.g., mcp__codestory__update_progress)
2. PostToolUse hook fires with tool result
3. Hook looks up registered SSE callbacks for story_id
4. Callbacks receive event and push to asyncio.Queue
5. SSE endpoint streams from queue to client

**Thread Safety:**
- Use asyncio-safe data structures (asyncio.Queue, dict with locks)
- Callbacks are async functions to avoid blocking
- Pending events cached for late-connecting clients
</reasoning_guidance>

<tasks>

<task type="auto">
  <n>Task 1: Create SDK hooks with SSE callback integration</n>
  <files>src/codestory/backend/sdk/hooks.py</files>
  <action>
Create hooks module with callback registry:

```python
"""SDK hooks for Code Story API - Bridges SDK execution with SSE streaming."""

import asyncio
import logging
from collections import defaultdict
from datetime import datetime
from typing import Any, Callable, Awaitable

logger = logging.getLogger(__name__)

# Type for SSE callbacks
SSECallback = Callable[[dict], Awaitable[None]]

# Registry: story_id -> list of callbacks
_sse_callbacks: dict[str, list[SSECallback]] = defaultdict(list)

# Pending events cache for late-connecting clients (story_id -> list of events)
_pending_events: dict[str, list[dict]] = defaultdict(list)
_pending_events_max = 50  # Keep last 50 events per story


def register_sse_callback(story_id: str, callback: SSECallback) -> None:
    """Register a callback to receive SSE events for a story."""
    _sse_callbacks[story_id].append(callback)
    logger.debug(f"Registered SSE callback for story: {story_id}")


def unregister_sse_callback(story_id: str, callback: SSECallback) -> None:
    """Remove a callback from the registry."""
    if callback in _sse_callbacks[story_id]:
        _sse_callbacks[story_id].remove(callback)
        logger.debug(f"Unregistered SSE callback for story: {story_id}")

    # Cleanup empty lists
    if not _sse_callbacks[story_id]:
        del _sse_callbacks[story_id]


def get_pending_events(story_id: str) -> list[dict]:
    """Get pending events for a story (for late-connecting clients)."""
    return list(_pending_events.get(story_id, []))


def clear_pending_events(story_id: str) -> None:
    """Clear pending events after story completes."""
    if story_id in _pending_events:
        del _pending_events[story_id]


async def _emit_event(story_id: str, event: dict) -> None:
    """Emit event to all registered callbacks and cache for pending."""
    # Add timestamp
    event["timestamp"] = datetime.utcnow().isoformat()
    event["story_id"] = story_id

    # Cache for late connectors
    _pending_events[story_id].append(event)
    if len(_pending_events[story_id]) > _pending_events_max:
        _pending_events[story_id] = _pending_events[story_id][-_pending_events_max:]

    # Notify all callbacks
    callbacks = _sse_callbacks.get(story_id, [])
    for callback in callbacks:
        try:
            await callback(event)
        except Exception as e:
            logger.warning(f"SSE callback error for story {story_id}: {e}")


async def validate_tool_request(
    input_data: dict,
    tool_use_id: str,
    context: dict,
) -> dict:
    """
    PreToolUse hook: Validate tool inputs before execution.

    Returns empty dict to allow, or hookSpecificOutput with deny to block.
    """
    tool_name = input_data.get("tool_name", "")
    tool_input = input_data.get("tool_input", {})

    # Validate mcp__codestory tools
    if tool_name.startswith("mcp__codestory__"):
        story_id = tool_input.get("story_id")

        if not story_id:
            logger.warning(f"Tool {tool_name} missing story_id")
            # Allow but log - some tools may not need story_id

    # Block dangerous bash commands if any slip through
    if tool_name == "Bash":
        command = tool_input.get("command", "")
        dangerous = ["rm -rf /", "dd if=", "> /dev/"]

        for pattern in dangerous:
            if pattern in command:
                return {
                    "hookSpecificOutput": {
                        "hookEventName": "PreToolUse",
                        "permissionDecision": "deny",
                        "permissionDecisionReason": f"Blocked dangerous command: {pattern}"
                    }
                }

    return {}


async def emit_progress_event(
    input_data: dict,
    tool_use_id: str,
    context: dict,
) -> dict:
    """
    PostToolUse hook: Emit SSE events based on tool results.

    Converts SDK tool completions into progress events for SSE streaming.
    """
    tool_name = input_data.get("tool_name", "")
    tool_input = input_data.get("tool_input", {})
    tool_response = input_data.get("tool_response", "")

    # Handle update_progress tool
    if tool_name == "mcp__codestory__update_progress":
        story_id = tool_input.get("story_id")
        status = tool_input.get("status")
        progress = tool_input.get("progress_percent", 0)
        step = tool_input.get("current_step", "")

        if story_id:
            await _emit_event(story_id, {
                "status": status,
                "progress_percent": progress,
                "current_step": step,
            })

    # Handle analyze_repository completion
    elif tool_name == "mcp__codestory__analyze_repository":
        story_id = tool_input.get("story_id")
        if story_id:
            await _emit_event(story_id, {
                "status": "analyzing",
                "progress_percent": 30,
                "current_step": "Repository analysis complete",
            })

    # Handle generate_script completion
    elif tool_name == "mcp__codestory__generate_script":
        story_id = tool_input.get("story_id")
        if story_id:
            await _emit_event(story_id, {
                "status": "generating",
                "progress_percent": 60,
                "current_step": "Script generation complete",
            })

    # Handle synthesize_audio completion
    elif tool_name == "mcp__codestory__synthesize_audio":
        story_id = tool_input.get("story_id")
        if story_id:
            await _emit_event(story_id, {
                "status": "synthesizing",
                "progress_percent": 90,
                "current_step": "Audio synthesis complete",
            })

    return {}


async def log_tool_execution(
    input_data: dict,
    tool_use_id: str,
    context: dict,
) -> dict:
    """
    PostToolUse hook: Log tool executions for debugging/auditing.
    """
    tool_name = input_data.get("tool_name", "")
    tool_input = input_data.get("tool_input", {})

    # Truncate large inputs for logging
    input_str = str(tool_input)[:200]

    logger.info(f"[SDK] Tool executed: {tool_name} | Input: {input_str}")

    return {}


# Hook configuration for ClaudeAgentOptions
def get_hook_config() -> dict:
    """
    Get hook configuration for SDK client options.

    Returns dict compatible with ClaudeAgentOptions.hooks
    """
    from claude_agent_sdk import HookMatcher

    return {
        "PreToolUse": [
            HookMatcher(matcher="*", hooks=[validate_tool_request]),
        ],
        "PostToolUse": [
            HookMatcher(matcher="mcp__codestory__*", hooks=[emit_progress_event]),
            HookMatcher(matcher="*", hooks=[log_tool_execution]),
        ],
    }
```
  </action>
  <verify>python -c "from src.codestory.backend.sdk.hooks import get_hook_config, register_sse_callback; print('SDK hooks OK')"</verify>
  <done>SDK hooks with SSE integration created</done>
</task>

<task type="auto">
  <n>Task 2: Create progress event models</n>
  <files>src/codestory/backend/sdk/events.py</files>
  <action>
Create event models for type safety:

```python
"""Progress event models for SDK hooks."""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any


class StoryStatus(str, Enum):
    """Story generation status."""

    PENDING = "pending"
    ANALYZING = "analyzing"
    GENERATING = "generating"
    SYNTHESIZING = "synthesizing"
    COMPLETE = "complete"
    FAILED = "failed"


@dataclass
class ProgressEvent:
    """Progress event emitted by SDK hooks."""

    story_id: str
    status: StoryStatus
    progress_percent: int = 0
    current_step: str = ""
    timestamp: datetime = field(default_factory=datetime.utcnow)
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict:
        """Convert to dict for SSE serialization."""
        return {
            "story_id": self.story_id,
            "status": self.status.value,
            "progress_percent": self.progress_percent,
            "current_step": self.current_step,
            "timestamp": self.timestamp.isoformat(),
            **self.metadata,
        }


@dataclass
class CompletionEvent(ProgressEvent):
    """Story completion event."""

    audio_url: str | None = None
    duration_seconds: float | None = None
    chapter_count: int = 0

    def __post_init__(self):
        self.status = StoryStatus.COMPLETE
        self.progress_percent = 100
        self.current_step = "Story complete"

    def to_dict(self) -> dict:
        """Convert to dict for SSE serialization."""
        base = super().to_dict()
        base.update({
            "audio_url": self.audio_url,
            "duration_seconds": self.duration_seconds,
            "chapter_count": self.chapter_count,
        })
        return base


@dataclass
class ErrorEvent(ProgressEvent):
    """Story error event."""

    error_message: str = ""
    error_code: str = ""
    recoverable: bool = False

    def __post_init__(self):
        self.status = StoryStatus.FAILED
        self.current_step = "Error occurred"

    def to_dict(self) -> dict:
        """Convert to dict for SSE serialization."""
        base = super().to_dict()
        base.update({
            "error": self.error_message,
            "error_code": self.error_code,
            "recoverable": self.recoverable,
        })
        return base


# Progress percentages for each stage
STAGE_PROGRESS = {
    StoryStatus.PENDING: 0,
    StoryStatus.ANALYZING: 25,
    StoryStatus.GENERATING: 50,
    StoryStatus.SYNTHESIZING: 75,
    StoryStatus.COMPLETE: 100,
    StoryStatus.FAILED: 0,
}


def create_stage_event(story_id: str, status: StoryStatus, step: str = "") -> ProgressEvent:
    """Create a progress event for a pipeline stage."""
    return ProgressEvent(
        story_id=story_id,
        status=status,
        progress_percent=STAGE_PROGRESS.get(status, 0),
        current_step=step or status.value.title(),
    )
```
  </action>
  <verify>python -c "from src.codestory.backend.sdk.events import ProgressEvent, CompletionEvent; print('Events OK')"</verify>
  <done>Progress event models created</done>
</task>

</tasks>

<playwright_validation_gate>
```
# Hook registration test
Python: register_sse_callback("test-story", async_callback)
Expected: Callback added to registry

# Event emission test
Python: await _emit_event("test-story", {"status": "analyzing", "progress_percent": 25})
Expected: Callback receives event with timestamp

# Pending events retrieval
Python: get_pending_events("test-story")
Expected: Returns cached events for late connectors

# Hook config creation
Python: get_hook_config()
Expected: Returns dict with PreToolUse and PostToolUse HookMatchers
```
</playwright_validation_gate>
