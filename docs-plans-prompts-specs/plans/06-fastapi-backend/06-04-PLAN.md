---
phase: 06-fastapi-backend
plan: 04
type: execute
domain: python-api
---

<objective>
Implement SSE (Server-Sent Events) endpoint for real-time story generation progress using Claude Agent SDK hooks.
</objective>

<context>
@BRIEF.md
@src/codestory/backend/sdk/hooks.py
@src/codestory/backend/api/deps.py
</context>

<reasoning_guidance>
SSE provides a simpler alternative to WebSockets for server-to-client streaming.
The Claude Agent SDK hooks emit progress events during pipeline execution.
This plan creates the SSE endpoint that consumes those events.

**SSE vs WebSocket Trade-offs:**
- SSE: Simpler, unidirectional, built-in reconnection, HTTP/2 compatible
- WebSocket: Bidirectional, more complex, better for chat-like interactions
- Recommendation: SSE for progress updates (server-to-client only)

**Integration with SDK Hooks:**
- PostToolUse hook captures tool completions
- Events are queued per story_id
- SSE endpoint streams queued events to connected clients
</reasoning_guidance>

<tasks>

<task type="auto">
  <n>Task 1: Create SSE router with SDK hook integration</n>
  <files>src/codestory/backend/api/routers/sse.py</files>
  <action>
Create SSE endpoint that streams events from SDK hooks:

```python
"""SSE router for Code Story API - Real-time progress via Claude Agent SDK hooks."""

import asyncio
import json
import logging
from typing import AsyncGenerator
from uuid import UUID

from fastapi import APIRouter, Query
from fastapi.responses import StreamingResponse
from sqlalchemy import select

from src.codestory.backend.api.deps import CurrentUser, DBSession
from src.codestory.backend.api.exceptions import NotFoundError, ForbiddenError
from src.codestory.backend.models.story import Story
from src.codestory.backend.core.security import decode_jwt_token
from src.codestory.backend.sdk.hooks import (
    register_sse_callback,
    unregister_sse_callback,
    get_pending_events,
)

logger = logging.getLogger(__name__)
router = APIRouter()


@router.get("/stories/{story_id}/progress")
async def story_progress_sse(
    story_id: str,
    token: str = Query(..., description="JWT token for authentication"),
) -> StreamingResponse:
    """
    SSE endpoint for real-time story generation progress.

    Connect: GET /api/sse/stories/{story_id}/progress?token={jwt_token}

    Event format:
    ```
    event: progress
    data: {"story_id": "...", "status": "analyzing", "progress_percent": 25, "current_step": "..."}

    event: complete
    data: {"story_id": "...", "status": "complete", "audio_url": "..."}

    event: error
    data: {"story_id": "...", "error": "..."}
    ```

    The SSE stream is powered by Claude Agent SDK PostToolUse hooks that emit
    events as the pipeline progresses through analyze -> generate -> synthesize.
    """
    # Validate token
    payload = decode_jwt_token(token)
    if not payload:
        return StreamingResponse(
            _error_stream("Invalid or expired token"),
            media_type="text/event-stream",
        )

    user_id = payload.get("sub")
    if not user_id:
        return StreamingResponse(
            _error_stream("Invalid token payload"),
            media_type="text/event-stream",
        )

    # Validate story access (we need a sync DB check here)
    # For SSE, we'll validate on first event or use cached validation
    try:
        story_uuid = UUID(story_id)
        user_uuid = UUID(user_id)
    except ValueError:
        return StreamingResponse(
            _error_stream("Invalid story_id or user_id format"),
            media_type="text/event-stream",
        )

    return StreamingResponse(
        _event_generator(story_id, str(user_uuid)),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no",  # Disable nginx buffering
        },
    )


async def _event_generator(story_id: str, user_id: str) -> AsyncGenerator[str, None]:
    """
    Generate SSE events for story progress.

    Integrates with Claude Agent SDK hooks via callback registration.
    """
    event_queue: asyncio.Queue = asyncio.Queue()

    # Callback to receive events from SDK hooks
    async def on_event(event: dict):
        await event_queue.put(event)

    # Register callback with SDK hooks system
    register_sse_callback(story_id, on_event)

    try:
        # Send initial connection event
        yield _format_sse_event("connected", {
            "story_id": story_id,
            "message": "Connected to progress stream"
        })

        # Send any pending events (from before connection)
        pending = get_pending_events(story_id)
        for event in pending:
            yield _format_sse_event("progress", event)

        # Stream events as they arrive from SDK hooks
        while True:
            try:
                # Wait for event with timeout (for keepalive)
                event = await asyncio.wait_for(
                    event_queue.get(),
                    timeout=30.0
                )

                # Determine event type
                status = event.get("status", "")
                if status == "complete":
                    yield _format_sse_event("complete", event)
                    break  # Stream complete
                elif status == "failed" or "error" in event:
                    yield _format_sse_event("error", event)
                    break  # Stream ended with error
                else:
                    yield _format_sse_event("progress", event)

            except asyncio.TimeoutError:
                # Send keepalive ping
                yield _format_sse_event("ping", {"timestamp": "keepalive"})

    except asyncio.CancelledError:
        logger.info(f"SSE stream cancelled for story: {story_id}")
    except Exception as e:
        logger.exception(f"SSE stream error for story {story_id}: {e}")
        yield _format_sse_event("error", {"error": str(e)})
    finally:
        # Unregister callback
        unregister_sse_callback(story_id, on_event)


def _format_sse_event(event_type: str, data: dict) -> str:
    """Format data as SSE event."""
    return f"event: {event_type}\ndata: {json.dumps(data)}\n\n"


async def _error_stream(message: str) -> AsyncGenerator[str, None]:
    """Generate single error event stream."""
    yield _format_sse_event("error", {"error": message})


@router.get("/user/stories")
async def user_stories_sse(
    token: str = Query(..., description="JWT token for authentication"),
) -> StreamingResponse:
    """
    SSE endpoint for all user's story updates.

    Useful for dashboard real-time updates across all stories.
    """
    # Validate token
    payload = decode_jwt_token(token)
    if not payload:
        return StreamingResponse(
            _error_stream("Invalid or expired token"),
            media_type="text/event-stream",
        )

    user_id = payload.get("sub")

    return StreamingResponse(
        _user_stories_generator(user_id),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
        },
    )


async def _user_stories_generator(user_id: str) -> AsyncGenerator[str, None]:
    """Generate SSE events for all user stories."""
    from src.codestory.backend.core.database import async_session_factory

    event_queue: asyncio.Queue = asyncio.Queue()
    story_ids: list[str] = []

    async def on_event(event: dict):
        await event_queue.put(event)

    try:
        # Get user's active stories
        async with async_session_factory() as db:
            result = await db.execute(
                select(Story.id).where(
                    Story.user_id == UUID(user_id),
                    Story.status.in_(["pending", "analyzing", "generating", "synthesizing"])
                )
            )
            story_ids = [str(row[0]) for row in result.all()]

        # Register for all active stories
        for story_id in story_ids:
            register_sse_callback(story_id, on_event)

        # Send connection event
        yield _format_sse_event("connected", {
            "user_id": user_id,
            "active_stories": story_ids
        })

        # Stream events
        while True:
            try:
                event = await asyncio.wait_for(
                    event_queue.get(),
                    timeout=30.0
                )
                yield _format_sse_event("progress", event)
            except asyncio.TimeoutError:
                yield _format_sse_event("ping", {"timestamp": "keepalive"})

    except asyncio.CancelledError:
        logger.info(f"User stories SSE cancelled for user: {user_id}")
    finally:
        # Cleanup callbacks
        for story_id in story_ids:
            unregister_sse_callback(story_id, on_event)
```
  </action>
  <verify>python -c "from src.codestory.backend.api.routers.sse import router; print('SSE router OK')"</verify>
  <done>SSE router created with SDK hook integration</done>
</task>

<task type="auto">
  <n>Task 2: Create SSE client utilities</n>
  <files>src/codestory/backend/api/sse_utils.py</files>
  <action>
Create utilities for SSE event formatting and testing:

```python
"""SSE utilities for Code Story API."""

import json
from typing import Any
from dataclasses import dataclass
from datetime import datetime


@dataclass
class SSEEvent:
    """Server-Sent Event structure."""

    event: str
    data: dict[str, Any]
    id: str | None = None
    retry: int | None = None

    def format(self) -> str:
        """Format as SSE wire protocol."""
        lines = []

        if self.id:
            lines.append(f"id: {self.id}")

        if self.retry:
            lines.append(f"retry: {self.retry}")

        lines.append(f"event: {self.event}")
        lines.append(f"data: {json.dumps(self.data)}")

        return "\n".join(lines) + "\n\n"


class ProgressEventBuilder:
    """Build progress events for story generation pipeline."""

    @staticmethod
    def analyzing(story_id: str, progress: int = 25) -> SSEEvent:
        """Create analyzing progress event."""
        return SSEEvent(
            event="progress",
            data={
                "story_id": story_id,
                "status": "analyzing",
                "progress_percent": progress,
                "current_step": "Analyzing repository structure",
                "timestamp": datetime.utcnow().isoformat(),
            }
        )

    @staticmethod
    def generating(story_id: str, progress: int = 50) -> SSEEvent:
        """Create generating progress event."""
        return SSEEvent(
            event="progress",
            data={
                "story_id": story_id,
                "status": "generating",
                "progress_percent": progress,
                "current_step": "Generating narrative script",
                "timestamp": datetime.utcnow().isoformat(),
            }
        )

    @staticmethod
    def synthesizing(story_id: str, progress: int = 75) -> SSEEvent:
        """Create synthesizing progress event."""
        return SSEEvent(
            event="progress",
            data={
                "story_id": story_id,
                "status": "synthesizing",
                "progress_percent": progress,
                "current_step": "Synthesizing audio",
                "timestamp": datetime.utcnow().isoformat(),
            }
        )

    @staticmethod
    def complete(story_id: str, audio_url: str | None = None) -> SSEEvent:
        """Create completion event."""
        return SSEEvent(
            event="complete",
            data={
                "story_id": story_id,
                "status": "complete",
                "progress_percent": 100,
                "current_step": "Complete",
                "audio_url": audio_url,
                "timestamp": datetime.utcnow().isoformat(),
            }
        )

    @staticmethod
    def error(story_id: str, error_message: str) -> SSEEvent:
        """Create error event."""
        return SSEEvent(
            event="error",
            data={
                "story_id": story_id,
                "status": "failed",
                "error": error_message,
                "timestamp": datetime.utcnow().isoformat(),
            }
        )

    @staticmethod
    def ping() -> SSEEvent:
        """Create keepalive ping event."""
        return SSEEvent(
            event="ping",
            data={"timestamp": datetime.utcnow().isoformat()}
        )


def parse_sse_stream(stream: str) -> list[SSEEvent]:
    """
    Parse SSE stream into events (for testing).

    Args:
        stream: Raw SSE stream text

    Returns:
        List of parsed SSEEvent objects
    """
    events = []
    current_event = None
    current_data = None

    for line in stream.split("\n"):
        line = line.strip()

        if not line:
            # Empty line = event boundary
            if current_event and current_data:
                events.append(SSEEvent(
                    event=current_event,
                    data=json.loads(current_data)
                ))
            current_event = None
            current_data = None
            continue

        if line.startswith("event:"):
            current_event = line[6:].strip()
        elif line.startswith("data:"):
            current_data = line[5:].strip()

    return events
```
  </action>
  <verify>python -c "from src.codestory.backend.api.sse_utils import SSEEvent, ProgressEventBuilder; print('SSE utils OK')"</verify>
  <done>SSE utilities created</done>
</task>

</tasks>

<playwright_validation_gate>
```
# SSE connection test
Playwright Action: Connect EventSource to /api/sse/stories/{story_id}/progress?token={jwt}
Expected: Connection established, receive "connected" event

# Progress events received
Wait: For "progress" event
Expected: JSON with status, progress_percent, current_step

# Complete event received
Wait: For "complete" event
Expected: JSON with status="complete", audio_url

# Keepalive ping (after 30s idle)
Wait: 35 seconds
Expected: Receive "ping" event
```
</playwright_validation_gate>
