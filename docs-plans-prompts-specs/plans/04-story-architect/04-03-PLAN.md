# Plan 04-03: Story Architect Agent Assembly

## Overview

**Phase**: 4 - Story Architect Agent
**Plan**: 03 of 05
**Depends on**: 04-01 (Narrative Styles), 04-02 (Chapter Scripts)
**Enables**: 04-04 (Transitions), 04-05 (Script Assembly)

## Goal

Assemble the Story Architect Agent using Claude Agent SDK's `AgentDefinition` pattern, integrating style selection and chapter orchestration MCP tools.

## Claude Agent SDK Pattern

The Story Architect Agent uses `AgentDefinition` for pipeline integration:

```python
from claude_agent_sdk import AgentDefinition

AgentDefinition(
    description="Creates narrative scripts from repository analysis",
    prompt=STORY_ARCHITECT_PROMPT,
    tools=["mcp__architect__*"],
    model="sonnet",  # Creative narrative generation
)
```

## Tasks

### Task 1: Create Story Architect MCP Tools

**File**: `src/codestory/agents/tools/story/architect.py`

```python
"""Story Architect tools using Claude Agent SDK @tool decorator."""

import json
from typing import Any

from claude_agent_sdk import tool

from codestory.agents.tools.story.styles import STYLE_DEFINITIONS, NarrativeStyle
from codestory.agents.tools.story.chapters import generate_chapter_script


# Intent to style mapping
INTENT_STYLE_MAP = {
    "general_onboarding": "tutorial",
    "architecture_understanding": "documentary",
    "code_review_preparation": "technical",
    "feature_exploration": "documentary",
    "debugging_context": "tutorial",
    "api_documentation": "technical",
    "team_knowledge_sharing": "podcast",
    "learning_patterns": "documentary",
    "project_history": "fiction",
}


@tool(
    name="select_narrative_style",
    description="Select the best narrative style based on user intent and preferences",
    input_schema={
        "type": "object",
        "properties": {
            "intent_category": {
                "type": "string",
                "description": "User intent category from Intent Agent",
            },
            "user_preference": {
                "type": "string",
                "description": "User's explicit style preference if any",
                "enum": ["fiction", "documentary", "tutorial", "podcast", "technical", ""],
            },
            "expertise_level": {
                "type": "string",
                "description": "User's expertise level",
                "enum": ["beginner", "intermediate", "expert"],
            },
        },
        "required": ["intent_category"],
    },
)
async def select_narrative_style(args: dict) -> dict:
    """Select narrative style based on user intent."""
    intent_category = args.get("intent_category", "general_onboarding")
    user_preference = args.get("user_preference", "")
    expertise_level = args.get("expertise_level", "intermediate")

    # User preference takes priority
    if user_preference and user_preference in STYLE_DEFINITIONS:
        selected_style = user_preference
    else:
        # Map intent to style
        selected_style = INTENT_STYLE_MAP.get(intent_category, "documentary")

    style_def = STYLE_DEFINITIONS.get(selected_style)

    # Adjust for expertise level
    expertise_notes = {
        "beginner": "Use simpler vocabulary, more explanations, slower pacing",
        "intermediate": "Balance detail with accessibility",
        "expert": "Can use technical jargon, focus on advanced concepts",
    }

    result = {
        "selected_style": selected_style,
        "style_name": style_def.name if style_def else selected_style.title(),
        "voice_character": style_def.voice_character if style_def else "",
        "pacing": style_def.pacing if style_def else "moderate",
        "tone": style_def.tone if style_def else "informative",
        "expertise_level": expertise_level,
        "expertise_guidance": expertise_notes.get(expertise_level, ""),
        "chapter_pattern": style_def.chapter_pattern if style_def else [],
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


@tool(
    name="generate_story_outline",
    description="Generate a complete story outline with chapters based on analysis and style",
    input_schema={
        "type": "object",
        "properties": {
            "analysis": {
                "type": "object",
                "description": "Repository analysis from Repo Analyzer Agent",
            },
            "style": {
                "type": "string",
                "description": "Selected narrative style",
            },
            "expertise_level": {
                "type": "string",
                "description": "Target expertise level",
            },
            "focus_areas": {
                "type": "array",
                "items": {"type": "string"},
                "description": "Specific areas to focus on",
            },
            "max_chapters": {
                "type": "integer",
                "description": "Maximum number of chapters",
                "default": 6,
            },
        },
        "required": ["analysis", "style"],
    },
)
async def generate_story_outline(args: dict) -> dict:
    """Generate story outline with chapter structure."""
    analysis = args.get("analysis", {})
    style = args.get("style", "documentary")
    expertise_level = args.get("expertise_level", "intermediate")
    focus_areas = args.get("focus_areas", [])
    max_chapters = args.get("max_chapters", 6)

    # Get style definition
    style_def = STYLE_DEFINITIONS.get(style)
    if not style_def:
        return {"content": [{"type": "text", "text": json.dumps({
            "error": f"Unknown style: {style}"
        })}]}

    # Get chapter pattern for style
    chapter_pattern = style_def.chapter_pattern[:max_chapters]

    # Extract key components from analysis
    repo_name = analysis.get("name", "Repository")
    components = analysis.get("key_components", [])
    architecture = analysis.get("architecture_pattern", "")

    # Build chapters based on pattern and analysis
    chapters = []
    for i, chapter_template in enumerate(chapter_pattern):
        chapter_type = chapter_template.get("type", "exploration")

        # Map chapter type to analysis content
        content_focus = _get_chapter_focus(
            chapter_type=chapter_type,
            components=components,
            focus_areas=focus_areas,
            chapter_index=i,
        )

        chapters.append({
            "chapter_number": i + 1,
            "title": chapter_template.get("title", f"Chapter {i + 1}"),
            "type": chapter_type,
            "description": chapter_template.get("description", ""),
            "content_focus": content_focus,
            "estimated_duration_seconds": chapter_template.get("duration_seconds", 180),
        })

    result = {
        "title": f"Code Story: {repo_name}",
        "repository": repo_name,
        "style": style,
        "expertise_level": expertise_level,
        "total_chapters": len(chapters),
        "estimated_total_duration_seconds": sum(c["estimated_duration_seconds"] for c in chapters),
        "chapters": chapters,
        "architecture_pattern": architecture,
        "focus_areas": focus_areas,
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


def _get_chapter_focus(
    chapter_type: str,
    components: list,
    focus_areas: list,
    chapter_index: int,
) -> dict:
    """Determine content focus for a chapter based on type and available content."""
    focus = {
        "type": chapter_type,
        "components": [],
        "topics": [],
    }

    if chapter_type == "introduction":
        focus["topics"] = ["project overview", "purpose", "getting started"]
    elif chapter_type == "architecture":
        focus["topics"] = ["structure", "patterns", "dependencies"]
        focus["components"] = [c for c in components if c.get("type") in ["module", "package"]][:3]
    elif chapter_type == "exploration":
        # Distribute components across exploration chapters
        start_idx = chapter_index * 2
        focus["components"] = components[start_idx:start_idx + 2]
        focus["topics"] = focus_areas[:2] if focus_areas else ["key functionality"]
    elif chapter_type == "deep_dive":
        focus["topics"] = ["implementation details", "patterns used"]
        focus["components"] = [c for c in components if c.get("importance_score", 0) > 0.7][:2]
    elif chapter_type == "conclusion":
        focus["topics"] = ["summary", "next steps", "resources"]

    return focus


@tool(
    name="orchestrate_story_creation",
    description="Orchestrate the complete story creation process from analysis to script",
    input_schema={
        "type": "object",
        "properties": {
            "analysis": {
                "type": "object",
                "description": "Repository analysis from Repo Analyzer Agent",
            },
            "intent": {
                "type": "object",
                "description": "User intent from Intent Agent",
            },
            "style_override": {
                "type": "string",
                "description": "Override style selection",
            },
        },
        "required": ["analysis", "intent"],
    },
)
async def orchestrate_story_creation(args: dict) -> dict:
    """Orchestrate complete story creation process."""
    analysis = args.get("analysis", {})
    intent = args.get("intent", {})
    style_override = args.get("style_override", "")

    # Step 1: Select style
    style_result = await select_narrative_style({
        "intent_category": intent.get("category", "general_onboarding"),
        "user_preference": style_override,
        "expertise_level": intent.get("expertise_level", "intermediate"),
    })
    style_data = json.loads(style_result["content"][0]["text"])

    # Step 2: Generate outline
    outline_result = await generate_story_outline({
        "analysis": analysis,
        "style": style_data["selected_style"],
        "expertise_level": style_data["expertise_level"],
        "focus_areas": intent.get("focus_areas", []),
    })
    outline_data = json.loads(outline_result["content"][0]["text"])

    # Step 3: Generate scripts for each chapter
    chapter_scripts = []
    for chapter in outline_data.get("chapters", []):
        script_result = await generate_chapter_script({
            "chapter_outline": chapter,
            "style": style_data["selected_style"],
            "expertise_level": style_data["expertise_level"],
            "analysis_context": analysis,
        })
        script_data = json.loads(script_result["content"][0]["text"])
        chapter_scripts.append(script_data)

    result = {
        "status": "complete",
        "style": style_data,
        "outline": outline_data,
        "chapters": chapter_scripts,
        "total_chapters": len(chapter_scripts),
        "total_estimated_duration_seconds": sum(
            c.get("duration_estimate_seconds", 0) for c in chapter_scripts
        ),
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}
```

### Task 2: Create Story Architect MCP Server

**File**: `src/codestory/agents/tools/story/server.py`

```python
"""Story Architect MCP server using Claude Agent SDK."""

from claude_agent_sdk import create_sdk_mcp_server

from codestory.agents.tools.story.styles import (
    get_style_definition,
    get_style_prompt,
    get_chapter_template,
    list_available_styles,
)
from codestory.agents.tools.story.chapters import (
    generate_chapter_script,
    estimate_script_duration,
)
from codestory.agents.tools.story.architect import (
    select_narrative_style,
    generate_story_outline,
    orchestrate_story_creation,
)


def create_architect_mcp_server():
    """Create the Story Architect MCP server with all tools."""
    return create_sdk_mcp_server(
        name="architect",
        version="1.0.0",
        tools=[
            # Style tools
            get_style_definition,
            get_style_prompt,
            get_chapter_template,
            list_available_styles,
            # Chapter tools
            generate_chapter_script,
            estimate_script_duration,
            # Orchestration tools
            select_narrative_style,
            generate_story_outline,
            orchestrate_story_creation,
        ],
    )
```

### Task 3: Create Story Architect Agent Definition

**File**: `src/codestory/agents/story_architect.py`

```python
"""Story Architect Agent using Claude Agent SDK AgentDefinition."""

from typing import Any

from claude_agent_sdk import AgentDefinition, ClaudeAgentOptions, query

from codestory.agents.tools.story.server import create_architect_mcp_server


STORY_ARCHITECT_PROMPT = """You are the Story Architect Agent for Code Story.

Your role is to transform repository analysis into engaging audio narratives.

## Your Capabilities

You have access to these MCP tools:

### Style Tools
- get_style_definition: Get full style configuration
- get_style_prompt: Get style-specific prompts
- get_chapter_template: Get chapter templates for a style
- list_available_styles: List all narrative styles

### Chapter Tools
- generate_chapter_script: Create script for a chapter
- estimate_script_duration: Calculate script timing

### Orchestration Tools
- select_narrative_style: Choose style based on intent
- generate_story_outline: Create chapter structure
- orchestrate_story_creation: Run complete story creation pipeline

## Available Styles

1. **Fiction** - Epic adventure narrative with characters
2. **Documentary** - Professional, authoritative exploration
3. **Tutorial** - Educational walkthrough with encouragement
4. **Podcast** - Casual, conversational discussion
5. **Technical** - Precise, comprehensive documentation

## Process

1. Receive analysis from Repo Analyzer Agent
2. Receive intent from Intent Agent
3. Select or confirm narrative style
4. Generate story outline with chapters
5. Create scripts for each chapter with voice markers
6. Return complete story for Voice Director

## Voice Markers

Include these markers in scripts for audio synthesis:
- [PAUSE Xs] - Pause for X seconds
- [EMPHASIS word] - Emphasize a word
- [SLOWER] - Slow down delivery
- [FASTER] - Speed up delivery

## Output Format

Return a complete story with:
- Selected style and configuration
- Chapter outline with descriptions
- Full scripts for each chapter
- Estimated total duration
- Voice direction metadata

Create engaging, coherent narratives that make code accessible and interesting."""


def create_story_architect_agent() -> AgentDefinition:
    """Create Story Architect Agent definition."""
    return AgentDefinition(
        description="Creates narrative scripts from repository analysis with style selection and chapter orchestration",
        prompt=STORY_ARCHITECT_PROMPT,
        tools=[
            # Style tools
            "mcp__architect__get_style_definition",
            "mcp__architect__get_style_prompt",
            "mcp__architect__get_chapter_template",
            "mcp__architect__list_available_styles",
            # Chapter tools
            "mcp__architect__generate_chapter_script",
            "mcp__architect__estimate_script_duration",
            # Orchestration tools
            "mcp__architect__select_narrative_style",
            "mcp__architect__generate_story_outline",
            "mcp__architect__orchestrate_story_creation",
        ],
        model="sonnet",  # Creative narrative generation
    )


async def run_architect_stage(
    analysis: dict[str, Any],
    intent: dict[str, Any],
    style_override: str | None = None,
) -> dict[str, Any]:
    """Run the Story Architect pipeline stage.

    Args:
        analysis: Repository analysis from Repo Analyzer
        intent: User intent from Intent Agent
        style_override: Optional style to use instead of auto-selection

    Returns:
        Complete story with chapters and scripts
    """
    # Build prompt
    prompt = f"""Create a Code Story narrative for this repository.

## Repository Analysis
{analysis}

## User Intent
- Category: {intent.get('category', 'general_onboarding')}
- Expertise: {intent.get('expertise_level', 'intermediate')}
- Focus Areas: {intent.get('focus_areas', [])}
- Goals: {intent.get('learning_goals', [])}
{f'- Style Override: {style_override}' if style_override else ''}

## Instructions

Use orchestrate_story_creation to generate the complete story.
This will automatically:
1. Select the best narrative style
2. Generate the chapter outline
3. Create scripts for each chapter
4. Return the assembled story

Return the complete story ready for the Voice Director."""

    # Create agent options with MCP server
    mcp_server = create_architect_mcp_server()
    agent = create_story_architect_agent()

    options = ClaudeAgentOptions(
        mcp_servers={"architect": mcp_server},
        agents={"story_architect": agent},
        allowed_tools=agent.tools,
        max_turns=10,
    )

    # Run story creation
    result_text = ""
    async for message in query(prompt=prompt, options=options):
        if hasattr(message, "content"):
            for block in message.content:
                if hasattr(block, "text"):
                    result_text = block.text

    # Parse result
    try:
        import json
        story = json.loads(result_text)
    except json.JSONDecodeError:
        story = {"raw_response": result_text}

    return {
        "story": story,
        "analysis": analysis,
        "intent": intent,
    }
```

### Task 4: Create Story Architect Tests

**File**: `tests/agents/tools/story/test_architect.py`

```python
"""Tests for Story Architect tools and agent."""

import pytest
import json
from unittest.mock import AsyncMock, patch

from codestory.agents.tools.story.architect import (
    select_narrative_style,
    generate_story_outline,
    orchestrate_story_creation,
    INTENT_STYLE_MAP,
)
from codestory.agents.story_architect import (
    create_story_architect_agent,
    run_architect_stage,
)


@pytest.mark.asyncio
async def test_select_narrative_style_from_intent():
    """Test style selection from intent category."""
    result = await select_narrative_style({
        "intent_category": "architecture_understanding",
        "expertise_level": "intermediate",
    })

    data = json.loads(result["content"][0]["text"])

    assert data["selected_style"] == "documentary"
    assert data["expertise_level"] == "intermediate"
    assert "expertise_guidance" in data


@pytest.mark.asyncio
async def test_select_narrative_style_user_preference():
    """Test user preference overrides intent."""
    result = await select_narrative_style({
        "intent_category": "architecture_understanding",
        "user_preference": "fiction",
        "expertise_level": "beginner",
    })

    data = json.loads(result["content"][0]["text"])

    assert data["selected_style"] == "fiction"


@pytest.mark.asyncio
async def test_generate_story_outline():
    """Test story outline generation."""
    analysis = {
        "name": "test-repo",
        "architecture_pattern": "layered",
        "key_components": [
            {"name": "api", "type": "module", "importance_score": 0.9},
            {"name": "core", "type": "module", "importance_score": 0.8},
        ],
    }

    result = await generate_story_outline({
        "analysis": analysis,
        "style": "documentary",
        "expertise_level": "intermediate",
        "focus_areas": ["api", "architecture"],
    })

    data = json.loads(result["content"][0]["text"])

    assert data["title"] == "Code Story: test-repo"
    assert data["style"] == "documentary"
    assert data["total_chapters"] > 0
    assert "chapters" in data


@pytest.mark.asyncio
async def test_generate_story_outline_unknown_style():
    """Test error handling for unknown style."""
    result = await generate_story_outline({
        "analysis": {"name": "test"},
        "style": "unknown_style",
    })

    data = json.loads(result["content"][0]["text"])

    assert "error" in data


def test_create_story_architect_agent():
    """Test agent definition creation."""
    agent = create_story_architect_agent()

    assert agent.model == "sonnet"
    assert "mcp__architect__orchestrate_story_creation" in agent.tools
    assert "mcp__architect__generate_story_outline" in agent.tools
    assert len(agent.tools) >= 9


@pytest.mark.asyncio
async def test_run_architect_stage():
    """Test story architect pipeline stage."""
    analysis = {
        "name": "test-repo",
        "key_components": [],
    }
    intent = {
        "category": "general_onboarding",
        "expertise_level": "beginner",
    }

    with patch("codestory.agents.story_architect.query") as mock_query:
        async def mock_response(*args, **kwargs):
            class MockMessage:
                content = [type("Block", (), {"text": '{"status": "complete", "chapters": []}'})()]
            yield MockMessage()

        mock_query.return_value = mock_response()

        with patch("codestory.agents.story_architect.create_architect_mcp_server"):
            result = await run_architect_stage(analysis, intent)

            assert "story" in result
            assert result["analysis"] == analysis
            assert result["intent"] == intent
```

## Files Created/Modified

| File | Action | Purpose |
|------|--------|---------|
| `src/codestory/agents/tools/story/architect.py` | Create | Orchestration tools with @tool decorator |
| `src/codestory/agents/tools/story/server.py` | Create | Combined MCP server for all story tools |
| `src/codestory/agents/story_architect.py` | Create | Agent definition and stage runner |
| `tests/agents/tools/story/test_architect.py` | Create | Story architect tests |

## Validation Criteria

1. Style selection respects user preference over intent mapping
2. Story outline generates appropriate chapters for each style
3. Orchestration tool chains style → outline → scripts correctly
4. AgentDefinition uses sonnet model for creative work
5. All tools accessible via `mcp__architect__<tool>`
6. All tests pass

## Tool Naming Convention

All tools accessed as: `mcp__architect__<tool_name>`

## Model Selection

- **Story Architect**: Uses `sonnet` model for creative narrative generation while maintaining quality

## Next Step

Ready for 04-04-PLAN.md (Chapter Transitions)
