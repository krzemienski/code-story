# Plan 04-02: Chapter Script Generation

## Overview

**Phase**: 4 - Story Architect Agent
**Plan**: 02 of 05
**Depends on**: 04-01 (Narrative Styles)
**Enables**: 04-03 (Story Agent), 04-04 (Transitions)

## Goal

Implement chapter script generation tools with pacing and voice synthesis directions. Generate chapter scripts from repository analysis using narrative styles.

## Claude Agent SDK Pattern

Uses `@tool` decorator for script generation:

```python
from claude_agent_sdk import tool, create_sdk_mcp_server

@tool(
    name="generate_chapter_script",
    description="Generate a chapter script from analysis",
    input_schema={...}
)
async def generate_chapter_script(args: dict) -> dict:
    ...
    return {"content": [{"type": "text", "text": json.dumps(result)}]}
```

## Tasks

### Task 1: Create Chapter Script Generation Tools

**File**: `src/codestory/tools/story/chapters.py`

```python
"""Chapter script generation for Code Story.

Uses Claude Agent SDK @tool decorator for MCP integration.
"""

import json
from dataclasses import dataclass, asdict
from typing import Any

from anthropic import Anthropic
from claude_agent_sdk import tool

from codestory.core.config import get_settings
from codestory.tools.story.styles import (
    STYLE_DEFINITIONS,
    EXPERTISE_ADJUSTMENTS,
)


@dataclass
class ChapterScript:
    """Generated chapter script."""
    chapter_number: int
    title: str
    script: str
    duration_estimate_seconds: int
    word_count: int
    voice_directions: dict[str, str]

    def to_dict(self) -> dict:
        return asdict(self)


SCRIPT_GENERATION_PROMPT = '''Generate a chapter script for a code story.

## Story Context
Repository: {repo_name}
Style: {style}
Expertise Level: {expertise}

## Repository Analysis
{analysis_summary}

## Chapter Information
Chapter {chapter_number}: {chapter_title}
Focus: {chapter_focus}

## Requirements
1. Write engaging narration in the {style} style
2. Include voice markers: [PAUSE], [EMPHASIS], [SLOWER], [FASTER]
3. Target length: {target_words} words
4. Make technical concepts accessible for {expertise} audience

## Previous Chapters Summary
{previous_summary}

Write the complete chapter script. Use voice markers naturally.'''


def _build_analysis_summary(analysis: dict) -> str:
    """Build analysis summary for script generation."""
    analysis_data = analysis.get("analysis", analysis)

    arch_patterns = analysis_data.get("architecture", {}).get("architectural_patterns", [])
    arch_pattern = arch_patterns[0].get("pattern_name", "unknown") if arch_patterns else "unknown"

    components = analysis_data.get("components", {}).get("key_components", [])
    component_names = [c.get("name", "") for c in components[:5]]

    frameworks = analysis_data.get("architecture", {}).get("framework_patterns", [])
    framework_names = [f.get("pattern_name", "") for f in frameworks[:3]]

    return f"""
Architecture: {arch_pattern}
Key Components: {', '.join(component_names) or 'N/A'}
Frameworks: {', '.join(framework_names) or 'N/A'}
Primary Language: {analysis_data.get('structure', {}).get('primary_language', 'unknown')}
"""


def _build_style_system_prompt(style: str, expertise: str) -> str:
    """Build system prompt for style and expertise."""
    definition = STYLE_DEFINITIONS.get(style, STYLE_DEFINITIONS["documentary"])
    expertise_adjustment = EXPERTISE_ADJUSTMENTS.get(expertise, EXPERTISE_ADJUSTMENTS["intermediate"])

    return f'''You are a {definition.voice_character} creating a {definition.name} style code story.

## Style: {definition.name}
{definition.description}

## Voice Characteristics
- Tone: {definition.tone}
- Pacing: {definition.pacing}

## Audience
{expertise_adjustment}

## Voice Synthesis Directions
- Emphasis: {definition.voice_directions.get("emphasis", "natural")}
- Pace: {definition.voice_directions.get("pace", "moderate")}
- Emotion: {definition.voice_directions.get("emotion", "engaged")}

Write content that captures this style authentically.'''


@tool(
    name="generate_chapter_script",
    description="Generate a single chapter script from repository analysis. Includes voice markers for synthesis and duration estimates.",
    input_schema={
        "type": "object",
        "properties": {
            "analysis": {
                "type": "object",
                "description": "Repository analysis from Repo Analyzer Agent"
            },
            "chapter_number": {
                "type": "integer",
                "minimum": 1,
                "description": "Chapter number (1-indexed)"
            },
            "chapter_title": {
                "type": "string",
                "description": "Title of the chapter"
            },
            "chapter_focus": {
                "type": "string",
                "description": "What this chapter should focus on"
            },
            "style": {
                "type": "string",
                "enum": ["fiction", "documentary", "tutorial", "podcast", "technical"],
                "default": "documentary",
                "description": "Narrative style"
            },
            "expertise": {
                "type": "string",
                "enum": ["beginner", "intermediate", "expert"],
                "default": "intermediate",
                "description": "Target audience expertise"
            },
            "target_words": {
                "type": "integer",
                "default": 500,
                "minimum": 100,
                "maximum": 2000,
                "description": "Target word count for the script"
            },
            "previous_summary": {
                "type": "string",
                "default": "",
                "description": "Summary of previous chapters for context"
            }
        },
        "required": ["analysis", "chapter_number", "chapter_title", "chapter_focus"]
    }
)
async def generate_chapter_script(args: dict) -> dict:
    """Generate a chapter script."""
    analysis = args.get("analysis", {})
    chapter_number = args.get("chapter_number", 1)
    chapter_title = args.get("chapter_title", "Chapter")
    chapter_focus = args.get("chapter_focus", "")
    style = args.get("style", "documentary").lower()
    expertise = args.get("expertise", "intermediate").lower()
    target_words = args.get("target_words", 500)
    previous_summary = args.get("previous_summary", "")

    settings = get_settings()
    client = Anthropic()

    analysis_summary = _build_analysis_summary(analysis)
    analysis_data = analysis.get("analysis", analysis)
    repo_name = (
        analysis_data.get("metadata", {}).get("repo_name") or
        analysis_data.get("name", "Repository")
    )

    prompt = SCRIPT_GENERATION_PROMPT.format(
        repo_name=repo_name,
        style=style,
        expertise=expertise,
        analysis_summary=analysis_summary,
        chapter_number=chapter_number,
        chapter_title=chapter_title,
        chapter_focus=chapter_focus,
        target_words=target_words,
        previous_summary=previous_summary or "This is the first chapter.",
    )

    system_prompt = _build_style_system_prompt(style, expertise)

    response = client.messages.create(
        model=settings.claude_model,
        max_tokens=2000,
        system=system_prompt,
        messages=[{"role": "user", "content": prompt}],
    )

    script_text = response.content[0].text
    word_count = len(script_text.split())

    # Estimate duration (~150 words per minute for narration)
    duration_seconds = int((word_count / 150) * 60)

    result = ChapterScript(
        chapter_number=chapter_number,
        title=chapter_title,
        script=script_text,
        word_count=word_count,
        duration_estimate_seconds=duration_seconds,
        voice_directions={
            "style": style,
            "expertise": expertise,
            "pacing": STYLE_DEFINITIONS.get(style, STYLE_DEFINITIONS["documentary"]).pacing,
        },
    )

    return {"content": [{"type": "text", "text": json.dumps(result.to_dict(), indent=2)}]}


@tool(
    name="generate_story_outline",
    description="Generate complete story outline with all chapters based on narrative style template. Generates scripts for each chapter sequentially.",
    input_schema={
        "type": "object",
        "properties": {
            "analysis": {
                "type": "object",
                "description": "Repository analysis from Repo Analyzer Agent"
            },
            "style": {
                "type": "string",
                "enum": ["fiction", "documentary", "tutorial", "podcast", "technical"],
                "default": "documentary",
                "description": "Narrative style"
            },
            "expertise": {
                "type": "string",
                "enum": ["beginner", "intermediate", "expert"],
                "default": "intermediate",
                "description": "Target audience expertise"
            },
            "custom_chapters": {
                "type": "array",
                "items": {"type": "string"},
                "description": "Optional custom chapter titles (overrides style template)"
            }
        },
        "required": ["analysis"]
    }
)
async def generate_story_outline(args: dict) -> dict:
    """Generate complete story with all chapters."""
    analysis = args.get("analysis", {})
    style = args.get("style", "documentary").lower()
    expertise = args.get("expertise", "intermediate").lower()
    custom_chapters = args.get("custom_chapters")

    # Get chapter template
    if custom_chapters:
        chapters = custom_chapters
    else:
        definition = STYLE_DEFINITIONS.get(style, STYLE_DEFINITIONS["documentary"])
        chapters = definition.chapter_pattern

    story_chapters = []
    previous_summary = ""
    total_words = 0
    total_duration = 0

    for i, chapter_title in enumerate(chapters, 1):
        # Extract focus from chapter title
        chapter_focus = chapter_title.split(" - ")[-1] if " - " in chapter_title else chapter_title

        chapter_result = await generate_chapter_script({
            "analysis": analysis,
            "chapter_number": i,
            "chapter_title": chapter_title,
            "chapter_focus": f"Focus on {chapter_focus}",
            "style": style,
            "expertise": expertise,
            "previous_summary": previous_summary,
        })

        chapter_data = json.loads(chapter_result["content"][0]["text"])
        story_chapters.append(chapter_data)

        total_words += chapter_data["word_count"]
        total_duration += chapter_data["duration_estimate_seconds"]

        # Build summary for next chapter
        previous_summary = f"Chapter {i} covered: {chapter_title}"

    analysis_data = analysis.get("analysis", analysis)
    repo_name = (
        analysis_data.get("metadata", {}).get("repo_name") or
        analysis_data.get("name", "Repository")
    )

    result = {
        "title": f"{repo_name} - A {style.title()} Story",
        "repo_name": repo_name,
        "style": style,
        "expertise": expertise,
        "chapters": story_chapters,
        "total_chapters": len(story_chapters),
        "total_word_count": total_words,
        "total_duration_estimate_seconds": total_duration,
        "total_duration_minutes": round(total_duration / 60, 1),
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


@tool(
    name="estimate_script_duration",
    description="Estimate audio duration for a script based on word count and style pacing.",
    input_schema={
        "type": "object",
        "properties": {
            "script": {
                "type": "string",
                "description": "The script text"
            },
            "style": {
                "type": "string",
                "enum": ["fiction", "documentary", "tutorial", "podcast", "technical"],
                "default": "documentary",
                "description": "Narrative style (affects pacing)"
            }
        },
        "required": ["script"]
    }
)
async def estimate_script_duration(args: dict) -> dict:
    """Estimate duration for a script."""
    script = args.get("script", "")
    style = args.get("style", "documentary").lower()

    word_count = len(script.split())

    # Words per minute based on style pacing
    pacing_wpm = {
        "fiction": 140,      # Moderate with dramatic pauses
        "documentary": 145,  # Moderate, contemplative
        "tutorial": 130,     # Slow, deliberate
        "podcast": 160,      # Fast, energetic
        "technical": 150,    # Moderate, clear
    }

    wpm = pacing_wpm.get(style, 150)
    duration_seconds = int((word_count / wpm) * 60)

    result = {
        "word_count": word_count,
        "style": style,
        "words_per_minute": wpm,
        "duration_seconds": duration_seconds,
        "duration_minutes": round(duration_seconds / 60, 2),
        "duration_formatted": f"{duration_seconds // 60}:{duration_seconds % 60:02d}",
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}
```

### Task 2: Create MCP Server for Chapter Tools

**File**: `src/codestory/tools/story/chapters_server.py`

```python
"""MCP server for chapter generation tools.

Uses Claude Agent SDK create_sdk_mcp_server.
"""

from claude_agent_sdk import create_sdk_mcp_server

from codestory.tools.story.chapters import (
    generate_chapter_script,
    generate_story_outline,
    estimate_script_duration,
)


def create_chapters_mcp_server():
    """Create MCP server with chapter generation tools."""
    return create_sdk_mcp_server(
        name="chapters",
        version="1.0.0",
        tools=[
            generate_chapter_script,
            generate_story_outline,
            estimate_script_duration,
        ],
    )
```

### Task 3: Update Story Package Exports

**File**: `src/codestory/tools/story/__init__.py` (update)

```python
"""Story generation tools for Code Story.

Uses Claude Agent SDK @tool decorator for MCP integration.
"""

from codestory.tools.story.styles import (
    NarrativeStyle,
    ExpertiseLevel,
    StyleDefinition,
    STYLE_DEFINITIONS,
    get_style_definition,
    get_style_prompt,
    get_chapter_template,
    list_available_styles,
)
from codestory.tools.story.styles_server import create_styles_mcp_server
from codestory.tools.story.chapters import (
    ChapterScript,
    generate_chapter_script,
    generate_story_outline,
    estimate_script_duration,
)
from codestory.tools.story.chapters_server import create_chapters_mcp_server

__all__ = [
    # Enums
    "NarrativeStyle",
    "ExpertiseLevel",
    # Types
    "StyleDefinition",
    "STYLE_DEFINITIONS",
    "ChapterScript",
    # Style Tools
    "get_style_definition",
    "get_style_prompt",
    "get_chapter_template",
    "list_available_styles",
    # Chapter Tools
    "generate_chapter_script",
    "generate_story_outline",
    "estimate_script_duration",
    # Servers
    "create_styles_mcp_server",
    "create_chapters_mcp_server",
]
```

### Task 4: Chapter Tools Tests

**File**: `tests/tools/story/test_chapters.py`

```python
"""Tests for chapter generation tools."""

import pytest
import json
from unittest.mock import AsyncMock, MagicMock, patch


@pytest.fixture
def sample_analysis():
    """Sample repository analysis."""
    return {
        "analysis": {
            "metadata": {"repo_name": "test-repo"},
            "structure": {"primary_language": "Python"},
            "architecture": {
                "architectural_patterns": [{"pattern_name": "Layered"}],
                "framework_patterns": [{"pattern_name": "FastAPI"}],
            },
            "components": {
                "key_components": [
                    {"name": "main.py"},
                    {"name": "api.py"},
                ],
            },
        }
    }


@pytest.fixture
def mock_anthropic():
    """Mock Anthropic client."""
    with patch("codestory.tools.story.chapters.Anthropic") as mock:
        client = MagicMock()
        response = MagicMock()
        response.content = [MagicMock(text="This is a sample script with [PAUSE] markers. It discusses the architecture and design patterns used.")]
        client.messages.create.return_value = response
        mock.return_value = client
        yield mock


@pytest.mark.asyncio
async def test_generate_chapter_script(sample_analysis, mock_anthropic):
    """Test generating a single chapter script."""
    from codestory.tools.story.chapters import generate_chapter_script

    result = await generate_chapter_script({
        "analysis": sample_analysis,
        "chapter_number": 1,
        "chapter_title": "Introduction",
        "chapter_focus": "Overview of the project",
        "style": "documentary",
        "expertise": "intermediate",
    })

    assert "content" in result
    data = json.loads(result["content"][0]["text"])

    assert data["chapter_number"] == 1
    assert data["title"] == "Introduction"
    assert "script" in data
    assert data["word_count"] > 0
    assert data["duration_estimate_seconds"] > 0


@pytest.mark.asyncio
async def test_generate_story_outline(sample_analysis, mock_anthropic):
    """Test generating complete story outline."""
    from codestory.tools.story.chapters import generate_story_outline

    result = await generate_story_outline({
        "analysis": sample_analysis,
        "style": "documentary",
        "expertise": "beginner",
    })

    data = json.loads(result["content"][0]["text"])

    assert "title" in data
    assert data["style"] == "documentary"
    assert data["total_chapters"] == 6  # Documentary has 6 chapters
    assert len(data["chapters"]) == 6
    assert data["total_word_count"] > 0
    assert data["total_duration_estimate_seconds"] > 0


@pytest.mark.asyncio
async def test_generate_story_outline_custom_chapters(sample_analysis, mock_anthropic):
    """Test story outline with custom chapters."""
    from codestory.tools.story.chapters import generate_story_outline

    custom_chapters = ["Setup", "Main Flow", "Conclusion"]

    result = await generate_story_outline({
        "analysis": sample_analysis,
        "style": "podcast",
        "custom_chapters": custom_chapters,
    })

    data = json.loads(result["content"][0]["text"])

    assert data["total_chapters"] == 3
    assert len(data["chapters"]) == 3


@pytest.mark.asyncio
async def test_estimate_script_duration():
    """Test script duration estimation."""
    from codestory.tools.story.chapters import estimate_script_duration

    script = " ".join(["word"] * 300)  # 300 words

    result = await estimate_script_duration({
        "script": script,
        "style": "documentary",
    })

    data = json.loads(result["content"][0]["text"])

    assert data["word_count"] == 300
    assert data["words_per_minute"] == 145  # Documentary WPM
    assert data["duration_seconds"] > 0
    assert "duration_formatted" in data


@pytest.mark.asyncio
async def test_estimate_duration_varies_by_style():
    """Test duration varies by style pacing."""
    from codestory.tools.story.chapters import estimate_script_duration

    script = " ".join(["word"] * 150)

    # Podcast should be faster
    podcast_result = await estimate_script_duration({
        "script": script,
        "style": "podcast",
    })
    podcast_data = json.loads(podcast_result["content"][0]["text"])

    # Tutorial should be slower
    tutorial_result = await estimate_script_duration({
        "script": script,
        "style": "tutorial",
    })
    tutorial_data = json.loads(tutorial_result["content"][0]["text"])

    # Tutorial should take longer than podcast
    assert tutorial_data["duration_seconds"] > podcast_data["duration_seconds"]


@pytest.mark.asyncio
async def test_chapter_script_includes_voice_directions(sample_analysis, mock_anthropic):
    """Test chapter script includes voice directions."""
    from codestory.tools.story.chapters import generate_chapter_script

    result = await generate_chapter_script({
        "analysis": sample_analysis,
        "chapter_number": 1,
        "chapter_title": "Test",
        "chapter_focus": "Testing",
        "style": "fiction",
    })

    data = json.loads(result["content"][0]["text"])

    assert "voice_directions" in data
    assert data["voice_directions"]["style"] == "fiction"
    assert "pacing" in data["voice_directions"]
```

## Files Created/Modified

| File | Action | Purpose |
|------|--------|---------|
| `src/codestory/tools/story/chapters.py` | Create | Chapter script generation tools |
| `src/codestory/tools/story/chapters_server.py` | Create | MCP server for chapter tools |
| `src/codestory/tools/story/__init__.py` | Update | Add chapter exports |
| `tests/tools/story/test_chapters.py` | Create | Chapter tools tests |

## Tool Naming Convention

When accessed via MCP, tools use the pattern: `mcp__chapters__<tool_name>`

- `mcp__chapters__generate_chapter_script`
- `mcp__chapters__generate_story_outline`
- `mcp__chapters__estimate_script_duration`

## Voice Markers

Scripts include voice markers for synthesis:
- `[PAUSE]` - Brief pause in narration
- `[EMPHASIS]` - Emphasize following word/phrase
- `[SLOWER]` - Slow down pacing
- `[FASTER]` - Speed up pacing

## Duration Estimation

Words per minute by style:
| Style | WPM | Description |
|-------|-----|-------------|
| Fiction | 140 | Moderate with dramatic pauses |
| Documentary | 145 | Moderate, contemplative |
| Tutorial | 130 | Slow, deliberate |
| Podcast | 160 | Fast, energetic |
| Technical | 150 | Moderate, clear |

## Validation Criteria

1. generate_chapter_script produces valid scripts with voice markers
2. generate_story_outline creates all chapters for selected style
3. Duration estimates vary by style pacing
4. Scripts include voice directions for synthesis
5. All tools return proper `{"content": [...]}` format

## Next Step

Ready for 04-03-PLAN.md (Story Architect Agent)
