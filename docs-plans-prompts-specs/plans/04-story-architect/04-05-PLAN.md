# Plan 04-05: Script Assembly

## Overview

**Phase**: 4 - Story Architect Agent
**Plan**: 05 of 05
**Depends on**: 04-03 (Story Agent), 04-04 (Transitions)
**Enables**: 05-01 (Voice Director Setup)

## Goal

Implement complete script assembly tools using Claude Agent SDK's `@tool` decorator pattern that combine chapters, transitions, and metadata into a final narrative script ready for voice synthesis.

## Claude Agent SDK Pattern

Script assembly tools use the `@tool` decorator:

```python
from claude_agent_sdk import tool

@tool(
    name="assemble_script",
    description="Assemble complete script from chapters",
    input_schema={...}
)
async def assemble_script(args: dict) -> dict:
    ...
    return {"content": [{"type": "text", "text": json.dumps(result)}]}
```

## Tasks

### Task 1: Create Script Assembly Tools

**File**: `src/codestory/agents/tools/story/assembly.py`

```python
"""Script assembly tools using Claude Agent SDK @tool decorator."""

import json
import re
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any

from claude_agent_sdk import tool

from codestory.agents.tools.story.transitions import (
    generate_all_transitions,
    STYLE_WPM,
)


@dataclass
class ScriptSegment:
    """A segment of the complete script."""

    segment_type: str  # "intro", "chapter", "transition", "outro"
    content: str
    chapter_number: int | None = None
    duration_estimate_seconds: float = 0
    voice_direction: dict[str, Any] = field(default_factory=dict)


@dataclass
class CompleteScript:
    """Complete assembled script ready for synthesis."""

    title: str
    repository_url: str
    style: str
    segments: list[ScriptSegment]
    total_duration_seconds: float
    total_word_count: int
    chapter_count: int
    generated_at: str
    metadata: dict[str, Any] = field(default_factory=dict)


# Intro templates by style
INTRO_TEMPLATES = {
    "fiction": "Welcome, traveler. [PAUSE 1s] Today we explore the realms of {repo_name}. [PAUSE 1s] A codebase with secrets waiting to be discovered...",
    "documentary": "Welcome to Code Story. [PAUSE 1s] Today we examine {repo_name}, [PAUSE 0.5s] exploring its architecture and design.",
    "tutorial": "Hey there! [PAUSE 0.5s] Today we're learning about {repo_name}. [PAUSE 0.5s] Let's dive in and see what makes it tick!",
    "podcast": "What's up everyone! [PAUSE 0.5s] Today we're diving into {repo_name}. [PAUSE 0.5s] This one's pretty cool, let me tell you why...",
    "technical": "Technical overview of {repo_name}. [PAUSE 1s] Beginning analysis of core components and architecture.",
}

# Outro templates by style
OUTRO_TEMPLATES = {
    "fiction": "[PAUSE 2s] And so our adventure through {repo_name} comes to a close. [PAUSE 1s] Until next time, fellow explorer...",
    "documentary": "[PAUSE 2s] This concludes our exploration of {repo_name}. [PAUSE 1s] Thank you for listening to Code Story.",
    "tutorial": "[PAUSE 2s] Great job! [PAUSE 0.5s] You've learned the key concepts of {repo_name}. [PAUSE 0.5s] Happy coding!",
    "podcast": "[PAUSE 2s] That's a wrap on {repo_name}! [PAUSE 0.5s] Thanks for tuning in. [PAUSE 0.5s] See you next time!",
    "technical": "[PAUSE 2s] End of {repo_name} technical overview. [PAUSE 1s] Summary complete.",
}


def _extract_repo_name(url: str) -> str:
    """Extract repository name from URL."""
    if not url:
        return "this repository"
    # Handle github.com/owner/repo format
    parts = url.rstrip("/").rstrip(".git").split("/")
    return parts[-1] if parts else "this repository"


def _count_words(text: str) -> int:
    """Count words in text, excluding voice markers."""
    # Remove voice direction markers like [PAUSE 2s], [EMPHASIS word]
    clean_text = re.sub(r'\[.*?\]', '', text)
    return len(clean_text.split())


def _estimate_duration(word_count: int, wpm: int = 145) -> float:
    """Estimate speaking duration in seconds."""
    return (word_count / wpm) * 60


@tool(
    name="assemble_complete_script",
    description="Assemble a complete script from chapters, adding intro, transitions, and outro",
    input_schema={
        "type": "object",
        "properties": {
            "chapters": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "chapter_number": {"type": "integer"},
                        "title": {"type": "string"},
                        "content": {"type": "string"},
                        "word_count": {"type": "integer"},
                        "duration_estimate_seconds": {"type": "number"},
                        "voice_direction": {"type": "object"},
                    },
                },
                "description": "List of chapter scripts",
            },
            "repository_url": {
                "type": "string",
                "description": "GitHub repository URL",
            },
            "style": {
                "type": "string",
                "description": "Narrative style",
                "enum": ["fiction", "documentary", "tutorial", "podcast", "technical"],
            },
            "title": {
                "type": "string",
                "description": "Optional custom title",
            },
            "include_intro": {
                "type": "boolean",
                "description": "Whether to include intro segment",
                "default": True,
            },
            "include_outro": {
                "type": "boolean",
                "description": "Whether to include outro segment",
                "default": True,
            },
        },
        "required": ["chapters", "repository_url", "style"],
    },
)
async def assemble_complete_script(args: dict) -> dict:
    """Assemble a complete script from chapter content."""
    chapters = args.get("chapters", [])
    repository_url = args.get("repository_url", "")
    style = args.get("style", "documentary")
    title = args.get("title", "")
    include_intro = args.get("include_intro", True)
    include_outro = args.get("include_outro", True)

    repo_name = _extract_repo_name(repository_url)
    wpm = STYLE_WPM.get(style, 145)

    segments = []
    total_words = 0

    # Add intro
    if include_intro:
        intro_text = INTRO_TEMPLATES.get(style, INTRO_TEMPLATES["documentary"]).format(repo_name=repo_name)
        intro_words = _count_words(intro_text)
        segments.append({
            "segment_type": "intro",
            "content": intro_text,
            "chapter_number": None,
            "duration_estimate_seconds": _estimate_duration(intro_words, wpm) + 2,  # +2s for pauses
            "voice_direction": {"pace": "slow", "emphasis": "warm"},
        })
        total_words += intro_words

    # Generate transitions
    transition_result = await generate_all_transitions({
        "chapters": chapters,
        "style": style,
    })
    transition_data = json.loads(transition_result["content"][0]["text"])
    transition_map = {t["from_chapter"]: t for t in transition_data.get("transitions", [])}

    # Add chapters with transitions
    for i, chapter in enumerate(chapters):
        chapter_num = chapter.get("chapter_number", i + 1)
        content = chapter.get("content", chapter.get("script", ""))
        word_count = chapter.get("word_count", _count_words(content))

        segments.append({
            "segment_type": "chapter",
            "content": content,
            "chapter_number": chapter_num,
            "title": chapter.get("title", f"Chapter {chapter_num}"),
            "duration_estimate_seconds": chapter.get(
                "duration_estimate_seconds",
                _estimate_duration(word_count, wpm)
            ),
            "voice_direction": chapter.get("voice_direction", {}),
        })
        total_words += word_count

        # Add transition after chapter (except last)
        if chapter_num in transition_map:
            trans = transition_map[chapter_num]
            trans_text = trans.get("transition_text", "")
            trans_words = _count_words(trans_text)
            segments.append({
                "segment_type": "transition",
                "content": trans_text,
                "chapter_number": None,
                "duration_estimate_seconds": trans.get("total_transition_seconds", 5),
                "voice_direction": {"pace": "slower"},
            })
            total_words += trans_words

    # Add outro
    if include_outro:
        outro_text = OUTRO_TEMPLATES.get(style, OUTRO_TEMPLATES["documentary"]).format(repo_name=repo_name)
        outro_words = _count_words(outro_text)
        segments.append({
            "segment_type": "outro",
            "content": outro_text,
            "chapter_number": None,
            "duration_estimate_seconds": _estimate_duration(outro_words, wpm) + 2,
            "voice_direction": {"pace": "slow", "emphasis": "warm"},
        })
        total_words += outro_words

    # Calculate totals
    total_duration = sum(s["duration_estimate_seconds"] for s in segments)

    result = {
        "title": title or f"Code Story: {repo_name}",
        "repository_url": repository_url,
        "style": style,
        "segments": segments,
        "total_segments": len(segments),
        "total_duration_seconds": total_duration,
        "total_duration_formatted": _format_duration(int(total_duration * 1000)),
        "total_word_count": total_words,
        "chapter_count": len(chapters),
        "transition_count": len([s for s in segments if s["segment_type"] == "transition"]),
        "generated_at": datetime.utcnow().isoformat(),
        "metadata": {
            "has_intro": include_intro,
            "has_outro": include_outro,
            "words_per_minute": wpm,
        },
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


def _format_duration(ms: int) -> str:
    """Format duration as MM:SS or HH:MM:SS."""
    seconds = ms // 1000
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    secs = seconds % 60

    if hours > 0:
        return f"{hours}:{minutes:02d}:{secs:02d}"
    return f"{minutes}:{secs:02d}"


@tool(
    name="get_script_for_synthesis",
    description="Extract synthesis-ready segments from an assembled script",
    input_schema={
        "type": "object",
        "properties": {
            "assembled_script": {
                "type": "object",
                "description": "Complete assembled script from assemble_complete_script",
            },
        },
        "required": ["assembled_script"],
    },
)
async def get_script_for_synthesis(args: dict) -> dict:
    """Extract synthesis-ready segments from assembled script."""
    assembled_script = args.get("assembled_script", {})

    synthesis_segments = []

    for segment in assembled_script.get("segments", []):
        voice_settings = _get_voice_settings(segment)

        synthesis_segments.append({
            "text": segment.get("content", ""),
            "segment_type": segment.get("segment_type", "chapter"),
            "chapter_number": segment.get("chapter_number"),
            "title": segment.get("title", ""),
            "duration_estimate_seconds": segment.get("duration_estimate_seconds", 0),
            "voice_settings": voice_settings,
        })

    result = {
        "title": assembled_script.get("title", "Code Story"),
        "style": assembled_script.get("style", "documentary"),
        "segments": synthesis_segments,
        "total_segments": len(synthesis_segments),
        "total_duration_seconds": assembled_script.get("total_duration_seconds", 0),
        "ready_for_synthesis": True,
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


def _get_voice_settings(segment: dict) -> dict:
    """Get ElevenLabs voice settings for segment."""
    direction = segment.get("voice_direction", {})

    # Base settings
    settings = {
        "stability": 0.5,
        "similarity_boost": 0.75,
        "style": 0.0,
        "use_speaker_boost": True,
    }

    # Adjust based on segment type
    segment_type = segment.get("segment_type", "chapter")
    if segment_type in ["intro", "outro"]:
        settings["stability"] = 0.6
    elif segment_type == "transition":
        settings["stability"] = 0.6
        settings["similarity_boost"] = 0.7

    # Adjust based on pace direction
    pace = direction.get("pace", "normal")
    if pace == "slow":
        settings["stability"] = 0.65
    elif pace == "slower":
        settings["stability"] = 0.7
    elif pace == "fast":
        settings["stability"] = 0.4

    return settings


@tool(
    name="validate_script",
    description="Validate a script is complete and ready for synthesis",
    input_schema={
        "type": "object",
        "properties": {
            "script": {
                "type": "object",
                "description": "Assembled script to validate",
            },
        },
        "required": ["script"],
    },
)
async def validate_script(args: dict) -> dict:
    """Validate script completeness and quality."""
    script = args.get("script", {})

    issues = []
    warnings = []

    # Check required fields
    if not script.get("title"):
        issues.append("Missing script title")

    if not script.get("segments"):
        issues.append("Script has no segments")
        return {"content": [{"type": "text", "text": json.dumps({
            "valid": False,
            "issues": issues,
            "warnings": warnings,
        })}]}

    segments = script.get("segments", [])

    # Check segment content
    for i, seg in enumerate(segments):
        content = seg.get("content", "")
        if not content or len(content.strip()) < 10:
            issues.append(f"Segment {i} has no or minimal content")

        # Check for unprocessed placeholders
        if "{" in content and "}" in content:
            warnings.append(f"Segment {i} may have unprocessed template placeholders")

        # Check for very long segments (>5000 chars = ElevenLabs limit)
        if len(content) > 5000:
            warnings.append(f"Segment {i} exceeds 5000 characters; may need chunking for synthesis")

    # Check chapter sequence
    chapter_segments = [s for s in segments if s.get("segment_type") == "chapter"]
    chapter_numbers = [s.get("chapter_number", 0) for s in chapter_segments]
    if chapter_numbers and chapter_numbers != list(range(1, len(chapter_numbers) + 1)):
        warnings.append("Chapter numbers are not sequential")

    # Check duration
    total_duration = script.get("total_duration_seconds", 0)
    if total_duration < 60:
        warnings.append("Script is under 1 minute; may be too short")
    elif total_duration > 1800:  # 30 minutes
        warnings.append("Script exceeds 30 minutes; consider splitting")

    result = {
        "valid": len(issues) == 0,
        "issues": issues,
        "warnings": warnings,
        "total_segments": len(segments),
        "chapter_count": len(chapter_segments),
        "total_duration_seconds": total_duration,
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


@tool(
    name="get_script_summary",
    description="Get a summary of the assembled script",
    input_schema={
        "type": "object",
        "properties": {
            "script": {
                "type": "object",
                "description": "Assembled script",
            },
        },
        "required": ["script"],
    },
)
async def get_script_summary(args: dict) -> dict:
    """Get human-readable summary of script."""
    script = args.get("script", {})

    segments = script.get("segments", [])
    chapters = [s for s in segments if s.get("segment_type") == "chapter"]

    chapter_summaries = []
    for ch in chapters:
        chapter_summaries.append({
            "number": ch.get("chapter_number"),
            "title": ch.get("title", f"Chapter {ch.get('chapter_number')}"),
            "word_count": _count_words(ch.get("content", "")),
            "duration_seconds": ch.get("duration_estimate_seconds", 0),
        })

    result = {
        "title": script.get("title", "Code Story"),
        "style": script.get("style", "documentary"),
        "repository_url": script.get("repository_url", ""),
        "total_duration_formatted": script.get("total_duration_formatted", "0:00"),
        "total_word_count": script.get("total_word_count", 0),
        "structure": {
            "has_intro": script.get("metadata", {}).get("has_intro", False),
            "has_outro": script.get("metadata", {}).get("has_outro", False),
            "chapter_count": len(chapters),
            "transition_count": script.get("transition_count", 0),
        },
        "chapters": chapter_summaries,
        "generated_at": script.get("generated_at", ""),
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}
```

### Task 2: Update MCP Server with Assembly Tools

**File**: `src/codestory/agents/tools/story/server.py` (update)

```python
"""Story Architect MCP server using Claude Agent SDK."""

from claude_agent_sdk import create_sdk_mcp_server

from codestory.agents.tools.story.styles import (
    get_style_definition,
    get_style_prompt,
    get_chapter_template,
    list_available_styles,
)
from codestory.agents.tools.story.chapters import (
    generate_chapter_script,
    estimate_script_duration,
)
from codestory.agents.tools.story.transitions import (
    generate_chapter_transition,
    generate_all_transitions,
    calculate_story_pacing,
    get_pause_durations,
)
from codestory.agents.tools.story.architect import (
    select_narrative_style,
    generate_story_outline,
    orchestrate_story_creation,
)
from codestory.agents.tools.story.assembly import (
    assemble_complete_script,
    get_script_for_synthesis,
    validate_script,
    get_script_summary,
)


def create_architect_mcp_server():
    """Create the Story Architect MCP server with all tools."""
    return create_sdk_mcp_server(
        name="architect",
        version="1.0.0",
        tools=[
            # Style tools
            get_style_definition,
            get_style_prompt,
            get_chapter_template,
            list_available_styles,
            # Chapter tools
            generate_chapter_script,
            estimate_script_duration,
            # Transition tools
            generate_chapter_transition,
            generate_all_transitions,
            calculate_story_pacing,
            get_pause_durations,
            # Orchestration tools
            select_narrative_style,
            generate_story_outline,
            orchestrate_story_creation,
            # Assembly tools
            assemble_complete_script,
            get_script_for_synthesis,
            validate_script,
            get_script_summary,
        ],
    )
```

### Task 3: Create Assembly Tests

**File**: `tests/agents/tools/story/test_assembly.py`

```python
"""Tests for script assembly tools."""

import pytest
import json

from codestory.agents.tools.story.assembly import (
    assemble_complete_script,
    get_script_for_synthesis,
    validate_script,
    get_script_summary,
    INTRO_TEMPLATES,
    OUTRO_TEMPLATES,
)


@pytest.fixture
def sample_chapters():
    """Sample chapters for testing."""
    return [
        {
            "chapter_number": 1,
            "title": "Introduction",
            "content": "Welcome to our journey through this codebase. We'll explore the architecture and key patterns.",
            "word_count": 15,
            "duration_estimate_seconds": 60,
        },
        {
            "chapter_number": 2,
            "title": "Core Architecture",
            "content": "The core architecture follows a layered pattern with clear separation of concerns.",
            "word_count": 14,
            "duration_estimate_seconds": 55,
        },
        {
            "chapter_number": 3,
            "title": "Conclusion",
            "content": "In summary, this codebase demonstrates excellent design principles.",
            "word_count": 10,
            "duration_estimate_seconds": 40,
        },
    ]


@pytest.mark.asyncio
async def test_assemble_complete_script(sample_chapters):
    """Test complete script assembly."""
    result = await assemble_complete_script({
        "chapters": sample_chapters,
        "repository_url": "https://github.com/owner/test-repo",
        "style": "documentary",
        "include_intro": True,
        "include_outro": True,
    })

    data = json.loads(result["content"][0]["text"])

    assert data["title"] == "Code Story: test-repo"
    assert data["style"] == "documentary"
    assert data["chapter_count"] == 3
    assert data["total_segments"] > 3  # chapters + intro + outro + transitions
    assert data["total_duration_seconds"] > 0

    # Check segment types
    segment_types = [s["segment_type"] for s in data["segments"]]
    assert "intro" in segment_types
    assert "outro" in segment_types
    assert "chapter" in segment_types
    assert "transition" in segment_types


@pytest.mark.asyncio
async def test_assemble_script_without_intro_outro(sample_chapters):
    """Test assembly without intro and outro."""
    result = await assemble_complete_script({
        "chapters": sample_chapters,
        "repository_url": "https://github.com/owner/repo",
        "style": "technical",
        "include_intro": False,
        "include_outro": False,
    })

    data = json.loads(result["content"][0]["text"])

    segment_types = [s["segment_type"] for s in data["segments"]]
    assert "intro" not in segment_types
    assert "outro" not in segment_types


@pytest.mark.asyncio
async def test_assemble_script_custom_title(sample_chapters):
    """Test custom title override."""
    result = await assemble_complete_script({
        "chapters": sample_chapters,
        "repository_url": "https://github.com/owner/repo",
        "style": "podcast",
        "title": "My Custom Title",
    })

    data = json.loads(result["content"][0]["text"])

    assert data["title"] == "My Custom Title"


@pytest.mark.asyncio
async def test_get_script_for_synthesis(sample_chapters):
    """Test synthesis preparation."""
    # First assemble the script
    assembled = await assemble_complete_script({
        "chapters": sample_chapters,
        "repository_url": "https://github.com/owner/repo",
        "style": "documentary",
    })
    assembled_data = json.loads(assembled["content"][0]["text"])

    # Then prepare for synthesis
    result = await get_script_for_synthesis({
        "assembled_script": assembled_data,
    })

    data = json.loads(result["content"][0]["text"])

    assert data["ready_for_synthesis"] is True
    assert len(data["segments"]) == assembled_data["total_segments"]

    # Check voice settings are present
    for seg in data["segments"]:
        assert "voice_settings" in seg
        assert "stability" in seg["voice_settings"]
        assert "similarity_boost" in seg["voice_settings"]


@pytest.mark.asyncio
async def test_validate_script_valid(sample_chapters):
    """Test validation of valid script."""
    assembled = await assemble_complete_script({
        "chapters": sample_chapters,
        "repository_url": "https://github.com/owner/repo",
        "style": "documentary",
    })
    assembled_data = json.loads(assembled["content"][0]["text"])

    result = await validate_script({"script": assembled_data})
    data = json.loads(result["content"][0]["text"])

    assert data["valid"] is True
    assert len(data["issues"]) == 0


@pytest.mark.asyncio
async def test_validate_script_empty():
    """Test validation of empty script."""
    result = await validate_script({
        "script": {"title": "Empty", "segments": []},
    })
    data = json.loads(result["content"][0]["text"])

    assert data["valid"] is False
    assert len(data["issues"]) > 0


@pytest.mark.asyncio
async def test_validate_script_warnings():
    """Test validation warnings for long segments."""
    long_content = "word " * 1200  # >5000 characters

    result = await validate_script({
        "script": {
            "title": "Test",
            "segments": [{
                "segment_type": "chapter",
                "content": long_content,
                "chapter_number": 1,
            }],
            "total_duration_seconds": 300,
        },
    })
    data = json.loads(result["content"][0]["text"])

    assert data["valid"] is True  # Long content is warning, not error
    assert len(data["warnings"]) > 0
    assert any("5000 characters" in w for w in data["warnings"])


@pytest.mark.asyncio
async def test_get_script_summary(sample_chapters):
    """Test script summary generation."""
    assembled = await assemble_complete_script({
        "chapters": sample_chapters,
        "repository_url": "https://github.com/owner/test-repo",
        "style": "tutorial",
    })
    assembled_data = json.loads(assembled["content"][0]["text"])

    result = await get_script_summary({"script": assembled_data})
    data = json.loads(result["content"][0]["text"])

    assert data["title"] == "Code Story: test-repo"
    assert data["style"] == "tutorial"
    assert data["structure"]["chapter_count"] == 3
    assert len(data["chapters"]) == 3


def test_intro_templates_all_styles():
    """Test all styles have intro templates."""
    styles = ["fiction", "documentary", "tutorial", "podcast", "technical"]
    for style in styles:
        assert style in INTRO_TEMPLATES
        assert "{repo_name}" in INTRO_TEMPLATES[style]


def test_outro_templates_all_styles():
    """Test all styles have outro templates."""
    styles = ["fiction", "documentary", "tutorial", "podcast", "technical"]
    for style in styles:
        assert style in OUTRO_TEMPLATES
        assert "{repo_name}" in OUTRO_TEMPLATES[style]
```

## Files Created/Modified

| File | Action | Purpose |
|------|--------|---------|
| `src/codestory/agents/tools/story/assembly.py` | Create | Script assembly tools |
| `src/codestory/agents/tools/story/server.py` | Update | Add assembly tools to MCP server |
| `tests/agents/tools/story/test_assembly.py` | Create | Assembly tests |

## Validation Criteria

1. Script assembly combines chapters with intro/outro/transitions
2. Synthesis preparation adds correct voice settings
3. Validation catches empty and problematic scripts
4. Long segments trigger warnings about ElevenLabs limits
5. All templates have `{repo_name}` placeholder
6. All tools return proper `{"content": [...]}` format
7. All tests pass

## Tool Naming Convention

All tools accessed as: `mcp__architect__<tool_name>`

Complete list of Story Architect tools:
- `mcp__architect__get_style_definition`
- `mcp__architect__get_style_prompt`
- `mcp__architect__get_chapter_template`
- `mcp__architect__list_available_styles`
- `mcp__architect__generate_chapter_script`
- `mcp__architect__estimate_script_duration`
- `mcp__architect__generate_chapter_transition`
- `mcp__architect__generate_all_transitions`
- `mcp__architect__calculate_story_pacing`
- `mcp__architect__get_pause_durations`
- `mcp__architect__select_narrative_style`
- `mcp__architect__generate_story_outline`
- `mcp__architect__orchestrate_story_creation`
- `mcp__architect__assemble_complete_script`
- `mcp__architect__get_script_for_synthesis`
- `mcp__architect__validate_script`
- `mcp__architect__get_script_summary`

## Phase 4 Complete

Story Architect Agent fully functional with:
- 5 narrative styles with distinct voice characters
- Chapter script generation with voice markers
- Style-appropriate transitions and pacing
- Complete script assembly with intro/outro
- Validation and synthesis preparation
- All tools accessible via MCP server

## Next Step

Ready for Phase 5: Voice Director Agent (05-01-PLAN.md)
