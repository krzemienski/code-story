# Plan 04-04: Chapter Transitions and Pacing

## Overview

**Phase**: 4 - Story Architect Agent
**Plan**: 04 of 05
**Depends on**: 04-03 (Story Agent Assembly)
**Enables**: 04-05 (Script Assembly)

## Goal

Implement chapter transition generation and pacing calculation tools using Claude Agent SDK's `@tool` decorator pattern for smooth audio flow.

## Claude Agent SDK Pattern

Transition tools use the `@tool` decorator:

```python
from claude_agent_sdk import tool

@tool(
    name="generate_transitions",
    description="Generate transitions between chapters",
    input_schema={...}
)
async def generate_transitions(args: dict) -> dict:
    ...
    return {"content": [{"type": "text", "text": json.dumps(result)}]}
```

## Tasks

### Task 1: Create Transition Tools

**File**: `src/codestory/agents/tools/story/transitions.py`

```python
"""Chapter transitions and pacing tools using Claude Agent SDK @tool decorator."""

import json
from typing import Any
from dataclasses import dataclass

from claude_agent_sdk import tool


@dataclass
class TransitionTemplate:
    """Template for chapter transitions."""
    text: str
    pause_before_seconds: float = 2.0
    pause_after_seconds: float = 1.0


# Transition templates organized by narrative style
TRANSITION_TEMPLATES: dict[str, list[TransitionTemplate]] = {
    "fiction": [
        TransitionTemplate("And so our story continues...", 2.5, 1.5),
        TransitionTemplate("But the adventure was far from over...", 2.5, 1.5),
        TransitionTemplate("With newfound knowledge, we press on...", 2.5, 1.5),
        TransitionTemplate("The journey takes an unexpected turn...", 2.5, 1.5),
        TransitionTemplate("Yet there was more to discover...", 2.5, 1.5),
    ],
    "documentary": [
        TransitionTemplate("Let's examine the next component...", 2.0, 1.0),
        TransitionTemplate("Moving deeper into the architecture...", 2.0, 1.0),
        TransitionTemplate("Another fascinating aspect emerges...", 2.0, 1.0),
        TransitionTemplate("This brings us to our next topic...", 2.0, 1.0),
        TransitionTemplate("Now we turn our attention to...", 2.0, 1.0),
    ],
    "tutorial": [
        TransitionTemplate("Great progress! Now let's explore...", 2.0, 1.0),
        TransitionTemplate("Building on what we learned...", 2.0, 1.0),
        TransitionTemplate("Ready for the next step? Here we go...", 2.0, 1.0),
        TransitionTemplate("You're doing great! Next up...", 2.0, 1.0),
        TransitionTemplate("Let's keep the momentum going with...", 2.0, 1.0),
    ],
    "podcast": [
        TransitionTemplate("Alright, moving on to something cool...", 2.0, 1.0),
        TransitionTemplate("But wait, there's more...", 1.5, 1.0),
        TransitionTemplate("So here's where it gets interesting...", 2.0, 1.0),
        TransitionTemplate("Now, speaking of that...", 1.5, 0.5),
        TransitionTemplate("Okay, let's switch gears to...", 2.0, 1.0),
    ],
    "technical": [
        TransitionTemplate("The next section covers...", 2.0, 1.0),
        TransitionTemplate("Proceeding to the following component...", 2.0, 1.0),
        TransitionTemplate("See also the related functionality...", 2.0, 1.0),
        TransitionTemplate("The following module implements...", 2.0, 1.0),
        TransitionTemplate("Additionally, consider...", 2.0, 1.0),
    ],
}

# Pacing constants based on audiobook production standards
PAUSE_DURATIONS = {
    "sentence_break": 0.5,      # Between sentences
    "paragraph_break": 1.5,     # Between paragraphs
    "section_break": 2.5,       # Between sections
    "chapter_break": 4.0,       # Between chapters
    "emphasis_before": 0.3,     # Before emphasized word
    "emphasis_after": 0.2,      # After emphasized word
    "code_block_before": 1.0,   # Before code reading
    "code_block_after": 0.5,    # After code reading
}

# Words per minute by style (affects duration estimates)
STYLE_WPM = {
    "fiction": 140,       # Dramatic, slower
    "documentary": 145,   # Clear, measured
    "tutorial": 130,      # Educational, slower for comprehension
    "podcast": 160,       # Conversational, natural pace
    "technical": 150,     # Clear but efficient
}


@tool(
    name="generate_chapter_transition",
    description="Generate a transition between two specific chapters",
    input_schema={
        "type": "object",
        "properties": {
            "from_chapter": {
                "type": "integer",
                "description": "Chapter number we're transitioning from",
            },
            "to_chapter": {
                "type": "integer",
                "description": "Chapter number we're transitioning to",
            },
            "from_chapter_title": {
                "type": "string",
                "description": "Title of the chapter we're leaving",
            },
            "to_chapter_title": {
                "type": "string",
                "description": "Title of the chapter we're going to",
            },
            "style": {
                "type": "string",
                "description": "Narrative style",
                "enum": ["fiction", "documentary", "tutorial", "podcast", "technical"],
            },
        },
        "required": ["from_chapter", "to_chapter", "style"],
    },
)
async def generate_chapter_transition(args: dict) -> dict:
    """Generate a transition between two chapters."""
    from_chapter = args.get("from_chapter", 1)
    to_chapter = args.get("to_chapter", 2)
    from_title = args.get("from_chapter_title", "")
    to_title = args.get("to_chapter_title", "")
    style = args.get("style", "documentary")

    # Get templates for style
    templates = TRANSITION_TEMPLATES.get(style, TRANSITION_TEMPLATES["documentary"])

    # Select template based on chapter number (cycle through templates)
    template_idx = (from_chapter - 1) % len(templates)
    template = templates[template_idx]

    # Build transition with pause markers
    transition_text = f"[PAUSE {template.pause_before_seconds}s] {template.text} [PAUSE {template.pause_after_seconds}s]"

    result = {
        "from_chapter": from_chapter,
        "to_chapter": to_chapter,
        "from_chapter_title": from_title,
        "to_chapter_title": to_title,
        "transition_text": transition_text,
        "raw_text": template.text,
        "pause_before_seconds": template.pause_before_seconds,
        "pause_after_seconds": template.pause_after_seconds,
        "total_transition_seconds": template.pause_before_seconds + template.pause_after_seconds + len(template.text.split()) / 2.5,
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


@tool(
    name="generate_all_transitions",
    description="Generate transitions for all chapter boundaries in a story",
    input_schema={
        "type": "object",
        "properties": {
            "chapters": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "chapter_number": {"type": "integer"},
                        "title": {"type": "string"},
                    },
                },
                "description": "List of chapters in the story",
            },
            "style": {
                "type": "string",
                "description": "Narrative style",
                "enum": ["fiction", "documentary", "tutorial", "podcast", "technical"],
            },
        },
        "required": ["chapters", "style"],
    },
)
async def generate_all_transitions(args: dict) -> dict:
    """Generate all transitions for a story."""
    chapters = args.get("chapters", [])
    style = args.get("style", "documentary")

    if len(chapters) < 2:
        return {"content": [{"type": "text", "text": json.dumps({
            "transitions": [],
            "total_count": 0,
            "message": "Need at least 2 chapters for transitions",
        })}]}

    transitions = []
    total_transition_time = 0

    for i in range(len(chapters) - 1):
        from_ch = chapters[i]
        to_ch = chapters[i + 1]

        result = await generate_chapter_transition({
            "from_chapter": from_ch.get("chapter_number", i + 1),
            "to_chapter": to_ch.get("chapter_number", i + 2),
            "from_chapter_title": from_ch.get("title", ""),
            "to_chapter_title": to_ch.get("title", ""),
            "style": style,
        })

        transition_data = json.loads(result["content"][0]["text"])
        transitions.append(transition_data)
        total_transition_time += transition_data.get("total_transition_seconds", 0)

    result = {
        "transitions": transitions,
        "total_count": len(transitions),
        "total_transition_time_seconds": total_transition_time,
        "style": style,
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


@tool(
    name="calculate_story_pacing",
    description="Calculate comprehensive pacing metrics for a story",
    input_schema={
        "type": "object",
        "properties": {
            "chapters": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "chapter_number": {"type": "integer"},
                        "word_count": {"type": "integer"},
                        "duration_estimate_seconds": {"type": "number"},
                    },
                },
                "description": "List of chapters with word counts",
            },
            "style": {
                "type": "string",
                "description": "Narrative style for WPM calculation",
            },
            "include_intro": {
                "type": "boolean",
                "description": "Whether story has intro segment",
                "default": True,
            },
            "include_outro": {
                "type": "boolean",
                "description": "Whether story has outro segment",
                "default": True,
            },
        },
        "required": ["chapters"],
    },
)
async def calculate_story_pacing(args: dict) -> dict:
    """Calculate pacing metrics for a story."""
    chapters = args.get("chapters", [])
    style = args.get("style", "documentary")
    include_intro = args.get("include_intro", True)
    include_outro = args.get("include_outro", True)

    wpm = STYLE_WPM.get(style, 145)

    # Calculate chapter timing
    total_words = 0
    total_chapter_duration = 0
    chapter_metrics = []

    for ch in chapters:
        word_count = ch.get("word_count", 0)
        # Use provided estimate or calculate from words
        duration = ch.get("duration_estimate_seconds", (word_count / wpm) * 60)

        total_words += word_count
        total_chapter_duration += duration

        chapter_metrics.append({
            "chapter_number": ch.get("chapter_number", len(chapter_metrics) + 1),
            "word_count": word_count,
            "duration_seconds": duration,
            "duration_formatted": _format_duration(int(duration * 1000)),
        })

    # Add transition time (5 seconds average per transition)
    transition_count = len(chapters) - 1
    transition_time = transition_count * 5

    # Add intro/outro time (15 seconds each)
    intro_time = 15 if include_intro else 0
    outro_time = 15 if include_outro else 0

    # Calculate totals
    total_duration = total_chapter_duration + transition_time + intro_time + outro_time

    result = {
        "style": style,
        "words_per_minute": wpm,
        "total_words": total_words,
        "total_chapters": len(chapters),
        "chapter_metrics": chapter_metrics,
        "average_chapter_duration_seconds": total_chapter_duration / len(chapters) if chapters else 0,
        "average_words_per_chapter": total_words // len(chapters) if chapters else 0,
        "transition_count": transition_count,
        "transition_time_seconds": transition_time,
        "intro_time_seconds": intro_time,
        "outro_time_seconds": outro_time,
        "total_duration_seconds": total_duration,
        "total_duration_formatted": _format_duration(int(total_duration * 1000)),
        "pacing_recommendations": _get_pacing_recommendations(chapters, style),
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


def _format_duration(ms: int) -> str:
    """Format duration in milliseconds as HH:MM:SS or MM:SS."""
    seconds = ms // 1000
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    secs = seconds % 60

    if hours > 0:
        return f"{hours}:{minutes:02d}:{secs:02d}"
    return f"{minutes}:{secs:02d}"


def _get_pacing_recommendations(chapters: list, style: str) -> list[str]:
    """Generate pacing recommendations based on story structure."""
    recommendations = []

    if not chapters:
        return ["Add chapters to generate pacing recommendations"]

    total_words = sum(ch.get("word_count", 0) for ch in chapters)
    avg_words = total_words / len(chapters) if chapters else 0

    # Check for chapter length balance
    if chapters:
        word_counts = [ch.get("word_count", 0) for ch in chapters]
        if max(word_counts) > avg_words * 1.5:
            recommendations.append("Consider splitting longer chapters for better pacing")
        if min(word_counts) < avg_words * 0.5:
            recommendations.append("Consider expanding shorter chapters or merging them")

    # Style-specific recommendations
    if style == "tutorial" and avg_words > 400:
        recommendations.append("Tutorial chapters work best under 400 words for retention")
    elif style == "fiction" and avg_words < 300:
        recommendations.append("Fiction chapters benefit from 300+ words for narrative flow")
    elif style == "technical" and total_words < 500:
        recommendations.append("Technical overview may need more detail for completeness")

    # Duration recommendations
    wpm = STYLE_WPM.get(style, 145)
    total_duration_minutes = (total_words / wpm)

    if total_duration_minutes > 20:
        recommendations.append("Story exceeds 20 minutes; consider condensing for listener retention")
    elif total_duration_minutes < 5:
        recommendations.append("Story is under 5 minutes; may benefit from additional depth")

    if not recommendations:
        recommendations.append("Pacing looks balanced for this style")

    return recommendations


@tool(
    name="get_pause_durations",
    description="Get standard pause durations for audio production",
    input_schema={
        "type": "object",
        "properties": {},
    },
)
async def get_pause_durations(args: dict) -> dict:
    """Get standard pause duration constants."""
    result = {
        "pause_durations": PAUSE_DURATIONS,
        "style_words_per_minute": STYLE_WPM,
        "usage_guide": {
            "sentence_break": "Use between sentences for natural breathing room",
            "paragraph_break": "Use between paragraphs for topic transition",
            "section_break": "Use between major sections within a chapter",
            "chapter_break": "Use between chapters for mental context switch",
            "emphasis_before": "Brief pause before an important term",
            "emphasis_after": "Brief pause after an important term",
            "code_block_before": "Pause before reading code for mental preparation",
            "code_block_after": "Pause after code to let it sink in",
        },
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}
```

### Task 2: Update Story Package Init

**File**: `src/codestory/agents/tools/story/__init__.py`

```python
"""Story Architect tools package using Claude Agent SDK."""

from codestory.agents.tools.story.styles import (
    NarrativeStyle,
    StyleDefinition,
    STYLE_DEFINITIONS,
    get_style_definition,
    get_style_prompt,
    get_chapter_template,
    list_available_styles,
)
from codestory.agents.tools.story.chapters import (
    ChapterScript,
    generate_chapter_script,
    estimate_script_duration,
)
from codestory.agents.tools.story.transitions import (
    TransitionTemplate,
    TRANSITION_TEMPLATES,
    PAUSE_DURATIONS,
    STYLE_WPM,
    generate_chapter_transition,
    generate_all_transitions,
    calculate_story_pacing,
    get_pause_durations,
)
from codestory.agents.tools.story.architect import (
    INTENT_STYLE_MAP,
    select_narrative_style,
    generate_story_outline,
    orchestrate_story_creation,
)
from codestory.agents.tools.story.server import create_architect_mcp_server

__all__ = [
    # Styles
    "NarrativeStyle",
    "StyleDefinition",
    "STYLE_DEFINITIONS",
    "get_style_definition",
    "get_style_prompt",
    "get_chapter_template",
    "list_available_styles",
    # Chapters
    "ChapterScript",
    "generate_chapter_script",
    "estimate_script_duration",
    # Transitions
    "TransitionTemplate",
    "TRANSITION_TEMPLATES",
    "PAUSE_DURATIONS",
    "STYLE_WPM",
    "generate_chapter_transition",
    "generate_all_transitions",
    "calculate_story_pacing",
    "get_pause_durations",
    # Architect
    "INTENT_STYLE_MAP",
    "select_narrative_style",
    "generate_story_outline",
    "orchestrate_story_creation",
    # Server
    "create_architect_mcp_server",
]
```

### Task 3: Create Transition Tests

**File**: `tests/agents/tools/story/test_transitions.py`

```python
"""Tests for chapter transition and pacing tools."""

import pytest
import json

from codestory.agents.tools.story.transitions import (
    generate_chapter_transition,
    generate_all_transitions,
    calculate_story_pacing,
    get_pause_durations,
    TRANSITION_TEMPLATES,
    STYLE_WPM,
)


@pytest.mark.asyncio
async def test_generate_chapter_transition():
    """Test single chapter transition generation."""
    result = await generate_chapter_transition({
        "from_chapter": 1,
        "to_chapter": 2,
        "from_chapter_title": "Introduction",
        "to_chapter_title": "Architecture",
        "style": "documentary",
    })

    data = json.loads(result["content"][0]["text"])

    assert data["from_chapter"] == 1
    assert data["to_chapter"] == 2
    assert "[PAUSE" in data["transition_text"]
    assert data["pause_before_seconds"] > 0
    assert data["total_transition_seconds"] > 0


@pytest.mark.asyncio
async def test_generate_chapter_transition_cycles_templates():
    """Test that templates cycle through available options."""
    results = []
    for i in range(1, 7):
        result = await generate_chapter_transition({
            "from_chapter": i,
            "to_chapter": i + 1,
            "style": "fiction",
        })
        data = json.loads(result["content"][0]["text"])
        results.append(data["raw_text"])

    # Should cycle through templates (5 fiction templates)
    assert results[0] == results[5]  # 1st and 6th should match


@pytest.mark.asyncio
async def test_generate_all_transitions():
    """Test generating all transitions for a story."""
    chapters = [
        {"chapter_number": 1, "title": "Introduction"},
        {"chapter_number": 2, "title": "Architecture"},
        {"chapter_number": 3, "title": "Core Features"},
        {"chapter_number": 4, "title": "Conclusion"},
    ]

    result = await generate_all_transitions({
        "chapters": chapters,
        "style": "tutorial",
    })

    data = json.loads(result["content"][0]["text"])

    assert data["total_count"] == 3  # 4 chapters = 3 transitions
    assert len(data["transitions"]) == 3
    assert data["total_transition_time_seconds"] > 0


@pytest.mark.asyncio
async def test_generate_all_transitions_single_chapter():
    """Test handling of single chapter (no transitions needed)."""
    chapters = [{"chapter_number": 1, "title": "Only Chapter"}]

    result = await generate_all_transitions({
        "chapters": chapters,
        "style": "documentary",
    })

    data = json.loads(result["content"][0]["text"])

    assert data["total_count"] == 0
    assert "Need at least 2 chapters" in data.get("message", "")


@pytest.mark.asyncio
async def test_calculate_story_pacing():
    """Test pacing calculation."""
    chapters = [
        {"chapter_number": 1, "word_count": 300},
        {"chapter_number": 2, "word_count": 450},
        {"chapter_number": 3, "word_count": 350},
    ]

    result = await calculate_story_pacing({
        "chapters": chapters,
        "style": "documentary",
        "include_intro": True,
        "include_outro": True,
    })

    data = json.loads(result["content"][0]["text"])

    assert data["total_words"] == 1100
    assert data["total_chapters"] == 3
    assert data["transition_count"] == 2
    assert data["total_duration_seconds"] > 0
    assert "pacing_recommendations" in data


@pytest.mark.asyncio
async def test_calculate_story_pacing_style_wpm():
    """Test that different styles have different WPM."""
    chapters = [{"chapter_number": 1, "word_count": 300}]

    tutorial_result = await calculate_story_pacing({
        "chapters": chapters,
        "style": "tutorial",
    })
    podcast_result = await calculate_story_pacing({
        "chapters": chapters,
        "style": "podcast",
    })

    tutorial_data = json.loads(tutorial_result["content"][0]["text"])
    podcast_data = json.loads(podcast_result["content"][0]["text"])

    # Tutorial is slower (130 WPM) than podcast (160 WPM)
    assert tutorial_data["words_per_minute"] < podcast_data["words_per_minute"]


@pytest.mark.asyncio
async def test_get_pause_durations():
    """Test getting pause duration constants."""
    result = await get_pause_durations({})

    data = json.loads(result["content"][0]["text"])

    assert "pause_durations" in data
    assert "style_words_per_minute" in data
    assert "usage_guide" in data
    assert data["pause_durations"]["chapter_break"] > data["pause_durations"]["sentence_break"]


def test_transition_templates_all_styles():
    """Test that all styles have transition templates."""
    styles = ["fiction", "documentary", "tutorial", "podcast", "technical"]

    for style in styles:
        assert style in TRANSITION_TEMPLATES
        assert len(TRANSITION_TEMPLATES[style]) >= 3


def test_style_wpm_all_styles():
    """Test that all styles have WPM defined."""
    styles = ["fiction", "documentary", "tutorial", "podcast", "technical"]

    for style in styles:
        assert style in STYLE_WPM
        assert 100 < STYLE_WPM[style] < 200  # Reasonable WPM range
```

## Files Created/Modified

| File | Action | Purpose |
|------|--------|---------|
| `src/codestory/agents/tools/story/transitions.py` | Create | Transition and pacing tools |
| `src/codestory/agents/tools/story/__init__.py` | Update | Export transition tools |
| `tests/agents/tools/story/test_transitions.py` | Create | Transition tests |

## Validation Criteria

1. Transitions match narrative style tone
2. Templates cycle correctly to avoid repetition
3. Pacing calculations account for style-specific WPM
4. Pause durations follow audiobook production standards
5. Recommendations adapt to story structure
6. All tools return proper `{"content": [...]}` format
7. All tests pass

## Tool Naming Convention

All tools accessed as: `mcp__architect__<tool_name>`

## Audiobook Production Standards

Based on professional audiobook production:
- Sentence pauses: 0.5s
- Paragraph pauses: 1.5s
- Section pauses: 2.5s
- Chapter breaks: 4.0s
- Typical WPM: 130-160 depending on style

## Next Step

Ready for 04-05-PLAN.md (Script Assembly)
