# Plan 05-02: Voice Director Agent

## Overview

**Phase**: 5 - Voice Director Agent
**Plan**: 02 of 04
**Depends on**: 05-01 (ElevenLabs Integration)
**Enables**: 05-03 (Script Preparation)

## Goal

Implement Voice Director Agent using Claude Agent SDK `AgentDefinition` pattern with voice orchestration tools that coordinate script-to-audio synthesis.

## Claude Agent SDK Pattern

The Voice Director Agent uses `AgentDefinition` for agent configuration:

```python
from claude_agent_sdk import AgentDefinition

AgentDefinition(
    description="Orchestrates voice synthesis for Code Story narratives",
    prompt=VOICE_DIRECTOR_PROMPT,
    tools=["mcp__voice__*"],
    model="sonnet",  # Balanced for voice direction decisions
)
```

## Tasks

### Task 1: Create Voice Director Orchestration Tools

**File**: `src/codestory/voice/director.py`

```python
"""Voice Director orchestration tools for Code Story.

Coordinates the synthesis of complete story audio from scripts.
"""

import json
import asyncio
import tempfile
from pathlib import Path
from typing import Any
from dataclasses import dataclass

from claude_agent_sdk import tool

from codestory.voice.elevenlabs import (
    synthesize_with_style,
    check_elevenlabs_quota,
    STYLE_DEFAULTS,
)


@dataclass
class SynthesisProgress:
    """Track synthesis progress."""
    total_segments: int = 0
    completed_segments: int = 0
    failed_segments: int = 0
    total_characters: int = 0
    synthesized_characters: int = 0


# Segment type synthesis order (ensures proper flow)
SEGMENT_ORDER = ["intro", "chapter", "transition", "outro"]


@tool(
    name="estimate_synthesis_cost",
    description="Estimate character cost and check quota before synthesis",
    input_schema={
        "type": "object",
        "properties": {
            "segments": {
                "type": "array",
                "description": "Script segments to synthesize",
                "items": {
                    "type": "object",
                    "properties": {
                        "text": {"type": "string"},
                        "segment_type": {"type": "string"},
                    },
                },
            },
        },
        "required": ["segments"],
    },
)
async def estimate_synthesis_cost(args: dict) -> dict:
    """Estimate synthesis cost and check against quota."""
    segments = args["segments"]

    # Calculate total characters
    total_chars = sum(len(s.get("text", "")) for s in segments)
    segment_count = len(segments)

    # Check current quota
    quota_result = await check_elevenlabs_quota({})
    quota_content = json.loads(quota_result["content"][0]["text"])

    if not quota_content.get("success"):
        return {"content": [{"type": "text", "text": json.dumps({
            "success": False,
            "error": "Unable to check quota",
            "details": quota_content.get("error"),
        })}]}

    remaining = quota_content.get("characters_remaining", 0)
    can_synthesize = remaining >= total_chars

    # Estimate duration (avg 150 words/min, 5 chars/word)
    words = total_chars / 5
    estimated_minutes = words / 150

    result = {
        "success": True,
        "can_synthesize": can_synthesize,
        "estimate": {
            "total_characters": total_chars,
            "segment_count": segment_count,
            "estimated_duration_minutes": round(estimated_minutes, 1),
        },
        "quota": {
            "remaining": remaining,
            "after_synthesis": remaining - total_chars if can_synthesize else None,
        },
    }

    if not can_synthesize:
        result["warning"] = f"Insufficient quota. Need {total_chars}, have {remaining}"

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


@tool(
    name="synthesize_story_segments",
    description="Synthesize all script segments to audio files",
    input_schema={
        "type": "object",
        "properties": {
            "segments": {
                "type": "array",
                "description": "Script segments with text and metadata",
                "items": {
                    "type": "object",
                    "properties": {
                        "text": {"type": "string"},
                        "segment_type": {"type": "string"},
                        "chapter_number": {"type": "integer"},
                        "voice_settings": {"type": "object"},
                    },
                    "required": ["text"],
                },
            },
            "style": {
                "type": "string",
                "description": "Narrative style for voice selection",
                "enum": ["fiction", "documentary", "tutorial", "podcast", "technical"],
            },
            "output_dir": {
                "type": "string",
                "description": "Directory to save audio files (uses temp if not provided)",
            },
            "continue_on_error": {
                "type": "boolean",
                "description": "Continue synthesis if individual segments fail",
                "default": True,
            },
        },
        "required": ["segments", "style"],
    },
)
async def synthesize_story_segments(args: dict) -> dict:
    """Synthesize all story segments to audio files."""
    segments = args["segments"]
    style = args["style"]
    output_dir = args.get("output_dir") or tempfile.mkdtemp(prefix="codestory_audio_")
    continue_on_error = args.get("continue_on_error", True)

    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    results = []
    failed = []
    total_duration = 0

    for i, segment in enumerate(segments):
        text = segment.get("text", "")
        segment_type = segment.get("segment_type", "chapter")
        chapter_num = segment.get("chapter_number")

        # Synthesize segment
        synth_result = await synthesize_with_style({
            "text": text,
            "style": style,
            "segment_type": segment_type,
        })

        synth_content = json.loads(synth_result["content"][0]["text"])

        if synth_content.get("success"):
            # Save audio to file
            import base64
            audio_data = base64.b64decode(synth_content["audio_base64"])

            filename = f"segment_{i:03d}_{segment_type}.mp3"
            if chapter_num is not None:
                filename = f"segment_{i:03d}_ch{chapter_num:02d}_{segment_type}.mp3"

            file_path = output_path / filename
            file_path.write_bytes(audio_data)

            # Estimate duration
            words = len(text) / 5
            duration_sec = (words / 150) * 60

            results.append({
                "segment_index": i,
                "segment_type": segment_type,
                "chapter_number": chapter_num,
                "file_path": str(file_path),
                "file_size_bytes": len(audio_data),
                "character_count": len(text),
                "duration_seconds": round(duration_sec, 1),
                "success": True,
            })
            total_duration += duration_sec

        else:
            # Handle failure
            failed.append({
                "segment_index": i,
                "segment_type": segment_type,
                "error": synth_content.get("error", "Unknown error"),
            })

            if not continue_on_error:
                return {"content": [{"type": "text", "text": json.dumps({
                    "success": False,
                    "error": f"Synthesis failed at segment {i}",
                    "failed_segment": failed[-1],
                    "completed": results,
                })}]}

        # Small delay between API calls
        await asyncio.sleep(0.1)

    result = {
        "success": len(failed) == 0,
        "partial_success": len(results) > 0,
        "output_dir": str(output_path),
        "segments": results,
        "failed": failed,
        "summary": {
            "total_segments": len(segments),
            "successful": len(results),
            "failed": len(failed),
            "total_duration_seconds": round(total_duration, 1),
            "total_duration_formatted": _format_duration(int(total_duration)),
        },
    }

    return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}


def _format_duration(seconds: int) -> str:
    """Format duration as MM:SS or HH:MM:SS."""
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    secs = seconds % 60

    if hours > 0:
        return f"{hours}:{minutes:02d}:{secs:02d}"
    return f"{minutes}:{secs:02d}"


@tool(
    name="retry_failed_segments",
    description="Retry synthesis for previously failed segments",
    input_schema={
        "type": "object",
        "properties": {
            "failed_segments": {
                "type": "array",
                "description": "Failed segment info from previous synthesis",
                "items": {
                    "type": "object",
                    "properties": {
                        "segment_index": {"type": "integer"},
                        "segment_type": {"type": "string"},
                    },
                },
            },
            "original_segments": {
                "type": "array",
                "description": "Original segment list to get text from",
            },
            "style": {
                "type": "string",
                "enum": ["fiction", "documentary", "tutorial", "podcast", "technical"],
            },
            "output_dir": {
                "type": "string",
                "description": "Directory for output files",
            },
            "max_retries": {
                "type": "integer",
                "description": "Maximum retry attempts per segment",
                "default": 3,
            },
        },
        "required": ["failed_segments", "original_segments", "style", "output_dir"],
    },
)
async def retry_failed_segments(args: dict) -> dict:
    """Retry synthesis for failed segments with exponential backoff."""
    failed_segments = args["failed_segments"]
    original_segments = args["original_segments"]
    style = args["style"]
    output_dir = args["output_dir"]
    max_retries = args.get("max_retries", 3)

    output_path = Path(output_dir)
    results = []
    still_failed = []

    for failed in failed_segments:
        seg_idx = failed["segment_index"]
        segment_type = failed["segment_type"]

        # Get original text
        if seg_idx >= len(original_segments):
            still_failed.append({**failed, "error": "Segment index out of range"})
            continue

        original = original_segments[seg_idx]
        text = original.get("text", "")

        # Retry with backoff
        success = False
        last_error = None

        for attempt in range(max_retries):
            if attempt > 0:
                wait_time = 2 ** attempt  # Exponential backoff: 2, 4, 8 seconds
                await asyncio.sleep(wait_time)

            synth_result = await synthesize_with_style({
                "text": text,
                "style": style,
                "segment_type": segment_type,
            })

            synth_content = json.loads(synth_result["content"][0]["text"])

            if synth_content.get("success"):
                # Save audio
                import base64
                audio_data = base64.b64decode(synth_content["audio_base64"])

                filename = f"segment_{seg_idx:03d}_{segment_type}.mp3"
                file_path = output_path / filename
                file_path.write_bytes(audio_data)

                words = len(text) / 5
                duration_sec = (words / 150) * 60

                results.append({
                    "segment_index": seg_idx,
                    "segment_type": segment_type,
                    "file_path": str(file_path),
                    "file_size_bytes": len(audio_data),
                    "duration_seconds": round(duration_sec, 1),
                    "retry_count": attempt + 1,
                    "success": True,
                })
                success = True
                break

            last_error = synth_content.get("error")

        if not success:
            still_failed.append({
                "segment_index": seg_idx,
                "segment_type": segment_type,
                "error": last_error,
                "retry_attempts": max_retries,
            })

    return {"content": [{"type": "text", "text": json.dumps({
        "success": len(still_failed) == 0,
        "recovered": results,
        "still_failed": still_failed,
        "summary": {
            "original_failures": len(failed_segments),
            "recovered": len(results),
            "still_failing": len(still_failed),
        },
    }, indent=2)}]}


@tool(
    name="generate_voice_preview",
    description="Generate a short voice preview for style selection",
    input_schema={
        "type": "object",
        "properties": {
            "preview_text": {
                "type": "string",
                "description": "Sample text for preview (50-200 chars recommended)",
                "default": "Welcome to Code Story. Let me take you on a journey through this codebase.",
            },
            "styles": {
                "type": "array",
                "description": "Styles to generate previews for",
                "items": {
                    "type": "string",
                    "enum": ["fiction", "documentary", "tutorial", "podcast", "technical"],
                },
            },
            "output_dir": {
                "type": "string",
                "description": "Directory to save preview files",
            },
        },
        "required": ["styles"],
    },
)
async def generate_voice_preview(args: dict) -> dict:
    """Generate voice previews for multiple styles."""
    preview_text = args.get(
        "preview_text",
        "Welcome to Code Story. Let me take you on a journey through this codebase."
    )
    styles = args["styles"]
    output_dir = args.get("output_dir") or tempfile.mkdtemp(prefix="codestory_preview_")

    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    previews = []

    for style in styles:
        synth_result = await synthesize_with_style({
            "text": preview_text,
            "style": style,
            "segment_type": "intro",
        })

        synth_content = json.loads(synth_result["content"][0]["text"])

        if synth_content.get("success"):
            import base64
            audio_data = base64.b64decode(synth_content["audio_base64"])

            file_path = output_path / f"preview_{style}.mp3"
            file_path.write_bytes(audio_data)

            previews.append({
                "style": style,
                "file_path": str(file_path),
                "file_size_bytes": len(audio_data),
                "voice_info": STYLE_DEFAULTS.get(style, {}),
                "success": True,
            })
        else:
            previews.append({
                "style": style,
                "success": False,
                "error": synth_content.get("error"),
            })

        await asyncio.sleep(0.1)

    return {"content": [{"type": "text", "text": json.dumps({
        "success": all(p.get("success") for p in previews),
        "preview_text": preview_text,
        "output_dir": str(output_path),
        "previews": previews,
    }, indent=2)}]}
```

### Task 2: Create Voice Director Agent Definition

**File**: `src/codestory/agents/voice_director.py`

```python
"""Voice Director Agent for Code Story.

Uses Claude Agent SDK AgentDefinition pattern.
"""

from typing import Any

from claude_agent_sdk import AgentDefinition, ClaudeAgentOptions, query

from codestory.voice.server import create_voice_mcp_server
from codestory.voice.director import (
    estimate_synthesis_cost,
    synthesize_story_segments,
    retry_failed_segments,
    generate_voice_preview,
)
from claude_agent_sdk import create_sdk_mcp_server


VOICE_DIRECTOR_PROMPT = """You are the Voice Director Agent for Code Story. Your role is to transform narrative scripts into high-quality audio using ElevenLabs text-to-speech.

## Your Capabilities

You orchestrate voice synthesis using these tools:
- estimate_synthesis_cost: Check if synthesis is possible within quota
- synthesize_story_segments: Convert script segments to audio files
- retry_failed_segments: Recover from synthesis failures
- generate_voice_preview: Create voice samples for style selection
- synthesize_text: Direct text-to-speech synthesis
- synthesize_with_style: Style-optimized synthesis
- get_elevenlabs_voices: List available voices
- check_elevenlabs_quota: Monitor character quota

## Synthesis Workflow

When converting a script to audio:

1. **Pre-flight Check**
   - Use estimate_synthesis_cost to verify quota availability
   - If insufficient quota, report and suggest options

2. **Synthesis Process**
   - Use synthesize_story_segments with appropriate style
   - Process segments in order (intro → chapters → transitions → outro)
   - Enable continue_on_error for resilient processing

3. **Error Recovery**
   - If segments fail, use retry_failed_segments
   - Implement exponential backoff for rate limits
   - Report any unrecoverable failures

4. **Output**
   - Return paths to synthesized audio files
   - Include duration and metadata for assembly

## Voice Selection Guidelines

Match voices to narrative styles:
- **Fiction**: Narrative voice (Adam) - warm storytelling, engaging
- **Documentary**: Authoritative voice (Arnold) - professional, factual
- **Tutorial**: Friendly voice (Bella) - approachable, educational
- **Podcast**: Friendly voice (Bella) - conversational, casual
- **Technical**: Professional voice (Rachel) - clear, precise

## Segment Type Handling

Adjust voice settings by segment type:
- **intro**: Higher stability (0.6+) for consistent opening tone
- **chapter**: Standard settings for main content
- **transition**: Slightly slower, bridging tone
- **outro**: Warm, conclusive with fade consideration

## Voice Direction Markers

Scripts may contain these markers (handled by script preparation):
- [PAUSE Xs] - Silence duration (handled in audio assembly)
- [EMPHASIS word] - Let ElevenLabs interpret naturally
- [SLOW] ... [/SLOW] - Increase stability for slower speech
- [CODE] ... [/CODE] - Adjust for code pronunciation

## Quality Standards

- Ensure consistent voice throughout the story
- Monitor for synthesis artifacts or errors
- Verify audio file integrity
- Report any quality concerns

## Error Reporting

Always provide actionable error information:
- Which segments failed
- Why they failed (rate limit, timeout, API error)
- Recommended recovery steps
- Partial results if available"""


def create_voice_director_mcp_server():
    """Create MCP server with voice director tools."""
    return create_sdk_mcp_server(
        name="director",
        version="1.0.0",
        tools=[
            estimate_synthesis_cost,
            synthesize_story_segments,
            retry_failed_segments,
            generate_voice_preview,
        ],
    )


def create_voice_director_agent() -> AgentDefinition:
    """Create Voice Director Agent definition."""
    return AgentDefinition(
        description="Orchestrates voice synthesis for Code Story, converting narrative scripts to high-quality audio using ElevenLabs",
        prompt=VOICE_DIRECTOR_PROMPT,
        tools=[
            # Director orchestration tools
            "mcp__director__estimate_synthesis_cost",
            "mcp__director__synthesize_story_segments",
            "mcp__director__retry_failed_segments",
            "mcp__director__generate_voice_preview",
            # Base voice tools
            "mcp__voice__synthesize_text",
            "mcp__voice__synthesize_with_style",
            "mcp__voice__get_elevenlabs_voices",
            "mcp__voice__check_elevenlabs_quota",
        ],
        model="sonnet",  # Balanced model for orchestration decisions
    )


async def run_voice_director_stage(
    script: dict[str, Any],
    output_dir: str,
    generate_previews: bool = False,
) -> dict[str, Any]:
    """Run the Voice Director pipeline stage.

    Args:
        script: Assembled script from Story Architect
        output_dir: Directory to save audio files
        generate_previews: Whether to generate style previews first

    Returns:
        Synthesis results with file paths
    """
    style = script.get("style", "documentary")
    segments = script.get("segments", [])
    title = script.get("title", "Code Story")

    # Build synthesis prompt
    prompt = f"""Synthesize this Code Story script to audio.

## Script Details
- Title: {title}
- Style: {style}
- Total Segments: {len(segments)}

## Instructions

1. First, use estimate_synthesis_cost to check quota
2. If quota sufficient, use synthesize_story_segments to convert all segments
3. Save files to: {output_dir}
4. If any segments fail, attempt recovery with retry_failed_segments
5. Return the complete synthesis results

Segments to synthesize:
{[{"text": s.get("content", "")[:100] + "...", "segment_type": s.get("segment_type"), "chapter_number": s.get("chapter_number")} for s in segments]}
"""

    # Create MCP servers
    voice_server = create_voice_mcp_server()
    director_server = create_voice_director_mcp_server()
    agent = create_voice_director_agent()

    options = ClaudeAgentOptions(
        mcp_servers={
            "voice": voice_server,
            "director": director_server,
        },
        agents={"voice_director": agent},
        allowed_tools=agent.tools,
        max_turns=20,  # Allow for retries
    )

    # Run synthesis
    result_text = ""
    async for message in query(prompt=prompt, options=options):
        if hasattr(message, "content"):
            for block in message.content:
                if hasattr(block, "text"):
                    result_text = block.text

    # Parse result
    try:
        import json
        result = json.loads(result_text)
    except json.JSONDecodeError:
        result = {"raw_response": result_text}

    return {
        "synthesis": result,
        "script_title": title,
        "style": style,
        "output_dir": output_dir,
    }
```

### Task 3: Update Voice Package Exports

**File**: `src/codestory/voice/__init__.py` (update)

```python
"""Voice synthesis module for Code Story.

Provides ElevenLabs integration and Voice Director tools.
"""

from codestory.voice.elevenlabs import (
    synthesize_text,
    synthesize_with_style,
    get_elevenlabs_voices,
    check_elevenlabs_quota,
    VOICE_PRESETS,
    STYLE_DEFAULTS,
    ElevenLabsError,
)
from codestory.voice.server import create_voice_mcp_server
from codestory.voice.director import (
    estimate_synthesis_cost,
    synthesize_story_segments,
    retry_failed_segments,
    generate_voice_preview,
)

__all__ = [
    # ElevenLabs tools
    "synthesize_text",
    "synthesize_with_style",
    "get_elevenlabs_voices",
    "check_elevenlabs_quota",
    # Director tools
    "estimate_synthesis_cost",
    "synthesize_story_segments",
    "retry_failed_segments",
    "generate_voice_preview",
    # Constants
    "VOICE_PRESETS",
    "STYLE_DEFAULTS",
    # Server
    "create_voice_mcp_server",
    # Exceptions
    "ElevenLabsError",
]
```

### Task 4: Create Voice Director Tests

**File**: `tests/agents/test_voice_director.py`

```python
"""Tests for Voice Director Agent."""

import pytest
import json
from unittest.mock import AsyncMock, patch, MagicMock

from codestory.voice.director import (
    estimate_synthesis_cost,
    synthesize_story_segments,
    retry_failed_segments,
    generate_voice_preview,
)
from codestory.agents.voice_director import (
    create_voice_director_agent,
    create_voice_director_mcp_server,
)


@pytest.fixture
def sample_segments():
    """Sample script segments."""
    return [
        {"text": "Welcome to Code Story.", "segment_type": "intro"},
        {"text": "Let's explore this amazing codebase.", "segment_type": "chapter", "chapter_number": 1},
        {"text": "Moving on to the next topic.", "segment_type": "transition"},
        {"text": "Thanks for listening!", "segment_type": "outro"},
    ]


@pytest.mark.asyncio
async def test_estimate_synthesis_cost(sample_segments):
    """Test cost estimation."""
    mock_quota = {
        "success": True,
        "characters_remaining": 100000,
    }

    with patch("codestory.voice.director.check_elevenlabs_quota") as mock_check:
        mock_check.return_value = {
            "content": [{"type": "text", "text": json.dumps(mock_quota)}]
        }

        result = await estimate_synthesis_cost({"segments": sample_segments})

    content = json.loads(result["content"][0]["text"])

    assert content["success"] is True
    assert content["can_synthesize"] is True
    assert "estimate" in content
    assert content["estimate"]["segment_count"] == 4


@pytest.mark.asyncio
async def test_estimate_insufficient_quota(sample_segments):
    """Test cost estimation with insufficient quota."""
    mock_quota = {
        "success": True,
        "characters_remaining": 10,  # Very low
    }

    with patch("codestory.voice.director.check_elevenlabs_quota") as mock_check:
        mock_check.return_value = {
            "content": [{"type": "text", "text": json.dumps(mock_quota)}]
        }

        result = await estimate_synthesis_cost({"segments": sample_segments})

    content = json.loads(result["content"][0]["text"])

    assert content["can_synthesize"] is False
    assert "warning" in content


@pytest.mark.asyncio
async def test_synthesize_story_segments(sample_segments, tmp_path):
    """Test segment synthesis."""
    mock_synth = {
        "success": True,
        "audio_base64": "ZmFrZV9hdWRpb19kYXRh",  # base64 of "fake_audio_data"
    }

    with patch("codestory.voice.director.synthesize_with_style") as mock_voice:
        mock_voice.return_value = {
            "content": [{"type": "text", "text": json.dumps(mock_synth)}]
        }

        result = await synthesize_story_segments({
            "segments": sample_segments,
            "style": "documentary",
            "output_dir": str(tmp_path),
        })

    content = json.loads(result["content"][0]["text"])

    assert content["success"] is True
    assert len(content["segments"]) == 4
    assert content["summary"]["successful"] == 4
    assert content["summary"]["failed"] == 0


@pytest.mark.asyncio
async def test_synthesize_with_failures(sample_segments, tmp_path):
    """Test handling synthesis failures."""
    call_count = 0

    async def mock_synth_with_failure(args):
        nonlocal call_count
        call_count += 1
        if call_count == 2:  # Fail second segment
            return {"content": [{"type": "text", "text": json.dumps({
                "success": False,
                "error": "Rate limited",
            })}]}
        return {"content": [{"type": "text", "text": json.dumps({
            "success": True,
            "audio_base64": "ZmFrZV9hdWRpb19kYXRh",
        })}]}

    with patch("codestory.voice.director.synthesize_with_style", side_effect=mock_synth_with_failure):
        result = await synthesize_story_segments({
            "segments": sample_segments,
            "style": "documentary",
            "output_dir": str(tmp_path),
            "continue_on_error": True,
        })

    content = json.loads(result["content"][0]["text"])

    assert content["partial_success"] is True
    assert content["summary"]["successful"] == 3
    assert content["summary"]["failed"] == 1


@pytest.mark.asyncio
async def test_retry_failed_segments(sample_segments, tmp_path):
    """Test retry mechanism."""
    failed = [{"segment_index": 1, "segment_type": "chapter", "error": "Rate limited"}]

    mock_synth = {
        "success": True,
        "audio_base64": "ZmFrZV9hdWRpb19kYXRh",
    }

    with patch("codestory.voice.director.synthesize_with_style") as mock_voice:
        mock_voice.return_value = {
            "content": [{"type": "text", "text": json.dumps(mock_synth)}]
        }

        result = await retry_failed_segments({
            "failed_segments": failed,
            "original_segments": sample_segments,
            "style": "documentary",
            "output_dir": str(tmp_path),
            "max_retries": 3,
        })

    content = json.loads(result["content"][0]["text"])

    assert content["success"] is True
    assert len(content["recovered"]) == 1
    assert len(content["still_failed"]) == 0


@pytest.mark.asyncio
async def test_generate_voice_preview(tmp_path):
    """Test preview generation."""
    mock_synth = {
        "success": True,
        "audio_base64": "ZmFrZV9hdWRpb19kYXRh",
    }

    with patch("codestory.voice.director.synthesize_with_style") as mock_voice:
        mock_voice.return_value = {
            "content": [{"type": "text", "text": json.dumps(mock_synth)}]
        }

        result = await generate_voice_preview({
            "styles": ["documentary", "tutorial"],
            "output_dir": str(tmp_path),
        })

    content = json.loads(result["content"][0]["text"])

    assert content["success"] is True
    assert len(content["previews"]) == 2


def test_create_voice_director_agent():
    """Test agent definition creation."""
    agent = create_voice_director_agent()

    assert agent.model == "sonnet"
    assert "mcp__director__synthesize_story_segments" in agent.tools
    assert "mcp__voice__synthesize_with_style" in agent.tools
    assert len(agent.tools) >= 8


def test_create_voice_director_mcp_server():
    """Test MCP server creation."""
    server = create_voice_director_mcp_server()

    assert server is not None
```

## Files Created/Modified

| File | Action | Purpose |
|------|--------|---------|
| `src/codestory/voice/director.py` | Create | Voice Director orchestration tools |
| `src/codestory/agents/voice_director.py` | Create | Voice Director AgentDefinition |
| `src/codestory/voice/__init__.py` | Update | Export director tools |
| `tests/agents/test_voice_director.py` | Create | Agent tests |

## Validation Criteria

1. Voice Director uses `AgentDefinition` with `model="sonnet"`
2. All orchestration tools use `@tool` decorator
3. `estimate_synthesis_cost` checks quota before synthesis
4. `synthesize_story_segments` handles partial failures gracefully
5. `retry_failed_segments` implements exponential backoff
6. `generate_voice_preview` supports multiple styles
7. All tests pass

## Tool Summary

**Director Tools** (accessed as `mcp__director__<tool>`):
- `estimate_synthesis_cost` - Pre-flight quota check
- `synthesize_story_segments` - Batch synthesis
- `retry_failed_segments` - Error recovery
- `generate_voice_preview` - Style previews

**Voice Tools** (accessed as `mcp__voice__<tool>`):
- `synthesize_text` - Direct synthesis
- `synthesize_with_style` - Style-optimized synthesis
- `get_elevenlabs_voices` - List voices
- `check_elevenlabs_quota` - Monitor quota

## Next Step

Ready for 05-03-PLAN.md (Script Preparation)
