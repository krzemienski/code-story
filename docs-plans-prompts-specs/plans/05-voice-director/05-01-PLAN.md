# Plan 05-01: ElevenLabs API Integration

## Overview

**Phase**: 5 - Voice Director Agent
**Plan**: 01 of 04
**Depends on**: 04-05 (Script Assembly)
**Enables**: 05-02 (Voice Director Agent)

## Goal

Implement ElevenLabs API integration as MCP tools using Claude Agent SDK `@tool` decorator pattern for text-to-speech synthesis.

## Claude Agent SDK Pattern

Voice synthesis tools are implemented using `@tool` decorator with async functions:

```python
from claude_agent_sdk import tool

@tool(
    name="synthesize_text",
    description="Synthesize text to audio using ElevenLabs",
    input_schema={
        "type": "object",
        "properties": {
            "text": {"type": "string"},
            "voice_id": {"type": "string"},
        },
        "required": ["text"],
    },
)
async def synthesize_text(args: dict) -> dict:
    # Implementation
    return {"content": [{"type": "text", "text": json.dumps(result)}]}
```

## Tasks

### Task 1: Create ElevenLabs API Tools

**File**: `src/codestory/voice/elevenlabs.py`

```python
"""ElevenLabs TTS API tools for Code Story.

Provides @tool decorated functions for text-to-speech synthesis.
"""

import json
import asyncio
from typing import Any

import httpx

from claude_agent_sdk import tool

from codestory.core.config import get_settings


class ElevenLabsError(Exception):
    """ElevenLabs API error."""
    pass


# Voice presets for Code Story
VOICE_PRESETS = {
    "narrative": "pNInz6obpgDQGcFmaJgB",      # Adam - narrative storytelling
    "professional": "21m00Tcm4TlvDq8ikWAM",   # Rachel - professional delivery
    "friendly": "EXAVITQu4vr4xnSDxMaL",       # Bella - friendly conversational
    "authoritative": "VR6AewLTigWG4xSOukaG",  # Arnold - authoritative documentary
}

# Default voice settings per style
STYLE_DEFAULTS = {
    "fiction": {"voice": "narrative", "stability": 0.5, "similarity_boost": 0.75},
    "documentary": {"voice": "authoritative", "stability": 0.6, "similarity_boost": 0.8},
    "tutorial": {"voice": "friendly", "stability": 0.5, "similarity_boost": 0.75},
    "podcast": {"voice": "friendly", "stability": 0.45, "similarity_boost": 0.7},
    "technical": {"voice": "professional", "stability": 0.65, "similarity_boost": 0.8},
}


async def _get_client() -> httpx.AsyncClient:
    """Get configured HTTP client for ElevenLabs API."""
    settings = get_settings()
    return httpx.AsyncClient(
        base_url="https://api.elevenlabs.io/v1",
        headers={"xi-api-key": settings.elevenlabs_api_key},
        timeout=60.0,
    )


@tool(
    name="synthesize_text",
    description="Synthesize text to speech audio using ElevenLabs API",
    input_schema={
        "type": "object",
        "properties": {
            "text": {
                "type": "string",
                "description": "Text content to synthesize (max 5000 characters)",
            },
            "voice_id": {
                "type": "string",
                "description": "ElevenLabs voice ID or preset name (narrative, professional, friendly, authoritative)",
            },
            "model_id": {
                "type": "string",
                "description": "ElevenLabs model to use",
                "enum": ["eleven_multilingual_v2", "eleven_monolingual_v1", "eleven_turbo_v2"],
                "default": "eleven_multilingual_v2",
            },
            "stability": {
                "type": "number",
                "description": "Voice stability (0.0-1.0, higher = more consistent)",
                "minimum": 0.0,
                "maximum": 1.0,
            },
            "similarity_boost": {
                "type": "number",
                "description": "Voice similarity boost (0.0-1.0, higher = more like original)",
                "minimum": 0.0,
                "maximum": 1.0,
            },
            "style": {
                "type": "number",
                "description": "Style exaggeration (0.0-1.0)",
                "minimum": 0.0,
                "maximum": 1.0,
            },
        },
        "required": ["text"],
    },
)
async def synthesize_text(args: dict) -> dict:
    """Synthesize text to speech audio."""
    text = args["text"]

    # Validate text length
    if len(text) > 5000:
        return {"content": [{"type": "text", "text": json.dumps({
            "success": False,
            "error": f"Text exceeds 5000 character limit ({len(text)} chars)",
        })}]}

    # Resolve voice ID from preset or use directly
    voice_input = args.get("voice_id", "narrative")
    voice_id = VOICE_PRESETS.get(voice_input, voice_input)

    # Build voice settings
    voice_settings = {
        "stability": args.get("stability", 0.5),
        "similarity_boost": args.get("similarity_boost", 0.75),
    }
    if "style" in args:
        voice_settings["style"] = args["style"]

    model_id = args.get("model_id", "eleven_multilingual_v2")

    async with await _get_client() as client:
        try:
            response = await client.post(
                f"/text-to-speech/{voice_id}",
                json={
                    "text": text,
                    "model_id": model_id,
                    "voice_settings": voice_settings,
                },
            )

            if response.status_code == 429:
                return {"content": [{"type": "text", "text": json.dumps({
                    "success": False,
                    "error": "Rate limited - retry after 60 seconds",
                    "retry_after": 60,
                })}]}

            if response.status_code != 200:
                return {"content": [{"type": "text", "text": json.dumps({
                    "success": False,
                    "error": f"API error: {response.status_code} - {response.text}",
                })}]}

            # Return audio data as base64 for transport
            import base64
            audio_b64 = base64.b64encode(response.content).decode("utf-8")

            return {"content": [{"type": "text", "text": json.dumps({
                "success": True,
                "audio_base64": audio_b64,
                "audio_size_bytes": len(response.content),
                "character_count": len(text),
                "voice_id": voice_id,
                "model_id": model_id,
            }, indent=2)}]}

        except httpx.TimeoutException:
            return {"content": [{"type": "text", "text": json.dumps({
                "success": False,
                "error": "Request timed out - retry with smaller text chunk",
            })}]}


@tool(
    name="synthesize_with_style",
    description="Synthesize text using a predefined narrative style with optimal voice settings",
    input_schema={
        "type": "object",
        "properties": {
            "text": {
                "type": "string",
                "description": "Text content to synthesize",
            },
            "style": {
                "type": "string",
                "description": "Narrative style for voice selection",
                "enum": ["fiction", "documentary", "tutorial", "podcast", "technical"],
            },
            "segment_type": {
                "type": "string",
                "description": "Type of segment for voice adjustments",
                "enum": ["intro", "chapter", "transition", "outro"],
                "default": "chapter",
            },
        },
        "required": ["text", "style"],
    },
)
async def synthesize_with_style(args: dict) -> dict:
    """Synthesize text using predefined style settings."""
    text = args["text"]
    style = args["style"]
    segment_type = args.get("segment_type", "chapter")

    # Get style defaults
    style_config = STYLE_DEFAULTS.get(style, STYLE_DEFAULTS["documentary"])
    voice_key = style_config["voice"]
    voice_id = VOICE_PRESETS[voice_key]

    # Adjust settings for segment type
    stability = style_config["stability"]
    similarity_boost = style_config["similarity_boost"]

    # Intro/outro get slightly higher stability for consistent tone
    if segment_type in ("intro", "outro"):
        stability = min(1.0, stability + 0.1)
        similarity_boost = min(1.0, similarity_boost + 0.05)

    # Call the base synthesize tool
    return await synthesize_text({
        "text": text,
        "voice_id": voice_id,
        "stability": stability,
        "similarity_boost": similarity_boost,
    })


@tool(
    name="get_elevenlabs_voices",
    description="Get list of available ElevenLabs voices",
    input_schema={
        "type": "object",
        "properties": {
            "include_custom": {
                "type": "boolean",
                "description": "Include custom/cloned voices",
                "default": True,
            },
        },
    },
)
async def get_elevenlabs_voices(args: dict) -> dict:
    """Get available voices from ElevenLabs account."""
    include_custom = args.get("include_custom", True)

    async with await _get_client() as client:
        try:
            response = await client.get("/voices")

            if response.status_code != 200:
                return {"content": [{"type": "text", "text": json.dumps({
                    "success": False,
                    "error": f"Failed to fetch voices: {response.text}",
                })}]}

            data = response.json()
            voices = data.get("voices", [])

            # Filter if needed
            if not include_custom:
                voices = [v for v in voices if v.get("category") != "cloned"]

            result = {
                "success": True,
                "voices": [
                    {
                        "voice_id": v.get("voice_id"),
                        "name": v.get("name"),
                        "category": v.get("category"),
                        "description": v.get("description"),
                        "labels": v.get("labels", {}),
                    }
                    for v in voices
                ],
                "preset_voices": VOICE_PRESETS,
                "style_defaults": STYLE_DEFAULTS,
            }

            return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}

        except Exception as e:
            return {"content": [{"type": "text", "text": json.dumps({
                "success": False,
                "error": str(e),
            })}]}


@tool(
    name="check_elevenlabs_quota",
    description="Check remaining character quota on ElevenLabs account",
    input_schema={
        "type": "object",
        "properties": {},
    },
)
async def check_elevenlabs_quota(args: dict) -> dict:
    """Check remaining synthesis quota."""
    async with await _get_client() as client:
        try:
            response = await client.get("/user/subscription")

            if response.status_code != 200:
                return {"content": [{"type": "text", "text": json.dumps({
                    "success": False,
                    "error": f"Failed to fetch quota: {response.text}",
                })}]}

            data = response.json()

            result = {
                "success": True,
                "character_count": data.get("character_count", 0),
                "character_limit": data.get("character_limit", 0),
                "characters_remaining": data.get("character_limit", 0) - data.get("character_count", 0),
                "tier": data.get("tier"),
            }

            return {"content": [{"type": "text", "text": json.dumps(result, indent=2)}]}

        except Exception as e:
            return {"content": [{"type": "text", "text": json.dumps({
                "success": False,
                "error": str(e),
            })}]}
```

### Task 2: Create Voice MCP Server

**File**: `src/codestory/voice/server.py`

```python
"""MCP server for voice synthesis tools."""

from claude_agent_sdk import create_sdk_mcp_server

from codestory.voice.elevenlabs import (
    synthesize_text,
    synthesize_with_style,
    get_elevenlabs_voices,
    check_elevenlabs_quota,
)


def create_voice_mcp_server():
    """Create MCP server with voice synthesis tools."""
    return create_sdk_mcp_server(
        name="voice",
        version="1.0.0",
        tools=[
            synthesize_text,
            synthesize_with_style,
            get_elevenlabs_voices,
            check_elevenlabs_quota,
        ],
    )
```

### Task 3: Create Voice Package Init

**File**: `src/codestory/voice/__init__.py`

```python
"""Voice synthesis module for Code Story.

Provides ElevenLabs integration tools for text-to-speech.
"""

from codestory.voice.elevenlabs import (
    synthesize_text,
    synthesize_with_style,
    get_elevenlabs_voices,
    check_elevenlabs_quota,
    VOICE_PRESETS,
    STYLE_DEFAULTS,
    ElevenLabsError,
)
from codestory.voice.server import create_voice_mcp_server

__all__ = [
    # Tools
    "synthesize_text",
    "synthesize_with_style",
    "get_elevenlabs_voices",
    "check_elevenlabs_quota",
    # Constants
    "VOICE_PRESETS",
    "STYLE_DEFAULTS",
    # Server
    "create_voice_mcp_server",
    # Exceptions
    "ElevenLabsError",
]
```

### Task 4: Add Configuration Settings

**File**: `src/codestory/core/config.py` (add to existing)

```python
# Add to Settings class:
elevenlabs_api_key: str = ""
elevenlabs_default_model: str = "eleven_multilingual_v2"
```

### Task 5: Create Voice Tool Tests

**File**: `tests/voice/test_elevenlabs_tools.py`

```python
"""Tests for ElevenLabs voice synthesis tools."""

import pytest
import json
from unittest.mock import AsyncMock, patch, MagicMock

from codestory.voice.elevenlabs import (
    synthesize_text,
    synthesize_with_style,
    get_elevenlabs_voices,
    check_elevenlabs_quota,
    VOICE_PRESETS,
    STYLE_DEFAULTS,
)


@pytest.fixture
def mock_httpx_client():
    """Create mock httpx client."""
    mock = AsyncMock()
    mock.__aenter__ = AsyncMock(return_value=mock)
    mock.__aexit__ = AsyncMock(return_value=None)
    return mock


@pytest.mark.asyncio
async def test_synthesize_text_success(mock_httpx_client):
    """Test successful text synthesis."""
    mock_response = MagicMock()
    mock_response.status_code = 200
    mock_response.content = b"fake_audio_data"
    mock_httpx_client.post = AsyncMock(return_value=mock_response)

    with patch("codestory.voice.elevenlabs._get_client", return_value=mock_httpx_client):
        result = await synthesize_text({
            "text": "Hello, welcome to Code Story.",
            "voice_id": "narrative",
        })

    # Parse result
    content = json.loads(result["content"][0]["text"])

    assert content["success"] is True
    assert "audio_base64" in content
    assert content["audio_size_bytes"] == len(b"fake_audio_data")
    assert content["character_count"] == 30


@pytest.mark.asyncio
async def test_synthesize_text_exceeds_limit():
    """Test text exceeding character limit."""
    long_text = "x" * 5001

    result = await synthesize_text({"text": long_text})
    content = json.loads(result["content"][0]["text"])

    assert content["success"] is False
    assert "exceeds 5000 character limit" in content["error"]


@pytest.mark.asyncio
async def test_synthesize_text_rate_limited(mock_httpx_client):
    """Test rate limiting handling."""
    mock_response = MagicMock()
    mock_response.status_code = 429
    mock_httpx_client.post = AsyncMock(return_value=mock_response)

    with patch("codestory.voice.elevenlabs._get_client", return_value=mock_httpx_client):
        result = await synthesize_text({
            "text": "Test text",
        })

    content = json.loads(result["content"][0]["text"])

    assert content["success"] is False
    assert "Rate limited" in content["error"]
    assert content["retry_after"] == 60


@pytest.mark.asyncio
async def test_synthesize_with_style():
    """Test style-based synthesis."""
    with patch("codestory.voice.elevenlabs.synthesize_text") as mock_synth:
        mock_synth.return_value = {"content": [{"type": "text", "text": "{}"}]}

        await synthesize_with_style({
            "text": "Test",
            "style": "documentary",
            "segment_type": "intro",
        })

        # Check that synthesize_text was called with documentary voice
        call_args = mock_synth.call_args[0][0]
        assert call_args["voice_id"] == VOICE_PRESETS["authoritative"]
        # Intro gets higher stability
        assert call_args["stability"] == 0.7  # 0.6 + 0.1


@pytest.mark.asyncio
async def test_get_voices(mock_httpx_client):
    """Test fetching available voices."""
    mock_response = MagicMock()
    mock_response.status_code = 200
    mock_response.json.return_value = {
        "voices": [
            {"voice_id": "v1", "name": "Adam", "category": "premade"},
            {"voice_id": "v2", "name": "Custom", "category": "cloned"},
        ]
    }
    mock_httpx_client.get = AsyncMock(return_value=mock_response)

    with patch("codestory.voice.elevenlabs._get_client", return_value=mock_httpx_client):
        result = await get_elevenlabs_voices({"include_custom": True})

    content = json.loads(result["content"][0]["text"])

    assert content["success"] is True
    assert len(content["voices"]) == 2
    assert "preset_voices" in content


@pytest.mark.asyncio
async def test_check_quota(mock_httpx_client):
    """Test quota checking."""
    mock_response = MagicMock()
    mock_response.status_code = 200
    mock_response.json.return_value = {
        "character_count": 5000,
        "character_limit": 100000,
        "tier": "pro",
    }
    mock_httpx_client.get = AsyncMock(return_value=mock_response)

    with patch("codestory.voice.elevenlabs._get_client", return_value=mock_httpx_client):
        result = await check_elevenlabs_quota({})

    content = json.loads(result["content"][0]["text"])

    assert content["success"] is True
    assert content["characters_remaining"] == 95000
    assert content["tier"] == "pro"


def test_voice_presets():
    """Test voice presets are defined."""
    assert "narrative" in VOICE_PRESETS
    assert "professional" in VOICE_PRESETS
    assert "friendly" in VOICE_PRESETS
    assert "authoritative" in VOICE_PRESETS


def test_style_defaults():
    """Test all styles have defaults."""
    for style in ["fiction", "documentary", "tutorial", "podcast", "technical"]:
        assert style in STYLE_DEFAULTS
        assert "voice" in STYLE_DEFAULTS[style]
        assert "stability" in STYLE_DEFAULTS[style]
        assert "similarity_boost" in STYLE_DEFAULTS[style]
```

## Files Created/Modified

| File | Action | Purpose |
|------|--------|---------|
| `src/codestory/voice/__init__.py` | Create | Voice package init |
| `src/codestory/voice/elevenlabs.py` | Create | ElevenLabs API tools |
| `src/codestory/voice/server.py` | Create | Voice MCP server |
| `src/codestory/core/config.py` | Modify | Add ElevenLabs settings |
| `tests/voice/test_elevenlabs_tools.py` | Create | Tool tests |

## Validation Criteria

1. All tools use `@tool` decorator with proper `input_schema`
2. Tools return `{"content": [{"type": "text", "text": json.dumps(...)}]}`
3. Voice presets map to ElevenLabs voice IDs
4. Style defaults provide optimal settings per narrative type
5. Error handling covers rate limits, timeouts, and API errors
6. Character limit validation (5000 chars) before API calls
7. All tests pass

## Tool Naming Convention

Tools are accessed via MCP server as: `mcp__voice__<tool_name>`

- `mcp__voice__synthesize_text`
- `mcp__voice__synthesize_with_style`
- `mcp__voice__get_elevenlabs_voices`
- `mcp__voice__check_elevenlabs_quota`

## Next Step

Ready for 05-02-PLAN.md (Voice Director Agent)
